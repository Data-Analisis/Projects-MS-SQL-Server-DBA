-- 
-- Script was generated by Devart dbForge Studio 2019 for SQL Server, Version 5.8.107.0
-- Product Home Page: http://www.devart.com/dbforge/sql/studio
-- Script date 26.12.2019 11:28:43
-- Server version: 14.00.1000
-- Run this script against SRV to synchronize it with SRV_2019
-- Please backup your target database before running this script
-- 
SET CONCAT_NULL_YIELDS_NULL, ANSI_NULLS, ANSI_PADDING, QUOTED_IDENTIFIER, ANSI_WARNINGS, ARITHABORT, XACT_ABORT ON
SET NUMERIC_ROUNDABORT, IMPLICIT_TRANSACTIONS OFF
GO

USE [SRV]
GO

IF DB_NAME() <> N'SRV' SET NOEXEC ON
GO


--
-- Set transaction isolation level
--
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
GO

--
-- Start Transaction
--
BEGIN TRANSACTION
GO

--
-- Add extended property [MS_Description] on schema [zabbix]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Здесь располагаются объекты для вывода значений в Zabbix', 'SCHEMA', N'zabbix'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [zabbix].[GetServerPerformance_Info]
--
GO
--Быстрый мониторинг основных параметров производительности
--Автор: Прилепа Б.А. - АБД
--09.07.2019

CREATE PROCEDURE [zabbix].[GetServerPerformance_Info] @HighLoadCPU INT = 60,
	@SuperHighLoadCPU INT = 80,
	--@MinLimitRAM INT = 1024,
	@CountBlocks INT = 1,
	@HighCountBlocks INT = 5,
	@MaxWaitQuery INT = 15,
	@LockMaxWaitQuery_ms INT = 300
AS
BEGIN
	SET NOCOUNT ON;
	SET XACT_ABORT ON; 

	--Высчитываем число доступных ноде процессоров
	declare @cpu_count int
	set @cpu_count=(select top 1 cpu_count from sys.dm_os_nodes where node_state_desc='ONLINE')-1 --Так как отсчет cpu_id идет с нуля

	;WITH os_schedulers
	AS
	(SELECT
			cpu_id
		   ,active_workers_count
		   ,load_factor
		FROM sys.dm_os_schedulers
		WHERE cpu_id <= @cpu_count 
		      AND [status] = 'VISIBLE ONLINE'),
	Offline_cpu (Offline_cpu)
	AS
	--https://docs.microsoft.com/ru-ru/sql/relational-databases/system-dynamic-management-views/sys-dm-os-schedulers-transact-sql?view=sql-server-ver15
	(SELECT
			COUNT([status]) offline_cpu
		FROM sys.dm_os_schedulers
		WHERE cpu_id <= @cpu_count 
		      AND [status] = 'VISIBLE OFFLINE'
	)

	SELECT
		RES = (CASE
			WHEN [highly_loaded_cores_%] >= @SuperHighLoadCPU 
			OR ([blocking_queries] > @CountBlocks AND [highly_loaded_cores_%] >= @HighLoadCPU)
			THEN 8 --Сильная перегрузка CPU для доступных ядер (повторение такой картины говорит о крайне критической проблеме с нагрузкой ЦП)
			WHEN [highly_loaded_cores_%] >= @HighLoadCPU
			AND ([blocking_queries] = 0 AND ([max_waiting_query_sec] >= @MaxWaitQuery OR [maintenance_max_waiting_query_sec] >= @MaxWaitQuery)) THEN 7 --Высокое значение загруженности CPU (без блокировок, есть запросы свыше @MaxWaitQuery)
			WHEN [highly_loaded_cores_%] >= @HighLoadCPU
			AND ([blocking_queries] = 0 AND ([max_waiting_query_sec] < @MaxWaitQuery AND [maintenance_max_waiting_query_sec] < @MaxWaitQuery)) THEN 6 --Высокое значение загруженности CPU (без блокировок, а также слишком длинный запросов)			
			WHEN [blocking_queries] >= @HighCountBlocks OR
				([blocking_queries] >= @CountBlocks AND
				[max_lock_waiting_ms] >= @LockMaxWaitQuery_ms * 10) THEN 5 --Критическая проблема с блокировками 
			WHEN [blocking_queries] > @CountBlocks AND
				[blocking_queries] < @HighCountBlocks AND
				[max_lock_waiting_ms] >= @LockMaxWaitQuery_ms THEN 4 --Несколько долгих блокировок
			--Частое повторение говорит о значимой критичности плохой производительности одного или нескольких запросов
			WHEN [blocking_queries] = @CountBlocks AND
				[max_lock_waiting_ms] >= @LockMaxWaitQuery_ms THEN 3 --Одиночная долгая блокировка
			--Частое повторение говорит о системной проблеме с одним запросом
			WHEN [blocking_queries] = 0 AND
				[max_waiting_query_sec] >= @MaxWaitQuery THEN 2 --Долгие SQL запросы, кроме обслуживания и профилирования
            WHEN [blocking_queries] = 0 AND
				[maintenance_max_waiting_query_sec] >= @MaxWaitQuery THEN 1 --MS SQL процессы обслуживания, задача
			WHEN (SELECT
						Offline_cpu
					FROM Offline_cpu)
				> 0 THEN 9 --Есть ядра, которых не видит MS SQL, но они доступны (требуется рестарт сервиса)
			ELSE 0
		END)
	FROM (SELECT
			[highly_loaded_cores_%],
			[Offline_cpu],
			[max_waiting_query_sec],
			[blocking_queries],
			[maintenance_max_waiting_query_sec],
			[max_lock_waiting_ms]
		FROM (SELECT  (SELECT
						CAST(CAST(ROUND(COUNT(DISTINCT cpu_id) / (SELECT
								COUNT(DISTINCT cpu_id) / 1.0
							FROM os_schedulers)
						, 2) AS NUMERIC(4, 2)) * 100 AS INT)
					FROM os_schedulers
					WHERE ((active_workers_count > 8
					AND load_factor > 3) /*повышенная нагрузка на ядро*/ OR (active_workers_count <= 8
					AND load_factor > 9)  /*повышенный фактор нагрузки*/))
				[highly_loaded_cores_%]
			   ,CASE
					WHEN (SELECT
								Offline_cpu
							FROM Offline_cpu)
						> 0 THEN (SELECT
								Offline_cpu
							FROM Offline_cpu)
					ELSE 0
				END Offline_cpu
			   --Запросы JOB-ов, сервисов, пользовательские запросы
			   ,(SELECT
					DATEDIFF(SS, MIN(start_time), GETDATE()) SS
					FROM sys.dm_exec_requests
					WHERE [connection_id] IS NOT NULL
					AND last_wait_type NOT IN ('XE_LIVE_TARGET_TVF' /*Сборщик XE Events*/, --АБД сам следит за провилированием
											   'TRACEWRITE' /*Профайлер*/,
											    'PREEMPTIVE_OS_ENCRYPTMESSAGE'/*упреждающее сообщение шифрования ОС*/,'BROKER_RECEIVE_WAITFOR' /*Таймер диалога*/)
					AND (command NOT IN ('UPDATE STATISTICS','BACKUP DATABASE','BACKUP LOG','RESTORE DATABASE','RESTORE LOG','DBCC')
					--Обновление стастик, DBCC, операции создание и восстановления резервных копий
					))
				[max_waiting_query_sec]
				,(SELECT
					DATEDIFF(SS, MIN(start_time), GETDATE()) SS
					FROM sys.dm_exec_requests
					WHERE [connection_id] IS NOT NULL
					AND last_wait_type NOT IN ('XE_LIVE_TARGET_TVF' /*Сборщик XE Events*/, --АБД сам следит за провилированием
											   'TRACEWRITE' /*Профайлер*/,
											    'PREEMPTIVE_OS_ENCRYPTMESSAGE'/*упреждающее сообщение шифрования ОС*/,'BROKER_RECEIVE_WAITFOR' /*Таймер диалога*/)
					AND (command IN ('UPDATE STATISTICS','BACKUP DATABASE','BACKUP LOG','RESTORE DATABASE','RESTORE LOG','DBCC')
					--Обновление стастик, DBCC, операции создание и восстановления резервных копий
					))
				[maintenance_max_waiting_query_sec]
			   ,(SELECT
						COUNT(distinct blocking_session_id)
					FROM sys.dm_os_waiting_tasks
					WHERE blocking_session_id IS NOT NULL)
				[blocking_queries]
				,(SELECT
						max(wait_duration_ms)
					FROM sys.dm_os_waiting_tasks
					WHERE blocking_session_id IS NOT NULL)
				[max_lock_waiting_ms]
				) a) TBL


END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [zabbix].[GetServerPerformance_Info]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Хранимая процедура для быстрого анализа основных проблем на сервере MS SQL с 

1 - нет блокировок, но время max время выполнения запроса >=30 сек.
2 - имеется одна блокировка в соотношении с max долгим запросом >=30 сек.
3 - имеется 1-4 блокировки в соотношении с max долгим запросом >=30 сек.
4 - имеется 5 и более блокировок  или (от 1 и более блокировки с max долгим запросом от 90 сек.
5 - низкое значение доступной RAM для ОС ([Avail_RAM_Memory_Mb] <= @MinLimitRAM)
<=1024 Mb
6 - крайне низкое значение доступной RAM для ОС ([Avail_RAM_Memory_Mb] <= @MinLimitRAM)
<=206 Mb или доступная для MS SQL RAM меньше 100 Мб
7 - бол-во ядер с высокой нагрузкой на ЦП   ( [highly_loaded_cores_%] >= @HighLoadCPU)
>60-80% всех ядер доступных MS SQL сильно нагружены
8 - бол-во ядер со сверхвысокой нагрузкой на ЦП   ( [highly_loaded_cores_%] >= @SuperHighLoadCPU)
>80% всех ядер доступных MS SQL сильно нагружены
9 - есть доступные ядра, но они помечены OFFLINE для MS SQL', 'SCHEMA', N'zabbix', 'PROCEDURE', N'GetServerPerformance_Info'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [zabbix].[GetFileBackupProblemCount]
--
GO





-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE   PROCEDURE [zabbix].[GetFileBackupProblemCount]
	@path    nvarchar(255) = N'E:\DBTemplates\' --путь к резервным копиям
AS
BEGIN
	/*
		Количество проблемных резервных копий по указанному пути (нехватка или дата создания свыше 24 часов)
	*/

	--SET QUERY_GOVERNOR_COST_LIMIT 0;
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	SET XACT_ABORT ON;

	declare @servername nvarchar(255)=cast(SERVERPROPERTY(N'MachineName') as nvarchar(255));

	--set dateformat dmy;

	declare @srv nvarchar(2);
	declare @SourceFolder nvarchar(500);
	declare @inf table(inf nvarchar(4000));
	declare @tbl table([FileBak] nvarchar(255));
	declare @cmd nvarchar(4000);
	declare @ind int=6;
	declare @str_date nvarchar(32);
	declare @style_date tinyint;

	declare @server_name nvarchar(255)=cast(SERVERPROPERTY(N'ComputerNamePhysicalNetBIOS') as nvarchar(255));
	
	if(left(@server_name, 3) in (N'HLT', N'STG'))
	begin
		set @srv = right(@servername, 2);
		set @SourceFolder = N'\\backup-srv01\SQL_Backups\DB\PRD-SQL-SRV'+@srv;
		set @cmd=N'dir /b '+@SourceFolder+N'\*.bak';
	
		insert into @tbl([FileBak])
		exec xp_cmdshell @cmd;
	end
	else
	begin
		while(@ind>0)
		begin
			set @srv = cast(@ind as nvarchar(2));
			if(len(@srv)=1) set @srv=N'0'+@srv;
			set @SourceFolder = N'\\backup-srv01\SQL_Backups\DB\PRD-SQL-SRV'+@srv;
			set @cmd=N'dir /b '+@SourceFolder+N'\*.bak';
	
			insert into @tbl([FileBak])
			exec xp_cmdshell @cmd;
	
			set @ind=@ind-1;
		end
	end
	
	delete from @tbl
	where [FileBak]=N'File Not Found'
	   or [FileBak] is null;
	
	set @cmd=N'dir '+@path+N'\*.bak';
	
	insert into @inf
	exec xp_cmdshell @cmd;

	set @str_date=(
		select top(1) substring([inf], 1, 32) 
		from @inf
		where [inf] like '[0-9][0-9]%'
	);

	if(@str_date like '%/%') set @style_date=0;
	else if(@str_date like '%.%') set @style_date=104;
	
	;with tbl0 as (
		select replace(replace(inf,',',''),'.bak','') as inf
		from @inf
		where right(inf,4)='.bak'
	)
	, tbl1 as (
		select convert(datetime, left(inf,20), @style_date) as [DateModify],
		replace(rtrim(ltrim(substring(inf,21,len(inf)))),' ',',') as inf
		from tbl0
	)
	, tbl2 as (
		select [DateModify],
		left(inf,charindex(N',',inf)-1) as inf,
		replace(inf,left(inf,charindex(',',inf)),'') as FileBak
		from tbl1
	)
	, tbl_res as (
		select t.[DateModify],
		replace(t.inf, char(160), N'') as inf,
		t.FileBak,
		tt.FileBak as SourceFileBak
		from @tbl as tt
		left outer join tbl2 as t on t.[FileBak]=substring(tt.[FileBak],1, len(tt.[FileBak])-len(N'.bak'))
	)
	select count(*) as [count]
	--select [DateModify],
	--cast(replace(inf, N' ', N'') as bigint)/1024.0/1024.0 as [size(Mb)],
	--FileBak,
	--SourceFileBak
	from tbl_res
	where [DateModify] is null
	or [DateModify]<=DateAdd(hour,-36,GetDate());
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [zabbix].[GetFileBackupProblemCount]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Возвращает количество проблемных резервных копий по указанному пути (нехватка или дата создания свыше 24 часов)', 'SCHEMA', N'zabbix', 'PROCEDURE', N'GetFileBackupProblemCount'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [zabbix].[GetCurrentInMaxSizeFile]
--
GO





-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE   PROCEDURE [zabbix].[GetCurrentInMaxSizeFile]
AS
BEGIN
	/*
		Текущий размер файла БД приблизился к максимально установленному значению
	*/

	SET QUERY_GOVERNOR_COST_LIMIT 0;
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	SET XACT_ABORT ON;

	SELECT
		COUNT(*) AS [count]
	FROM sys.master_files
	WHERE [size] >= ([max_size] * 0.9)
	AND [max_size] > 0;
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [zabbix].[GetCurrentInMaxSizeFile]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Возвращает количество файлов БД, текущие размеры которых приблизились к максимально установленным значениям', 'SCHEMA', N'zabbix', 'PROCEDURE', N'GetCurrentInMaxSizeFile'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [zabbix].[GetSpaceusedDBServer]
--
GO





-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER PROCEDURE [zabbix].[GetSpaceusedDBServer]
AS
BEGIN
	/*
		информация о занятом месте в БД (данные+индексы) в МБ
	*/

	SET QUERY_GOVERNOR_COST_LIMIT 0;
	SET NOCOUNT ON;

	declare @db_name nvarchar(255);
	declare @sql nvarchar(max);
	declare @tbl table ([DBName] nvarchar(255), [DBSizeMB] decimal(18,3), [UnallocatedSpaceMB] decimal(18,3), [ReservedMB] decimal(18,3), [DataMB] decimal(18,3), [IndexSizeMB] decimal(18,3), [UnusedMB] decimal(18,3));

	select [name]
	into #tbls
	from sys.databases
	where [is_read_only]=0
	and [state]=0 --ONLINE
	and [user_access]=0--MULTI_USER
	and [database_id]>4;

	while(exists(select top(1) 1 from #tbls))
	begin
		select top(1)
		@db_name=[name]
		from #tbls;

		set @sql=N'USE ['+@db_name+']; '+
		N'IF(object_id('+N''''+N'[inf].[SpaceusedDB]'+N''''+N') is not null) select [DBName], [DBSizeMB], [UnallocatedSpaceMB], [ReservedMB], [DataMB], [IndexSizeMB], [UnusedMB] from [inf].[SpaceusedDB]();';

		insert into @tbl([DBName], [DBSizeMB], [UnallocatedSpaceMB], [ReservedMB], [DataMB], [IndexSizeMB], [UnusedMB])
		exec sp_executesql @sql;

		delete from #tbls
		where [name]=@db_name;
	end

	drop table #tbls;

	select SUM([DataMB]+[IndexSizeMB]) as [value]
	from @tbl;
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [zabbix].[GetExistsErrorInLog]
--
GO





-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER PROCEDURE [zabbix].[GetExistsErrorInLog]
AS
BEGIN
	/*
		Признак существования в журнале ошибок MS SQL Server подозрительных записей
	*/

	--SET QUERY_GOVERNOR_COST_LIMIT 0;
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	SET XACT_ABORT ON;

	declare @rez bit=0;

	declare @dt datetime=DateAdd(hour, -3, GetDate());
	declare @str nvarchar(255)=cast(@dt as nvarchar(255));
	
	declare @tbl table ([LogDate] datetime, [ProcessInfo] nvarchar(255), [Text] nvarchar(max));
	declare @tbl_filtered table ([LogDate] datetime, [ProcessInfo] nvarchar(255), [Text] nvarchar(max));

	declare @server_name nvarchar(255)=cast(SERVERPROPERTY(N'ComputerNamePhysicalNetBIOS') as nvarchar(255));

	if((left(@server_name,3) in (N'PRD')) or (@server_name like 'SQL_SERVICES%') or (@server_name in ('com-dba-01')))
	begin
		--читкаем текущий журнал
		insert into @tbl ([LogDate], [ProcessInfo], [Text])
		EXEC master.dbo.xp_readerrorlog 0, 1, N'cost limit', NULL, @str, NULL, 'DESC'; --один раз-пищать
		
		insert into @tbl ([LogDate], [ProcessInfo], [Text])
		EXEC master.dbo.xp_readerrorlog 0, 1, N'failed', NULL, @str, NULL, 'DESC';--при [ProcessInfo]='Logon' проверить частоту, а в остальных случаях-пищать
		
		--insert into @tbl ([LogDate], [ProcessInfo], [Text])
		--EXEC master.dbo.xp_readerrorlog 1, 1, N'cost limit', NULL, NULL, NULL, 'DESC'; --один раз-пищать
		
		--insert into @tbl ([LogDate], [ProcessInfo], [Text])
		--EXEC master.dbo.xp_readerrorlog 1, 1, N'failed', NULL, NULL, NULL, 'DESC';--при [ProcessInf`o]='Logon' проверить частоту, а в остальных случаях-пищать
		
		--insert into @tbl ([LogDate], [ProcessInfo], [Text])
		--EXEC master.dbo.xp_readerrorlog 2, 1, N'cost limit', NULL, NULL, NULL, 'DESC'; --один раз-пищать
		
		--insert into @tbl ([LogDate], [ProcessInfo], [Text])
		--EXEC master.dbo.xp_readerrorlog 2, 1, N'failed', NULL, NULL, NULL, 'DESC';--при [ProcessInfo]='Logon' проверить частоту, а в остальных случаях-пищать
		
		--insert into @tbl ([LogDate], [ProcessInfo], [Text])
		--EXEC master.dbo.xp_readerrorlog 3, 1, N'cost limit', NULL, NULL, NULL, 'DESC'; --один раз-пищать
		
		--insert into @tbl ([LogDate], [ProcessInfo], [Text])
		--EXEC master.dbo.xp_readerrorlog 3, 1, N'failed', NULL, NULL, NULL, 'DESC';--при [ProcessInfo]='Logon' проверить частоту, а в остальных случаях-пищать
		
		--insert into @tbl ([LogDate], [ProcessInfo], [Text])
		--EXEC master.dbo.xp_readerrorlog 4, 1, N'cost limit', NULL, NULL, NULL, 'DESC'; --один раз-пищать
		
		--insert into @tbl ([LogDate], [ProcessInfo], [Text])
		--EXEC master.dbo.xp_readerrorlog 4, 1, N'failed', NULL, NULL, NULL, 'DESC';--при [ProcessInfo]='Logon' проверить частоту, а в остальных случаях-пищать
		
		--insert into @tbl ([LogDate], [ProcessInfo], [Text])
		--EXEC master.dbo.xp_readerrorlog 5, 1, N'cost limit', NULL, NULL, NULL, 'DESC'; --один раз-пищать
		
		--insert into @tbl ([LogDate], [ProcessInfo], [Text])
		--EXEC master.dbo.xp_readerrorlog 5, 1, N'failed', NULL, NULL, NULL, 'DESC';--при [ProcessInfo]='Logon' проверить частоту, а в остальных случаях-пищать
		
		--insert into @tbl ([LogDate], [ProcessInfo], [Text])
		--EXEC master.dbo.xp_readerrorlog 6, 1, N'cost limit', NULL, NULL, NULL, 'DESC'; --один раз-пищать
		
		--insert into @tbl ([LogDate], [ProcessInfo], [Text])
		--EXEC master.dbo.xp_readerrorlog 6, 1, N'failed', NULL, NULL, NULL, 'DESC';--при [ProcessInfo]='Logon' проверить частоту, а в остальных случаях-пищать
		
		insert into @tbl_filtered ([LogDate], [ProcessInfo], [Text])
		select [LogDate], [ProcessInfo], [Text]
		from @tbl
		where [Text] not like N'Audit: Server Audit: %Initialized and Assigned State: START_FAILED'
		  and [Text] <> N'Creating view sysmail_faileditems...'
		  and [Text] not like N'Configuration option % changed from %. Run the RECONFIGURE statement to install.'
		
		  --and [Text] <> N'Perfmon counters for resource governor pools and groups failed to initialize and are disabled.'
		  --and [Text] <> N'A read operation on a large object failed while sending data to the client. A common cause for this is if the application is running in READ UNCOMMITTED isolation level. This connection will be terminated.'
		  --and [Text] <> N'Implied authentication manager initialization failed. Implied authentication will be disabled.'
		  --and [Text] <> N'InitializeExternalUserGroupSid failed. Implied authentication will be disabled.'
		  --and [Text] not like N'Login failed%'
		  --and [Text] not like N'BACKUP failed to complete the command BACKUP%'
		  --and [Text] not like N'The client was unable to reuse a session with SPID %, which had been reset for connection pooling. The failure ID is %. This error may have been caused by an earlier operation failing. Check the error logs for failed operations immediately before this error message.'
		  --and [Text] not like N'BackupDiskFile::CreateMedia: Backup device %'
		  --and [Text] not like N'FCB::Open failed: Could not open file %'
		  --and [Text] not like N'One or more recovery units belonging to database % failed to generate a checkpoint. This is typically caused by lack of system resources such as disk or memory, or in some cases due to database corruption. Examine previous entries in the error log for more detailed information on this failure.'
		  --and [Text] not like N'SSPI handshake failed with error code %, state % while establishing a connection with integrated security; the connection has been closed. Reason: AcceptSecurityContext failed. The Windows error code indicates the cause of failure. The logon attempt failed %'
		--group by [ProcessInfo], [Text]
		--where [LogDate]>='2019-05-14T00:00:00'
		
		if(exists(
					select top(1) 1
					from @tbl_filtered
					where [ProcessInfo]='Logon'
					group by [Text]
					having count(*)>=5
				 ))
		begin
			set @rez=1;
		end

		if(@rez=0)
		begin
			if(exists(
					select top(1) 1
					from @tbl_filtered
					where [Text] not like N'Login failed%'
				 ))
			begin
				set @rez=1;
			end
		end
	end
	else set @rez=0;

	select cast(@rez as int) as [value];
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [zabbix].[GetActiveUserTransaction]
--
GO





-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER PROCEDURE [zabbix].[GetActiveUserTransaction]
AS
BEGIN
	/*
		Количество активных пользовательских транзакций
	*/

	--SET QUERY_GOVERNOR_COST_LIMIT 0;
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	SET XACT_ABORT ON;

	select count(*) as [count]
	from sys.dm_tran_session_transactions
	where [is_user_transaction]=1;
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [zabbix].[GetActiveRequestProblemCount]
--
GO


-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER PROCEDURE [zabbix].[GetActiveRequestProblemCount]
	@diffSec    int       =20 --20 секунд на мониториг долгих запросов ctr'SELECT', 'INSERT', 'UPDATE', 'DELETE'
	,@diffSecBackUp    int       =300 --операции бэкпирования, анализ перестроение индексов
	,@Wait_Duration_ms int = 3000
	,@Wait_Duration_semaphore_ms int = 500
AS
BEGIN
	/*
		Количество проблемных запросов в режиме реального времени
	*/

	--SET QUERY_GOVERNOR_COST_LIMIT 0;
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	declare @data datetime=getdate();

	declare @server_name nvarchar(255)=cast(SERVERPROPERTY(N'ComputerNamePhysicalNetBIOS') as nvarchar(255));
 
	select case when ((left(@server_name, 3) in (N'PRD', N'COM')) or (@server_name like N'SQL_SERVICES%')) then count(distinct ER.session_id) 
				else case when (count(distinct ER.session_id)>3) then 3 else count(distinct ER.session_id) end
		   end as [count]
	from sys.dm_exec_requests ER with(readuncommitted)
	inner join sys.dm_exec_sessions ES with(readuncommitted) on ES.session_id = ER.session_id
	left outer join sys.dm_os_waiting_tasks AS t with(readuncommitted) on(ER.session_id=t.blocking_session_id)
	where ER.connection_id is not null and
	((left(last_wait_type,3) ='LCK'/*локи*/ OR last_wait_type='AWAITING COMMAND' /*скорее всего косяк в коде разрабов или триггер, ожидание внешнее от приложений*/)
	  AND t.wait_duration_ms > @Wait_Duration_ms)
	    OR (last_wait_type in('RESOURCE_SEMAPHORE','RESOURCE_SEMAPHORE_QUERY_COMPILE' /*Нехватка RAM под запрос, утечки RAM*/,'PAGEIOLATCH_UP'
	  /*задача ожидает кратковременной блокировки буфера, находящегося в состоянии запроса ввода-вывода (часто связанно с tempdb)*/)
	  and ER.[start_time]<=DateAdd(ms, -@Wait_Duration_semaphore_ms, @data))
	   OR (ER.[start_time]<=DateAdd(second, -@diffSec, @data) AND ER.command in('SELECT', 'INSERT', 'UPDATE', 'DELETE')
	   OR (ER.[start_time]<=DateAdd(second, -@diffSecBackUp, @data) AND ER.command in('BACKUP LOG', 'BACKUP DATABASE', 'DBCC')
	   OR (ER.last_wait_type='CXPACKET' and ER.[start_time]<=DateAdd(second, -@diffSec, @data)))
	  ) and ER.session_id>50;
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create function [srv].[ReturnTime]
--
GO



CREATE FUNCTION [srv].[ReturnTime] (@d int)
	RETURNS nvarchar(50)	
AS
BEGIN
	DECLARE @res nvarchar(50);

	set @res=(
			  case when (@d<60)				 then N'00:'+right(N'0'+cast(@d as nvarchar(2)),2) 
				   when (@d>=60 and @d<6000) then right(N'0'+cast(floor(@d/60.0) as nvarchar(2)),2)
											+N':'+right(N'0'+cast(ceiling(((@d/60.0)-floor(@d/60.0))*60)  as nvarchar(50)),2)
				   when (@d>=6000) then right(N'0'+cast(floor(@d/60.0/100.0) as nvarchar(50)),2)+ N':'+
			    right(N'0'+cast(floor((@d - (floor(@d/60.0/100.0))*6000)/60.0) as nvarchar(50)),2) +N':'+
				right(N'0'+cast(ceiling((((@d - (floor(@d/60.0/100.0))*6000)/60.0)- floor((@d - (floor(@d/60.0/100.0))*6000)/60.0))*60)     as nvarchar(50)),2)
			  else N'00:00' 
			  end
			 );
	
	return @res;
END;


GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on function [srv].[ReturnTime]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Функция форматировния вывода времени выполнения SQL JOBS из БД msdb. Время переводится в удобичитаемый формат.', 'SCHEMA', N'srv', 'FUNCTION', N'ReturnTime'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [srv].[GetStatisticJobs]
--
GO








--Данные по выполнению заданий на сервере
--Автор: Прилепа Б.А. - АБД
--Дата создания: 16.01.2017
--exec [dbo].[GetStatisticJobs] @srv='1csrv'

CREATE procedure [srv].[GetStatisticJobs]
as
begin
	set nocount on;
	set xact_abort on;

	declare @servername nvarchar(255)=cast(SERVERPROPERTY(N'MachineName') as nvarchar(255));
	
	select @servername as SERVERNAME
	,[name]
	,[count]
	,[srv].[ReturnTime](avg_run_duration) avg_run_duration
	,[srv].[ReturnTime](min_run_duration) min_run_duration
	,[srv].[ReturnTime](max_run_duration) max_run_duration
	,[srv].[ReturnTime](sum_run_duration) sum_run_duration
	,[enabled]
	,cast(cast(run_date as nvarchar(255)) as date) as run_date
	,last_run=(
				case when len(last_run)=5 then N'0'+left(last_run,1)+N':'+right(left(last_run,3),2)+N':'+right(last_run,2)
					 when len(last_run)=6 then left(last_run,2)+N':'+right(left(last_run,4),2)+N':'+right(last_run,2)
				end
			  )
	,last_duration=[srv].[ReturnTime](last_duration)
	,last_run_status=case when last_run_status=0 then N'Неуспех' 
						  when last_run_status=1 then N'Успех' 
						  when last_run_status=2 then N'Повтор'
						  when last_run_status=3 then N'Отмена'
					 end
	,Неуспехов
	,date_created
	from
	(
		select top(1000)
		b.job_id
		,MAX([enabled]) as [enabled]
		,b.[name]
		,b.date_created
		,run_date
		,max(run_time) as last_run
		,AVG(run_duration) as avg_run_duration
		,MIN(run_duration) as min_run_duration
		,MAX(run_duration) as max_run_duration
		,SUM(run_duration) as sum_run_duration
		,SUM(case when run_status=0 then 1 else 0 end) as Неуспехов
		,last_run_status=(select top 1 run_status from msdb.dbo.sysjobhistory j where b.job_id=j.job_id order by run_date desc,run_time desc)
		,last_duration=(select top 1 run_duration=case when run_duration>=100 then cast(left(run_duration,len(run_duration)-2)*60 as int)+cast(right(run_duration,2) as int) 
		else run_duration end from msdb.dbo.sysjobhistory j where b.job_id=j.job_id order by run_date desc,run_time desc)
		,count(*)  [count]
		from msdb.dbo.sysjobs b
		left join (
					select job_id, run_duration=case when run_duration>=100 then cast(left(run_duration,len(run_duration)-2)*60 as int)+cast(right(run_duration,2) as int) 
												else run_duration
												end,run_date,
						   run_time,
						   run_status,
						   ROW_NUMBER() over (partition by job_id order by run_date desc) as k  
						   from msdb.dbo.sysjobhistory
				  ) as a on (a.job_id=b.job_id)
		where cast(cast(run_date as nvarchar(255)) as date)=cast(getdate() as date) or k=1
		group by b.job_id, b.[name], b.date_created, run_date
		order by sum(run_duration) desc,count(*) *avg(run_duration) desc
	) as a;
end





GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [srv].[GetStatisticJobs]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Данные по выполнению заданий на сервере', 'SCHEMA', N'srv', 'PROCEDURE', N'GetStatisticJobs'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [srv].[Used_resouces_by_sessions]
--
GO

--Мониторинг использования ресурсов ОП(RAM),cpu,reads,writes по текущим исполняемым сессиям на SQL Server-е
--Прилепа Б.А. - АБД
--22.05.2017

CREATE procedure [srv].[Used_resouces_by_sessions]
as
begin
	set nocount on;
	set xact_abort on;

	SELECT	spid,
			[percent],
			required_memory_kb,
			used_memory_kb,
			[status],
			sum(writes) writes,
			loginame=(case when max(loginame)=min(loginame) then max(loginame) else max(loginame)+' '+min(loginame) end),
			[db_name],[hostname],client_net_address,[program_name]
			,start_time
			,wait_time
			,last_wait_type
			,command
			,[statement]
			,[text]
	FROM
		(SELECT 
				distinct r.session_id             AS spid,r.percent_complete       AS [percent],required_memory_kb,used_memory_kb,
				r.[status]
				,r.writes
				,DB_NAME(r.database_id)   AS [db_name]
				,s.[hostname]
				,dmec.client_net_address,
				s.[program_name],s.loginame,r.start_time,r.wait_time,r.last_wait_type,r.command,
				(SELECT SUBSTRING(text, statement_start_offset / 2 + 1,

				(CASE WHEN statement_end_offset = -1 THEN LEN(CONVERT(NVARCHAR(MAX),text)) * 2 
				ELSE statement_end_offset END - statement_start_offset) / 2)
					FROM sys.dm_exec_sql_text(r.sql_handle)) AS [statement]
				,t.[text]
				FROM sys.dm_exec_requests r

				INNER JOIN sys.dm_exec_connections dmec ON r.session_id = dmec.session_id

				INNER JOIN sys.sysprocesses s ON s.spid = r.session_id

				CROSS APPLY sys.dm_exec_sql_text (r.sql_handle) t

				LEFT JOIN sys.dm_exec_query_memory_grants p on(r.session_id=p.session_id) --Использование ОП по сессиям

				) tbl 
	GROUP BY spid,[percent],required_memory_kb,used_memory_kb,[status],[db_name],[hostname],client_net_address,[program_name],start_time,wait_time,last_wait_type,command,[statement],[text]
	ORDER BY used_memory_kb desc,required_memory_kb desc,sum(writes) desc
end
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [srv].[Used_resouces_by_sessions]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Мониторинг использования ресурсов ОП(RAM),cpu,reads,writes по текущим исполняемым сессиям на SQL Server-е', 'SCHEMA', N'srv', 'PROCEDURE', N'Used_resouces_by_sessions'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [srv].[Locks]
--
GO

  
CREATE PROCEDURE [srv].[Locks]
(
   @Mode int = 4
)
/*
  @Mode - 0 вывод активных запросов без кода T-SQL и sql plan 1 окно
  @Mode - 1 блокируемый запрос и заблокированный 1 окно
  @Mode - 2 запрос инициирующий блокировку в том числе каскадную и окно @Mode - 1 (блокируемый и заблокированный запрос)
  @Mode - 3 три окна, сочетаниие @Mode 2 и 0, но в третьем окне дополнительно выводится полный текст запроса и sql plan
*/
AS
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	/*Мониториг sql процессов выполняемых в данный момент на сервере, блокировок процессов*/
	BEGIN
	SET XACT_ABORT ON;
	IF @Mode = 0
	BEGIN;
		SELECT DISTINCT
	    r.session_id             AS spid,
	    r.percent_complete       AS [percent],
	    r.open_transaction_count AS open_trans,
	    r.[status],
	    r.reads,
	    r.logical_reads,
	    r.writes,
	    s.cpu,
	    DB_NAME(r.database_id)   AS [db_name],
	    s.[hostname],
		dmec.client_net_address,
	    s.[program_name],
	    s.loginame,
	    r.start_time,
	    r.wait_time,
	    r.last_wait_type,
	    r.blocking_session_id    AS blocking,
	    r.command
	  FROM sys.dm_exec_requests r
	  inner join sys.dm_exec_connections dmec ON r.session_id = dmec.session_id
	    INNER JOIN sys.sysprocesses s ON s.spid = r.session_id
	  WHERE (r.[status]<>'background' and r.command<>'TASK MANAGER') AND r.session_id <> @@spid
	  ORDER BY r.session_id;
	END;
	
	IF @Mode = 1
	BEGIN;
	  SELECT
	      t.blocking_session_id           AS blocking,
	      t.session_id                    AS blocked,
	      p2.[program_name]               AS program_blocking,
	      p1.[program_name]               AS program_blocked,
	      DB_NAME(l.resource_database_id) AS [database],
	      p2.[hostname]                   AS host_blocking,
	      p1.[hostname]                   AS host_blocked,
	      t.wait_duration_ms,
	      l.request_mode,
	      l.resource_type,
	      t.wait_type,
	      (SELECT SUBSTRING(st.text, (r.statement_start_offset/2) + 1, 
	              ((CASE r.statement_end_offset 
	                  WHEN -1 THEN DATALENGTH(st.text) 
	                  ELSE r.statement_end_offset END
	                - r.statement_start_offset) /2 ) + 1)
	        FROM sys.dm_exec_requests AS r 
	          CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) AS st 
	        WHERE r.session_id = l.request_session_id) AS statement_blocked,
	      CASE WHEN t.blocking_session_id > 0 THEN 
	        (SELECT st.text 
	          FROM sys.sysprocesses AS p 
	            CROSS APPLY sys.dm_exec_sql_text(p.sql_handle) AS st
	          WHERE p.spid = t.blocking_session_id)
	      ELSE NULL END AS statement_blocking
	    FROM sys.dm_os_waiting_tasks AS t
	      INNER JOIN sys.dm_tran_locks AS l 
	        ON t.resource_address = l.lock_owner_address
	      INNER JOIN sys.sysprocesses p1 ON p1.spid = t.session_id
	      INNER JOIN sys.sysprocesses p2 ON p2.spid = t.blocking_session_id
	    WHERE (p1.[status]<>'background' and p1.cmd<>'TASK MANAGER') and t.session_id<>@@SPID 
	END;
	
	IF @Mode = 2
	BEGIN;
	SELECT 
	    spid,
	    [status],
	    CONVERT(CHAR(3), s.blocked) AS blocked,
	    loginame,
	    SUBSTRING([program_name], 1, 25)   AS program,
	    SUBSTRING(DB_NAME(s.dbid), 1, 10)  AS [database],
	    SUBSTRING(hostname, 1, 12)         AS host,
	    cmd,
	    waittype,
	    t.[text]
	  FROM (select * from sys.sysprocesses where blocked = 0) s 
	  INNER JOIN (SELECT distinct blocked FROM sys.sysprocesses WHERE blocked <> 0) p on(s.spid=p.blocked)
	  CROSS APPLY sys.dm_exec_sql_text (s.sql_handle) t
	
	SELECT
	    t.blocking_session_id            AS blocking,
	    t.session_id                     AS blocked,
	    p2.[program_name]                AS program_blocking,
	    p1.[program_name]                AS program_blocked,
	    DB_NAME(l.resource_database_id)  AS [database],
	    p2.[hostname]                    AS host_blocking,
	    p1.[hostname]                    AS host_blocked,
	    t.wait_duration_ms,
	    l.request_mode,
	    l.resource_type,
	    t.wait_type,
	    (SELECT SUBSTRING(st.text, (r.statement_start_offset / 2) + 1, 
	              ((CASE r.statement_end_offset 
	                  WHEN -1 THEN DATALENGTH(st.text)
	                  ELSE r.statement_end_offset END
	                - r.statement_start_offset) / 2) + 1
	            )
	      FROM sys.dm_exec_requests AS r
	        CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) AS st 
	      WHERE r.session_id = l.request_session_id) AS statement_blocked,
	    CASE WHEN t.blocking_session_id > 0 THEN 
	          (SELECT st.text 
	            FROM sys.sysprocesses AS p  
	              CROSS APPLY sys.dm_exec_sql_text(p.sql_handle) AS st 
	            WHERE p.spid = t.blocking_session_id) ELSE NULL 
	         END AS statement_blocking
	  FROM sys.dm_os_waiting_tasks AS t
	    INNER JOIN sys.dm_tran_locks AS l
	      ON t.resource_address = l.lock_owner_address
	    INNER JOIN sys.sysprocesses p1   ON p1.spid = t.session_id
	    INNER JOIN sys.sysprocesses p2   ON p2.spid = t.blocking_session_id
	  WHERE (p1.[status]<>'background' and p1.cmd<>'TASK MANAGER')  AND t.session_id<>@@spid
	  ORDER BY t.blocking_session_id  DESC;
	END;
	
	IF @Mode = 3
	BEGIN;
	SELECT 
	    DISTINCT spid,
	    [status],
	    CONVERT(CHAR(3), s.blocked) AS blocked,
	    loginame,
	    SUBSTRING([program_name], 1, 255)   AS program,
	    SUBSTRING(DB_NAME(s.dbid), 1, 255)  AS [database],
	    SUBSTRING(hostname, 1, 255)         AS host,
	    cmd,
	    waittype,
	    t.[text]
	  FROM (select * from sys.sysprocesses where blocked = 0) s 
	  INNER JOIN (SELECT distinct blocked FROM sys.sysprocesses WHERE blocked <> 0) p on(s.spid=p.blocked)
	  CROSS APPLY sys.dm_exec_sql_text (s.sql_handle) t
	  
	  
	SELECT
	    DISTINCT t.blocking_session_id                AS blocking,
	    t.session_id                        AS blocked,
	    SUBSTRING(p2.[program_name], 1, 255)  AS program_blocking,
	    SUBSTRING(p1.[program_name], 1, 255)  AS program_blocked,
	    DB_NAME(l.resource_database_id)      AS [database],
	    p2.[hostname]                        AS host_blocking,
	    p1.[hostname]                        AS host_blocked,
	    t.wait_duration_ms,
	    l.request_mode,
	    l.resource_type,
	    t.wait_type,
	    (SELECT SUBSTRING(st.text, (r.statement_start_offset/2) + 1, 
	            ((CASE r.statement_end_offset WHEN -1 THEN DATALENGTH(st.text)
	              ELSE r.statement_end_offset 
	              END - r.statement_start_offset) / 2) + 1) 
	      FROM sys.dm_exec_requests AS r 
	        CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) AS st 
	      WHERE r.session_id = l.request_session_id) AS statement_blocked,
	    CASE WHEN t.blocking_session_id > 0 THEN 
	           (SELECT st.text 
	              FROM sys.sysprocesses AS p  
	                CROSS APPLY sys.dm_exec_sql_text(p.sql_handle) AS st 
	              WHERE p.spid = t.blocking_session_id) ELSE NULL 
	         END AS statement_blocking
	  FROM sys.dm_os_waiting_tasks AS t
	    INNER JOIN sys.dm_tran_locks AS l 
	      ON t.resource_address = l.lock_owner_address
	    INNER JOIN sys.sysprocesses p1   ON p1.spid = t.session_id
	    INNER JOIN sys.sysprocesses p2   ON p2.spid = t.blocking_session_id
	  WHERE (p1.[status]<>'background' and p1.cmd<>'TASK MANAGER') AND t.session_id<>@@spid
	  ORDER BY wait_duration_ms desc,t.blocking_session_id  DESC;
	
	WITH A AS(SELECT DISTINCT
	    r.session_id             AS spid,
	    r.percent_complete       AS [percent],
	    r.open_transaction_count AS open_trans,
	    r.[status],
	    r.reads,
	    r.logical_reads,
	    r.writes,
	    s.cpu,
	    DB_NAME(r.database_id)   AS [db_name],
	    s.[hostname],
		dmec.client_net_address,
	    s.[program_name],
	    s.loginame,
	    r.start_time,
	    r.wait_time,
	    r.last_wait_type,
	    r.blocking_session_id    AS blocking,
	    r.command,
	    (SELECT SUBSTRING(text, statement_start_offset / 2 + 1,
	            (CASE WHEN statement_end_offset = -1 THEN
	                    LEN(CONVERT(NVARCHAR(MAX),text)) * 2 
	                  ELSE statement_end_offset 
	                  END - statement_start_offset) / 2)
	      FROM sys.dm_exec_sql_text(r.sql_handle)) AS [statement],
	    t.[text],r.plan_handle,r.scheduler_id 
	  FROM sys.dm_exec_requests r
	  LEFT JOIN sys.dm_exec_connections dmec ON r.session_id = dmec.session_id
	    LEFT JOIN sys.sysprocesses s ON s.spid = r.session_id
	    OUTER APPLY sys.dm_exec_sql_text (r.sql_handle) t
	  WHERE (r.[status]<>'background' and r.command<>'TASK MANAGER') AND r.session_id <> @@spid and hostname<>'')
	
	SELECT A.spid,s.cpu_id,threads.threads,s.current_tasks_count current_tasks,s.runnable_tasks_count runnable_tasks,[percent],open_trans,A.[status],reads,logical_reads,writes,cpu,[db_name],[hostname],client_net_address
	,[program_name],loginame,start_time,wait_time,last_wait_type,blocking,command,[statement],[text],query_plan 
	FROM A A OUTER APPLY sys.dm_exec_query_plan (plan_handle) 
	LEFT JOIN sys.dm_os_schedulers s on(A.scheduler_id=s.scheduler_id) --выбираем данные по доступу к ЦП
	LEFT JOIN (SELECT  cpu_id,count(SThreads.os_thread_id) threads
	FROM sys.dm_os_threads AS SThreads  
	INNER JOIN sys.dm_os_schedulers s on(SThreads.scheduler_address=s.scheduler_address)
	GROUP BY cpu_id) threads ON(s.cpu_id=threads.cpu_id)
	ORDER BY spid ,wait_time DESC
	END;
	IF @Mode = 4
	BEGIN
	SELECT DISTINCT
	    r.session_id             AS spid,sh.cpu_id,threads.threads,sh.current_tasks_count current_tasks,sh.runnable_tasks_count runnable_tasks,
	    r.percent_complete       AS [percent],
	    r.open_transaction_count AS open_trans,
	    r.[status],
	    r.reads,
	    r.logical_reads,
	    r.writes,
	    s.cpu,
	    DB_NAME(r.database_id)   AS [db_name],
	    s.[hostname],
		dmec.client_net_address,
	    s.[program_name],
	    s.loginame,
	    r.start_time,
	    r.wait_time,
	    r.last_wait_type,
	    r.blocking_session_id    AS blocking,
	    r.command,
	   (SELECT SUBSTRING(text, statement_start_offset / 2 + 1,
	            (CASE WHEN statement_end_offset = -1 THEN
	                    LEN(CONVERT(NVARCHAR(MAX),text)) * 2 
	                  ELSE statement_end_offset 
	                  END - statement_start_offset) / 2)
	      FROM sys.dm_exec_sql_text(r.sql_handle)) AS [statement],
	    t.[text]
	  FROM sys.dm_exec_requests r
	  left join sys.dm_exec_connections dmec ON r.session_id = dmec.session_id
	    left JOIN sys.sysprocesses s ON s.spid = r.session_id
	    outer APPLY sys.dm_exec_sql_text (r.sql_handle) t
		LEFT JOIN sys.dm_os_schedulers sh on(r.scheduler_id=sh.scheduler_id) --выбираем данные по доступу к ЦП
	  LEFT JOIN (SELECT  cpu_id,count(SThreads.os_thread_id) threads
	FROM sys.dm_os_threads AS SThreads  
	INNER JOIN sys.dm_os_schedulers s on(SThreads.scheduler_address=s.scheduler_address)
	GROUP BY cpu_id) threads ON(sh.cpu_id=threads.cpu_id)
	  WHERE (r.[status]<>'background' and r.command<>'TASK MANAGER') AND r.session_id <> @@spid and hostname<>''
	  ORDER BY r.session_id ,r.wait_time DESC;
	END
END

GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [srv].[Locks]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Мониториг sql процессов выполняемых в данный момент на сервере, блокировок процессов', 'SCHEMA', N'srv', 'PROCEDURE', N'Locks'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [srv].[Get_Statistic_Waits]
--
GO


--Мониторинг SQL ожиданий
--Прилепа Б.А. - АБД
--23.11.2017

CREATE procedure [srv].[Get_Statistic_Waits]
as
begin
	set nocount on;
	set xact_abort on;
	
	if (OBJECT_ID(N'tempdb..#Waits', N'U') is not null)
		drop table #Waits;
		
	SELECT
	        [wait_type],
	        [wait_time_ms] AS [WaitS],
	        ([wait_time_ms] - [signal_wait_time_ms]) AS [ResourceS],
	        [signal_wait_time_ms] AS [SignalS],
	        [waiting_tasks_count] AS [WaitCount],
	        100.0 * [wait_time_ms] / SUM ([wait_time_ms]) OVER() AS [Percentage],
	        ROW_NUMBER() OVER(ORDER BY [wait_time_ms] DESC) AS [RowNum]
			into #Waits
	    FROM master.sys.dm_os_wait_stats
	    WHERE [wait_type] NOT IN (
	        N'BROKER_EVENTHANDLER',         N'BROKER_RECEIVE_WAITFOR',
	        N'BROKER_TASK_STOP',            N'BROKER_TO_FLUSH',
	        N'BROKER_TRANSMITTER',          N'CHECKPOINT_QUEUE',
	        N'CHKPT',                       N'CLR_AUTO_EVENT',
	        N'CLR_MANUAL_EVENT',            N'CLR_SEMAPHORE',
	        N'DBMIRROR_DBM_EVENT',          N'DBMIRROR_EVENTS_QUEUE',
	        N'DBMIRROR_WORKER_QUEUE',       N'DBMIRRORING_CMD',
	        N'DIRTY_PAGE_POLL',             N'DISPATCHER_QUEUE_SEMAPHORE',
	        N'EXECSYNC',                    N'FSAGENT',
	        N'FT_IFTS_SCHEDULER_IDLE_WAIT', N'FT_IFTSHC_MUTEX',
	        N'HADR_CLUSAPI_CALL',           N'HADR_FILESTREAM_IOMGR_IOCOMPLETION',
	        N'HADR_LOGCAPTURE_WAIT',        N'HADR_NOTIFICATION_DEQUEUE',
	        N'HADR_TIMER_TASK',             N'HADR_WORK_QUEUE',
	        N'KSOURCE_WAKEUP',              N'LAZYWRITER_SLEEP',
	        N'LOGMGR_QUEUE',                N'ONDEMAND_TASK_QUEUE',
	        N'PWAIT_ALL_COMPONENTS_INITIALIZED',
	        N'QDS_PERSIST_TASK_MAIN_LOOP_SLEEP',
	        N'QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP',
	        N'REQUEST_FOR_DEADLOCK_SEARCH', N'RESOURCE_QUEUE',
	        N'SERVER_IDLE_CHECK',           N'SLEEP_BPOOL_FLUSH',
	        N'SLEEP_DBSTARTUP',             N'SLEEP_DCOMSTARTUP',
	        N'SLEEP_MASTERDBREADY',         N'SLEEP_MASTERMDREADY',
	        N'SLEEP_MASTERUPGRADED',        N'SLEEP_MSDBSTARTUP',
	        N'SLEEP_SYSTEMTASK',            N'SLEEP_TASK',
	        N'SLEEP_TEMPDBSTARTUP',         N'SNI_HTTP_ACCEPT',
	        N'SP_SERVER_DIAGNOSTICS_SLEEP', N'SQLTRACE_BUFFER_FLUSH',
	        N'SQLTRACE_INCREMENTAL_FLUSH_SLEEP',
	        N'SQLTRACE_WAIT_ENTRIES',       N'WAIT_FOR_RESULTS',
	        N'WAITFOR',                     N'WAITFOR_TASKSHUTDOWN',
	        N'WAIT_XTP_HOST_WAIT',          N'WAIT_XTP_OFFLINE_CKPT_NEW_LOG',
	        N'WAIT_XTP_CKPT_CLOSE',         N'XE_DISPATCHER_JOIN',
	        N'XE_DISPATCHER_WAIT',          N'XE_TIMER_EVENT', N'XE_LIVE_TARGET_TVF', N'PREEMPTIVE_OS_ENCRYPTMESSAGE',N'PREEMPTIVE_XE_DISPATCHER',N'QDS_ASYNC_QUEUE'
		)
	SELECT
	    [W1].[wait_type]														AS [Тип ожидания],
	    CAST ([W1].[WaitS]/1000.0 AS DECIMAL (16, 2))									AS [Всего ожидания (сек.)],
	    CAST ([W1].[ResourceS]/1000.0 AS DECIMAL (16, 2))								AS [Ресурсоное ожидание (сек.)],
	    CAST ([W1].[SignalS]/1000.0 AS DECIMAL (16, 2))								AS [Сигнальное ожидание (сек.)],
	    [W1].[WaitCount]														AS [Ожидавших задач],
	    CAST ([W1].[Percentage] AS DECIMAL (5, 2))								AS [Процент],
	    CAST (([W1].[WaitS] / ([W1].[WaitCount]/1.0)) AS DECIMAL (18, 3))		AS [Среднее время ожидания (мс.)],
	    CAST (([W1].[ResourceS] / ([W1].[WaitCount]/1.0)) AS DECIMAL (18, 3))	AS [Среднее время ресурсного ожидания (мс.)],
	    CAST (([W1].[SignalS] / ([W1].[WaitCount]/1.0)) AS DECIMAL (18, 3))		AS [Среднее время сигнального ожидания (мс.)]
	FROM #Waits AS [W1]
	INNER JOIN #Waits AS [W2] ON [W2].[RowNum] <= [W1].[RowNum]
	GROUP BY [W1].[RowNum], [W1].[wait_type], [W1].[WaitS], [W1].[ResourceS], [W1].[SignalS], [W1].[WaitCount], [W1].[Percentage]
	HAVING SUM ([W2].[Percentage]) - [W1].[Percentage] < 99.8;

	if (OBJECT_ID(N'tempdb..#Waits', N'U') is not null)
		drop table #Waits;
end
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [srv].[Get_Statistic_Waits]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Мониторинг SQL ожиданий', 'SCHEMA', N'srv', 'PROCEDURE', N'Get_Statistic_Waits'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [srv].[FindObject]
--
GO


--exec [dbo].[sp_FindObject] @name='ms_Mail_Prepare&Send_CheckMove'
--exec [dbo].[sp_FindObject] @name='Operation',@like=1
CREATE   proc [srv].[FindObject]
	@name nvarchar(255)=N'sp_tc_search_code' --exec master.dbo.sp_FindObject @name='agreement_requests'
	/*,@name2 varchar(255)=''
	,@name3 varchar(255)='esbsrv02'
	,@name4 varchar(255)='esbsrv03'
	,@name5 varchar(255)='esbsrv04'*/
	,@mult int=0
	,@like int=1
as
begin
	set nocount on;
	set xact_abort on;
	--Хранимая процедура глобального поиска объекта, в том числе его использорвания в SQL JOB

	if (object_id(N'tempdb..#t', N'U') is not null)	drop table #t;

	declare @sql nvarchar(4000)=N'';
	declare @sql2 nvarchar(4000)=N'';

	if @like=0
	begin
		declare @P nvarchar(max)=N'';

		declare @table table (
							   referenced_database_name nvarchar(255),
							   DB nvarchar(255),
							   referenced_entity_name nvarchar(255),
							   type_desc_obj nvarchar(255),
							   ref_obj nvarchar(255),
							   [type_desc] nvarchar(255)
							 );

		set @P=N'use [?]
		select distinct referenced_database_name referenced_database_name,db_name() DB,referenced_entity_name,b.type_desc type_desc_obj,c.name ref_obj,c.type_desc
		from sys.sql_expression_dependencies a 
		LEFT JOIN sys.objects b on(a.referenced_id=b.object_id)
		LEFT JOIN sys.objects c on(a.referencing_id=c.object_id)
		where (referenced_entity_name='''+@name+N''' or c.name='''+@name+N''')';

		insert into @table (referenced_database_name, DB, referenced_entity_name, type_desc_obj, ref_obj, [type_desc])
		exec master..sp_msforeachdb @P;

		select referenced_database_name, referenced_entity_name, type_desc_obj, DB, ref_obj, [type_desc]
		from @table
		order by 1,2,3;
	end

	declare @tbl table (DB nvarchar(255), [type] nvarchar(50), [name] nvarchar(255), [type_desc] nvarchar(255));

	/*if @mult=1
	set @sql='USE [?]
	select DB_NAME() DB,''В тексте'',a.name name,a.type_desc from sys.objects a (nolock) inner join sys.sql_modules b (nolock) on(a.object_id=b.object_id) where b.[definition] like ''%'+@name+'%''
	or b.[definition] like ''%'+@name2+'%'' or b.[definition] like ''%'+@name3+'%'' or b.[definition] like ''%'+@name4+'%'' or b.[definition] like ''%'+@name5+'%'''*/

	if ((@mult=0) and (@like=1))
	begin
		set @sql=N'USE [?]
		select DB_NAME() DB,''В тексте'',a.name name,a.type_desc from sys.objects a (nolock) inner join sys.sql_modules b (nolock) on(a.object_id=b.object_id) 
		where a.[type] in(''P'',
		''V'',
		''U'',
		''IF'',
		''FN'',
		''TF'',
		''TR'') and b.[definition] like '''+'%'+@name+N'%'+'''
		union
		select DB_NAME() DB,''Столбец'',TABLE_NAME COLLATE Cyrillic_General_CI_AS,''Таблица'' type_desc from INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME='''+@name+N'''';
	end

	if ((@mult=0) and (@like=0))
	begin
		set @sql=N'USE [?]
		select DB_NAME() DB,''Столбец'',TABLE_NAME COLLATE Cyrillic_General_CI_AS,''Таблица'' type_desc from INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME='''+@name+N'''';
	end

	if @like=1
		insert into @tbl (DB, [type], [name], [type_desc])
		exec sp_Msforeachdb @sql;

	if @like=0
	begin
		set @sql2=N'USE [?]
		select DB_NAME() DB,''Название'',name name,type_desc from sys.objects where [name]='''+@name+N'''';

		insert into @tbl (DB, [type], [name], [type_desc])
		exec sp_Msforeachdb @sql2;
	end

		select distinct * 
		into #t
		from @tbl
		where DB not in (N'', N'master', N'msdb', N'monitor_performance', N'tempdb') 
		and [name] not like N'%_New'
		and [name] not like N'%_p'
		and [name] not like N'%_Test'
		and [name] not like N'%copy'
		and [name] not like N'%Old'
		and [name] not like N'%[0-9][0-9][0-9][0-9]%' 
		and [name] not like N'Obsolet%'
		and [name] not like N'DELETE%';


		select DB, [type], [name], [type_desc], job, command, [enabled]--,convert(date,last_run_date,104) last_run_date,left(last_run_time,2)+':'+right(left(last_run_time,4),2)+':'+right(last_run_time,2) last_run_time 
		from #t as a
		LEFT OUTER JOIN (
						 select a.[name] as job, b.command ,a.[enabled]--,cast(b.last_run_date as varchar(50)) last_run_date,cast(last_run_time as varchar(50)) last_run_time 
						 from msdb..sysjobs as a
						 inner join msdb..sysjobsteps as b on (a.job_id=b.job_id)
						) as b on (b.command like N''+N'%'+a.[name]+N'%'+N'');

		if (object_id('tempdb..#t','U') is not null) drop table #t;
	
end
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [srv].[FindObject]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Хранимая процедура глобального поиска объекта, в том числе его использорвания в SQL JOB', 'SCHEMA', N'srv', 'PROCEDURE', N'FindObject'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [srv].[FindObj]
--
GO



CREATE procedure [srv].[FindObj]
	@find nvarchar(255)=N'StateOfResource'
as
begin
	set nocount on;
	set xact_abort on;
	
	if (object_id(N'tempdb..##TBL', N'U') is not null) drop table ##TBL;
	
	create table ##TBL (DB nvarchar(255), [obj] nvarchar(255), [type_desc] nvarchar(255));
	
	insert into ##TBL (DB, [obj], [type_desc])
	exec sp_MSforeachdb N'USE [?] select DB_NAME() as DB, [name] as [obj], [type_desc] from sys.objects';
	
	--объекты
	select DB, [obj], [type_desc]
	from ##TBL
	where [obj]=@find;
	
	--зависимости
	declare @SQL nvarchar(max)=N'';
	
	set @SQL=N'USE [?]  
	select DB_NAME() DB,b.[name] def_obj,b.type_desc,referenced_entity_name,c.[type_desc] COLLATE Cyrillic_General_CI_AS ref_type_desc 
	,isnull(referenced_database_name,DB_NAME()) referenced_database_name, referenced_server_name 
	from sys.sql_expression_dependencies a
	left join sys.objects b on(a.referencing_id=b.[object_id])
	left join ##TBL c on(a.referenced_entity_name=c.[obj] and (isnull(referenced_database_name,DB_NAME())=c.DB))
	where b.[name]='''+@find+N''' or referenced_entity_name='''+@find+N'''
	union
	select DB_NAME() DB,tr.[name],o.type_desc,o.[name],o.[type_desc],DB_NAME() DB, '''' referenced_server_name 
	from sys.triggers tr LEFT JOIN sys.objects o on(tr.parent_id=o.object_id)
	where tr.name='''+@find+N''' or o.[name]='''+@find+N'''';
	
	declare @RES table (DB nvarchar(255), def_obj nvarchar(255), [type_desc] nvarchar(255),referenced_entity_name nvarchar(255)
	,ref_type_desc nvarchar(255), referenced_database_name nvarchar(255), referenced_server_name nvarchar(255));
	
	insert into @RES (DB, def_obj, [type_desc], referenced_entity_name, ref_type_desc, referenced_database_name, referenced_server_name)
	exec sp_MSforeachdb @SQL;
	
	select DB, def_obj, [type_desc], referenced_entity_name, ref_type_desc, referenced_database_name, referenced_server_name
	from @RES;
	
	if (object_id(N'tempdb..##TBL', N'U') is not null)	drop table ##TBL;
end
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [srv].[FindObj]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Поиск объекта sql в рамках одного SQL сервера. Нахождение всех использований указанного объекта в определении других sql объектов.', 'SCHEMA', N'srv', 'PROCEDURE', N'FindObj'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [srv].[Find_Ref_Other_DB]
--
GO


CREATE   proc [srv].[Find_Ref_Other_DB]
	@DB nvarchar(255)=N'',
	@obj nvarchar(255)=null,
	@srv int=0
as
begin
	set nocount on;
	set xact_abort on;
	/*
	Хранимая процедура ищет использование хранимых объектов и таблиц в определении других хранимых обхектах SQL (в основе лежит sql_expression_dependencies)
	Выполняется только в контексте одной БД
	*/

	declare @sql nvarchar(max)=N'';
	
	set @sql=N'select DB_NAME() DB,b.name obj,b.type_desc,referenced_entity_name ,referenced_database_name, referenced_server_name 
	from sys.sql_expression_dependencies a INNER JOIN 
	sys.objects b on(a.referencing_id=b.object_id)
	left join sys.objects c on(a.referenced_entity_name=c.name)
	where lower(referenced_database_name) is not null and referenced_database_name not in(''master'')
	and left(b.name,7)<>''Obsolet''
	and right(b.name, 4) not in(''Test'',''COPY'')
	and right(b.name, 2) not in(''BP'')
	and left(b.name, 6) not in(''DELETE'')
	and b.name not like ''%[0-9][0-9][0-9][0-9]''
	and (referenced_database_name='''+@DB+N''' or '''+@DB+N''''+'='''')
	'+case when len(@obj)>0 then N'and (b.name='''+@obj+''' or referenced_entity_name='''+@obj+N''')' else N'' end +N'
	 '+case when @srv=1 then N'and exists(select 1 from sys.sql_expression_dependencies se where a.referencing_id=se.referencing_id and se.referenced_server_name is not null)' else N'' end +N'';
	
	declare @tbl table(DB nvarchar(255), obj nvarchar(255), [type_desc] nvarchar(255), referenced_entity_name nvarchar(255), referenced_database_name nvarchar(255), referenced_server_name nvarchar(255));
	
	--print @sql
	
	insert into @tbl
	exec sp_executesql @sql;
	
	if (exists(select top(1) 1 from @tbl)) select distinct DB, obj, [type_desc], referenced_entity_name, referenced_database_name, referenced_server_name from @tbl;
end
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [srv].[Find_Ref_Other_DB]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Хранимая процедура ищет использование хранимых объектов и таблиц в определении других хранимых обхектах SQL (в основе лежит sql_expression_dependencies)
	Выполняется только в контексте одной БД', 'SCHEMA', N'srv', 'PROCEDURE', N'Find_Ref_Other_DB'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [srv].[Disk_RAM]
--
GO

CREATE   proc [srv].[Disk_RAM]
as
begin
	set xact_abort on;
	set nocount on;

	--Вывод данных по видимым MS SQL логическим дискам
	SELECT  volume_mount_point as [Disk]
		  ,cast(((MAX(s.total_bytes))/1024.0)/1024.0 as numeric(11,2))as  Disk_Space_Mb
		  ,cast(((MIN(s.available_bytes))/1024.0)/1024.0 as numeric(11,2)) as Available_Mb
		  ,cast((MIN(available_bytes)/cast(MAX(total_bytes) as float))*100 as numeric(11,2)) as [Available_Percent]
	FROM sys.master_files AS f  
	CROSS APPLY sys.dm_os_volume_stats(f.database_id, f.file_id) as s
	GROUP BY volume_mount_point; 

	--Вывод данным о использование RAM на сервере
	select ceiling(physical_memory_kb/1024.0) as [physical_memory_Mb]
		  ,ceiling(committed_target_kb/1024.0) as [committed_target_Mb]
		  ,ceiling(physical_memory_in_use_kb/1024.0) as [physical_memory_in_use_Mb]
		  ,ceiling(available_physical_memory_kb/1024.0) as [available_physical_memory_Mb]
		  ,cast((available_physical_memory_kb/cast(physical_memory_kb as float))*100 as numeric(10,2)) as [Avail RAM (%)]  
	from sys.dm_os_process_memory as a
	cross join sys.dm_os_sys_info as b
	cross join sys.dm_os_sys_memory as v;
end
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [srv].[Disk_RAM]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Вывод данных по видимым MS SQL логическим дискам.Вывод данным о использование RAM на сервере', 'SCHEMA', N'srv', 'PROCEDURE', N'Disk_RAM'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [srv].[Depend_objects]
--
GO


CREATE procedure [srv].[Depend_objects]
	@DB nvarchar(255)=N'',
	@type nvarchar(50)=N'',
	@type2 nvarchar(50)=N'',
	@ref_DB nvarchar(255)=N'',
	@obj nvarchar(255)=N'',
	@ref_obj nvarchar(255)=N'',
	@stat int=0, 
	@srv int=0,
	@job int=0
as
begin
	set xact_abort on;
	set nocount on;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	
	/*Построение зависимостей в хранимых объектов MS SQL (на основе sys.sql_expression_dependencies)*/
	
	IF (OBJECT_ID(N'tempdb..##TBL', N'U') IS NOT NULL) DROP TABLE tempdb..##TBL;
	
	IF (LEN(@DB)<1)
	begin
		RAISERROR(N'Вы не указали БД!', 10, 2);

		return 0;
	end
	
	IF ((@job=1) and (len(@obj)>0))
	begin
		--Использование объекта в SQL JOBS
		select a.name job,N'в теле' place,b.command,a.enabled
		from msdb..sysjobs a inner join msdb..sysjobsteps b on(a.job_id=b.job_id)
		where (command like N'%'+@obj+N'%' or command like N'%'+@obj+N'%' or a.name=@obj) AND (@DB=N'' OR (command like N'%'+@DB+N'%' or [database_name]=@DB));
	end
	
	IF ((@job=1) and (len(@obj)=0))
	begin
		--ИСпользование объекта в SQL JOBS
		select a.name job,N'в теле' place,b.command,a.enabled
		from msdb..sysjobs a inner join msdb..sysjobsteps b on(a.job_id=b.job_id)
		where command like N'%'+@DB+N'%' or [database_name]=@DB;
	end
	
	IF ((@type not in (N'U', N'V', N'P', N'FN', N'IF', N'TR', N'TF', N'')) or (@type2 not in(N'U', N'V', N'P', N'FN', N'IF', N'TR', N'TF', N'')))
	begin
		RAISERROR(N'Вы указали не валидный тип поиска! Валидные типы:
		SQL_INLINE_TABLE_VALUED_FUNCTION	IF
		SQL_SCALAR_FUNCTION	FN
		SQL_STORED_PROCEDURE	P 
		SQL_TABLE_VALUED_FUNCTION	TF
		SQL_TRIGGER	TR
		USER_TABLE	U 
		VIEW	V ', 10, 2);

		return 0;
	end
	
	create table ##TBL(DB nvarchar(255), [obj] nvarchar(255), COL nvarchar(255), [type_desc] nvarchar(255), [type] nvarchar(5));
	
	declare @S varchar(max)=N'USE [?] select DB_NAME() DB,[name] [obj],'''' COL,[type_desc],[type] from sys.objects 
	where [type] in(''P'',
	''V'',
	''U'',
	''IF'',
	''FN'',
	''TF'',
	''TR'')
	UNION
	select TOP 1 DB_NAME() DB,TABLE_NAME,COLUMN_NAME COL,''USER_TABLE'' [type_desc],''U'' [type] 
	FROM INFORMATION_SCHEMA.COLUMNS where COLUMN_NAME='''+@obj+N'''';
	
	insert into ##TBL(DB, [obj], COL, [type_desc], [type])
	exec sp_MSforeachdb @S;
	
	if ((@obj<>N'') and (@type=N''))
	begin
		select *
		from ##TBL
		where DB not in (N'master', N'tempdb', N'model', N'msdb')
		 and ([obj]=@obj or COL=@obj);
	end
	
	declare @DBR sysname=@DB;

	DECLARE @dbContext nvarchar(256)=@DBR+N'.dbo.'+N'sp_executeSQL';
	
	declare @SQL nvarchar(max)=N'';
	
	--Не рассматриваем триггеры
	IF (((@type not in (N'TR')) and (@type2<>N'TR')) and (@stat=0))
	begin
		set @SQL=N'
		select DB_NAME() DB,b.[name] parent_obj,b.type,b.type_desc,referenced_entity_name,case when referenced_server_name is null then isnull(c.[type],'''')
		else '''' end ref_type,
		case when referenced_server_name is null then isnull(c.[type_desc],''Не существует!'')
		else '''' end ref_type_desc
		,isnull(referenced_database_name,DB_NAME()) referenced_database_name, isnull(referenced_server_name ,'''') referenced_server_name
		from sys.sql_expression_dependencies a
		left join sys.objects b on(a.referencing_id=b.[object_id])
		left join ##TBL c on(a.referenced_entity_name=c.[obj] and (isnull(referenced_database_name,DB_NAME())=c.DB))
		where  left(b.[name],7)<>''Obsolet''
		and right(b.[name], 4) not in(''Test'',''COPY'')
		and right(b.[name], 2) not in(''BP'')
		and right(b.[name], 3) not in(''OLD'')
		and left(b.[name], 6) not in(''DELETE'') and left(b.[name], 3) not in(''sp_'')
		and b.[name] not like ''%[0-9][0-9][0-9][0-9]''
		and (b.[type]='''+@type+N''' or '''+@type+N'''='''') and (c.[type]='''+@type2+N''' or '''+@type2+N'''='''') and (b.[name]='''+@obj+N''' or '''+@obj+N'''='''' or a.referenced_entity_name='''+@obj+N''')
		and (referenced_entity_name='''+@ref_obj+N''' or '''+@ref_obj+N'''='''')
		and (a.[referenced_database_name]='''+@ref_DB+N''' or '''+@ref_DB+N'''='''') and ('+case when @srv=0 then N'''''=''''' when @srv=1 then N'a.[referenced_server_name]<>''''' end+N')
		GROUP BY b.[name],b.type_desc,b.type,referenced_entity_name,c.[type],c.[type_desc],isnull(referenced_database_name,DB_NAME()), referenced_server_name';
		
		print @SQL;
		
		--Блок обработки ошибок
		BEGIN TRY
			EXEC @dbContext @SQL;
		END TRY
		BEGIN CATCH
			SELECT ERROR_MESSAGE() as ERR_MSG, ERROR_LINE() as ERR_LINE;
		END CATCH
	end
	
	IF ((@type not in (N'TR')) and (@type2<>N'TR') and (@stat=1))
	begin
		set @SQL=N'
		select DB_NAME() DB,o.name [obj],o.type_desc,isnull(referenced_entity_name,'''') referenced_entity_name,isnull(ref_type_desc,'''') ref_type_desc
		,isnull(referenced_database_name,'''') referenced_database_name
		from sys.objects o LEFT OUTER JOIN
		(select b.[name] parent_obj,b.type_desc,referenced_entity_name,c.[type_desc] ref_type_desc
		,isnull(referenced_database_name,DB_NAME()) referenced_database_name
		from sys.sql_expression_dependencies a
		left join sys.objects b on(a.referencing_id=b.[object_id])
		left join ##TBL c on(a.referenced_entity_name=c.[obj] and (isnull(referenced_database_name,DB_NAME())=c.DB))
		where  left(b.[name],7)<>''Obsolet''
		and right(b.[name], 4) not in(''Test'',''COPY'')
		and right(b.[name], 2) not in(''BP'')
		and right(b.[name], 3) not in(''OLD'')
		and left(b.[name], 6) not in(''DELETE'') and left(b.[name], 3) not in(''sp_'')
		and b.[name] not like ''%[0-9][0-9][0-9][0-9]''
		and (b.[type]='''+@type+N''' or '''+@type+N'''='''') and (c.[type]='''+@type2+N''' or '''+@type2+N'''='''')
		GROUP BY b.[name],b.type_desc,referenced_entity_name,c.[type_desc],isnull(referenced_database_name,DB_NAME()) ) tbl 
		ON(o.name=tbl.parent_obj and o.type_desc=tbl.type_desc and (o.[type]='''+@type+N''' or '''+@type+N'''=''''))
		where (o.[type]='''+@type+N''' or '''+@type+N'''='''')
		and  left(o.[name],7)<>''Obsolet''
		and right(o.[name], 4) not in(''Test'',''COPY'')
		and right(o.[name], 2) not in(''BP'')
		and right(o.[name], 3) not in(''OLD'')
		and left(o.[name], 6) not in(''DELETE'') and left(o.[name], 3) not in(''sp_'')
		and o.[name] not like ''%[0-9][0-9][0-9][0-9]''';
		
		--Блок обработки ошибок
		BEGIN TRY
			EXEC @dbContext @SQL;
		END TRY
		BEGIN CATCH
			SELECT ERROR_MESSAGE() as ERR_MSG, ERROR_LINE() as ERR_LINE;
		END CATCH
	end
	
	--Отдельно рассматриваем триггеры
	IF ((@type=N'TR') or (@type2=N'TR'))
	begin
		IF (LEN(@SQL)>0)
		begin
			RAISERROR(N'Ошибка формирования скрипта SQL!', 10, 2);

			print @SQL;

			return 0;
		end
		
		set @SQL=N'select distinct b.name [trigger],isnull(a.referenced_database_name,DB_NAME()) referenced_database_name,a.referenced_entity_name,isnull(ob.type_desc,''Нет объекта'') ref_type_desc,o.name parent_name,o.type_desc 
		from sys.sql_expression_dependencies a inner join sys.objects b on(a.referencing_id=b.object_id)
		inner join sys.triggers tr on(a.referencing_id=tr.object_id and ('''+@type+N'''=''TR'' or 0=1))
		inner join sys.objects o on(tr.parent_id=o.object_id )
		left join ##TBL ob on(a.referenced_entity_name=ob.[obj] and (referenced_database_name is null or referenced_database_name=ob.DB))
		where (ob.[type]='''+@type2+N''' or '''+@type2+N'''='''')
		and (referenced_entity_name='''+@ref_obj+N''' or '''+@ref_obj+N'''='''')
		and (a.[referenced_database_name]='''+@ref_DB+N''' or '''+@ref_DB+N'''='''')
		order by 1';
		
		--Блок обработки ошибок
		BEGIN TRY
			EXEC @dbContext @SQL;
		END TRY
		BEGIN CATCH
			SELECT ERROR_MESSAGE() as ERR_MSG, ERROR_LINE() as ERR_LINE;
		END CATCH
	end
	
	IF (OBJECT_ID(N'tempdb..##TBL', N'U') IS NOT NULL)	DROP TABLE tempdb..##TBL;
	
	
end
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [srv].[Depend_objects]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Построение зависимостей в хранимых объектов MS SQL (на основе sys.sql_expression_dependencies)', 'SCHEMA', N'srv', 'PROCEDURE', N'Depend_objects'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [srv].[DB_USE_DATASPACE]
--
GO


--Цель: анализ свободного места в БД
--Автор: Прилепа Б.А. - АБД
--Дата создания: 10.08.2015

CREATE procedure [srv].[DB_USE_DATASPACE]
	@DATABASE nvarchar(255)=N''
as
begin
	set nocount on;
	set xact_abort on;

	begin try
		--Цель: анализ свободного места в БД
		DECLARE @SQL nvarchar(max)=N'';
		
		IF (OBJECT_ID(N'tempdb..##DB_FILES', N'U') IS NOT NULL)	DROP TABLE tempdb..##DB_FILES;
		
		create table ##DB_FILES([Name] nvarchar(255), [FileName] nvarchar(2000),[Size(Mb)] numeric(11,2), [UsedSpace(Mb)] numeric(11,2), ID int);
		
		DECLARE @name nvarchar(255)=N'';
		
		DECLARE SysCur CURSOR LOCAL FOR 
		SELECT [name]
		FROM sys.databases
		WHERE @DATABASE=N''
		   OR [name]=@DATABASE;

		OPEN SysCur;

		FETCH NEXT FROM SysCur INTO @name;

		WHILE (@@FETCH_STATUS=0)
		BEGIN
			set @SQL=N'USE ['+@name+N']
			create table #tmpspc (Fileid int, FileGroup int, TotalExtents int, UsedExtents int, Name sysname, FileName nchar(520))
						insert #tmpspc EXEC (''dbcc showfilestats'')
			
			insert into ##DB_FILES([Name],[FileName],[Size(Mb)], [UsedSpace(Mb)],ID)
			SELECT
			cast(s.name as varchar(255)) AS [Name],
			cast(s.physical_name as varchar(2000)) AS [FileName],
			cast(round((s.size * CONVERT(float,8)/1024.0),2) AS numeric(11,2)) AS [Size(Mb)],
			cast(round((CAST(CASE s.type WHEN 2 THEN 0 ELSE tspc.UsedExtents*convert(float,64) END AS float)/1024.0),2) AS numeric(11,2)) AS [UsedSpace(Mb)],
			cast(s.file_id as INT) AS [ID]
			FROM
			sys.filegroups AS g
			INNER JOIN sys.master_files AS s ON ((s.type = 2 or s.type = 0) and s.database_id = db_id() and (s.drop_lsn IS NULL)) AND (s.data_space_id=g.data_space_id)
			LEFT OUTER JOIN #tmpspc tspc ON tspc.Fileid = s.file_id
			WHERE
			(CAST(cast(g.name as varbinary(256)) AS sysname)=N''PRIMARY'')
			UNION ALL
			SELECT
			s.name AS [Name],
			s.physical_name AS [FileName],
			round((s.size * CONVERT(float,8)/1024.0),2) AS [Size],
			round((CAST(FILEPROPERTY(s.name, ''SpaceUsed'') AS float)* CONVERT(float,8)/1024.0),2) AS [UsedSpace],
			s.file_id AS [ID]
			FROM
			sys.master_files AS s
			WHERE
			(s.type = 1 and s.database_id = db_id())
			ORDER BY
			[ID] ASC
			drop table #tmpspc';
		
			exec sp_executesql @SQL;

			FETCH NEXT FROM SysCur INTO @name;
		END

		CLOSE SysCur;
		DEALLOCATE SysCur;
		
		SELECT [Name],[FileName],[Size(Mb)], [UsedSpace(Mb)],[Size(Mb)]-[UsedSpace(Mb)] [Available(Mb)],cast((1-([UsedSpace(Mb)]/[Size(Mb)]))*100 as numeric(5,2)) [AvailbaleSpace(%)]
		FROM ##DB_FILES
		ORDER BY (1-([UsedSpace(Mb)]/[Size(Mb)]))*100 ASC;
		
		IF (OBJECT_ID('tempdb..##DB_FILES','U') IS NOT NULL) DROP TABLE tempdb..##DB_FILES;
	end try
	begin catch
		if (@@ERROR<>0)	SELECT ERROR_LINE() AS ERROR_LINE, ERROR_MESSAGE() AS ERROR_MESSAGE;
	end catch
end
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [srv].[DB_USE_DATASPACE]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Анализ свободного места в БД', 'SCHEMA', N'srv', 'PROCEDURE', N'DB_USE_DATASPACE'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [srv].[CleanCashes]
--
GO


--Принудительная чистка кэшей

CREATE procedure [srv].[CleanCashes]
as
begin
	set nocount on;
	set xact_abort on;

	DBCC FREESESSIONCACHE  WITH NO_INFOMSGS; --кэши сессий распредленных запросов

	DBCC FREESYSTEMCACHE ('ALL')  WITH MARK_IN_USE_FOR_REMOVAL, NO_INFOMSGS;

	DBCC DROPCLEANBUFFERS;

	DECLARE @database_id int;

	DECLARE SysCur CURSOR LOCAL FOR SELECT database_id FROM sys.databases;

	OPEN SysCur;

	FETCH NEXT FROM SysCur INTO @database_id;

	WHILE (@@FETCH_STATUS=0)
	BEGIN
		DBCC FLUSHPROCINDB(@database_id) WITH NO_INFOMSGS; --чистка процедурных кэшей

		FETCH NEXT FROM SysCur INTO @database_id;
	END

	CLOSE SysCur;
	DEALLOCATE SysCur;
end

GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [srv].[CleanCashes]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Принудительная чистка кэшей', 'SCHEMA', N'srv', 'PROCEDURE', N'CleanCashes'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [srv].[Backups_info]
--
GO




/*
Автор - Прилепа Б.А. АБД
Мониторинг резервирования данных

exec [dbo].[sp_backups_info] --Вся история по всем базам
exec [dbo].[sp_backups_info] @db='Trucks' --Вя имеющаяся история по одной БД
exec [dbo].[sp_backups_info] @d='2019-01-28',@k=3 /*три дня в прошлое с 2019-01-28*/,@t='DD', @db='Trucks'
exec [dbo].[sp_backups_info] @d='2019-01-26',@k=8 /*8 часов в прошлое с 2019-01-26 00:00:00*/,@t='HH', @db='Trucks'
exec [dbo].[sp_backups_info] @d=null,@t='MI',@k=120 /*за 2 последних часа*/, @db='Trucks'
exec [dbo].[sp_backups_info] @db='Trucks',@d='2019-01-27 06:00:00',@d2='2019-01-25 10:00:00' --с 6 утра 27-го января дня и до 10 утра 25-го
exec [dbo].[sp_backups_info] @DATABASE='MonopolySun' --Получение результатов на удаленном сервера
*/

CREATE procedure [srv].[Backups_info]
	@DATE		datetime	 = null,
	@DATE2		datetime	 = null,
	@DAYS		int			 = 7 /*период от даты*/,
	@INTERVAL	nvarchar(2)	 = N'DD'/*DD - дни*/ ,
	@DATABASE	nvarchar(255)= null
as
begin
	set nocount on;
	set xact_abort on;
	
	if (@DATE is null) set @DATE=getdate();
	
	declare @i int=0;
	
	if (@DATE2 is not null)
	begin
		set @i=1;
		set @DAYS=null;
	end
	
	if (@DATE2>@DATE)
	begin
		print N'Вторая дата @d2 - '''+convert(nvarchar(50),@DATE2,113)+N''' должна быть меньше пераой @d - '''+convert(nvarchar(50),@DATE,113)+N'''!';
		return 0;
	end
	
	if (@DATABASE is null)
		set @DATABASE=N''; --Поиск по всем БД
	
	declare @SQL nvarchar(max)=N'';
	
	declare @DAYS_BEFORE nvarchar(50)=@DAYS;
	
	declare @dop nvarchar(max)='';
	
	if (@i=0)
	begin
		set @dop=N'( '+@DAYS_BEFORE+N' is not null and backup_finish_date<='''+convert(nvarchar(50),@DATE,113)+N''' 
		and backup_finish_date>= dateadd('+@INTERVAL+N',-isnull('+@DAYS_BEFORE+N',999),'''+convert(nvarchar(50),@DATE,113)+N'''))';
	end
	
	if (@i=1)
	begin
		set @dop=N'(backup_finish_date<='''+convert(nvarchar(50), @DATE, 113)+N''' and backup_finish_date>='''+convert(nvarchar(50), @DATE2, 113)+N''')';
	end
	
	set @SQL=
	N'if len('''+@DATABASE+N''')>0 and (select count(1) from master.sys.databases where [name]='''+@DATABASE+N''')=0
	begin
	   print ''Указанная Вами БД ( '+@DATABASE+N' ) не найденна! Проверьте передаваемые параметры!''
	   return
	end
	
	select a.database_name,db.name db,[physical_name],a.recovery_model,
	case when a.type=''D'' then ''Полный'' 
	when a.type=''I'' then ''Дифференциальный''
	when a.type=''L'' then ''Транзакционный''
	when a.type=''F'' then ''File or filegroup''
	when a.type=''G'' then ''Differential file''
	when a.type=''P'' then ''Partial''
	when a.type=''Q'' then ''Differential partialend'' end [type]
	,is_damaged Поврежден
	,MAX(a.backup_finish_date) backup_finish_date
	,cast(c.backup_size/1024.0/1024.0 as numeric(12,3)) as backup_size
	,a.collation_name,
	[physical_device_name]=LAST_VALUE([physical_device_name]) over (partition by a.database_name order by backup_finish_date desc)
	,ROW_NUMBER() over (partition by a.database_name order by backup_finish_date desc) Rang
	,SUM(cast(c.backup_size/1024.0/1024.0 as numeric(12,3))) OVER (partition by 1) all_full_backup_size
	from master.sys.databases db left outer join (select * from [msdb].[dbo].[backupset] 
	where database_name='''+@DATABASE+N''' ) a on(a.database_name=db.name) 
	left join [msdb].[dbo].[backupmediafamily] b on(a.[media_set_id]=b.[media_set_id])
	left join [msdb].[dbo].[backupfile] c on(a.[backup_set_id]=c.[backup_set_id])
	where (db.name='''+@DATABASE+N''' or '''+@DATABASE+N'''='''')
	group by a.database_name,
	db.name
	,[physical_name],
	a.recovery_model,
	a.backup_finish_date,
	a.[compressed_backup_size],
	a.collation_name,
	[physical_device_name],
	c.backup_size,
	is_damaged,
	a.type
	order by a.backup_finish_date desc';
	
	begin try
		print @SQL;

		exec sp_executesql @SQL;
	end try
	begin catch
		print @SQL;

	    select ERROR_MESSAGE() as err_msg, ERROR_LINE() as err_line;
	end catch
end



GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [srv].[Backups_info]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Мониторинг резервирования данных', 'SCHEMA', N'srv', 'PROCEDURE', N'Backups_info'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [srv].[AutoSetRecoveryModelDB]
--
GO


CREATE PROCEDURE [srv].[AutoSetRecoveryModelDB]
	@recovery_model NVARCHAR(255)=N'SIMPLE'
AS
BEGIN
	/*
		автоперевод всех несистемных БД в указанную модель восстановления
	*/

	SET QUERY_GOVERNOR_COST_LIMIT 0;
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @sql NVARCHAR(max);
	DECLARE @server NVARCHAR(255);
	
	SELECT
		[name] INTO #tbl
	FROM sys.databases
	WHERE [database_id]>4
	  AND recovery_model_desc <> @recovery_model;
	
	DECLARE sql_cursor CURSOR LOCAL FOR SELECT
		[name]
	FROM #tbl;
	
	OPEN sql_cursor;
	
	FETCH NEXT FROM sql_cursor
	INTO @server;
	
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @sql=N'ALTER DATABASE ['+@server+N'] SET RECOVERY '+@recovery_model+N' WITH NO_WAIT';
	
		exec sp_executesql @sql;
		
		FETCH NEXT FROM sql_cursor
		INTO @server;
	END
	
	CLOSE sql_cursor;
	DEALLOCATE sql_cursor;
	
	DROP TABLE #tbl;
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [srv].[AutoSetRecoveryModelDB]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Выполняет автоперевод всех несистемных БД в указанную модель восстановления', 'SCHEMA', N'srv', 'PROCEDURE', N'AutoSetRecoveryModelDB'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [srv].[Alter_index]
--
GO


--Анализ используемости, фрагментированности, важности индекса и его реорганизация/перестроение
--Прилепа Б.А. - АБД
--21.03.2019

CREATE PROCEDURE [srv].[Alter_index]
	@DB nvarchar(255)=N'CompositeQuestions',
	@frag int=8,
	@danger int=2,
	@timeout int=5000,
	@op int=1,
	@TableRows int=1000,
	@MaxTableRows bigint=500000,
	@dop int=1000,
	@MI_U int=30,
	@MI_S int=10,
	@FillFactor tinyint=80
AS
BEGIN
	SET XACT_ABORT ON;
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	declare @tbl table([index] nvarchar(2000), [schema_name] varchar(255),[tbl] nvarchar(2000),index_id int,[object_id] int,[type] int,op int,k int identity not null)

	declare @SQL nvarchar(2000)--SQL контэйнер

	SET @SQL='SELECT i.name [index],o.name as [tbl],sh.name [schema_name],i.index_id,o.object_id,i.[type]
	,case when '+cast(@op as varchar(1))+'=1 or p.TableRows>='+cast(@MaxTableRows as varchar(50))+'
	 or (isnull(dm_ius.user_seeks,0)+ isnull(dm_ius.user_scans,0)+isnull(dm_ius.user_lookups,0))*'+cast(@danger as varchar(5))+'<=isnull(dm_ius.user_updates,0) then 1 else 0 end as op
	 FROM ['+@DB+'].sys.dm_db_index_usage_stats dm_ius
	 INNER JOIN ['+@DB+'].sys.indexes i ON i.index_id = dm_ius.index_id AND dm_ius.OBJECT_ID = i.OBJECT_ID
	 INNER JOIN ['+@DB+'].sys.objects o ON dm_ius.OBJECT_ID = o.OBJECT_ID
	 INNER JOIN ['+@DB+'].sys.schemas sh ON o.SCHEMA_ID =sh.SCHEMA_ID
	 INNER JOIN (SELECT SUM(p.rows) TableRows, p.index_id, p.OBJECT_ID
	 FROM ['+@DB+'].sys.partitions p GROUP BY p.index_id, p.OBJECT_ID) p
	 ON p.index_id = dm_ius.index_id AND dm_ius.OBJECT_ID = p.OBJECT_ID
	 WHERE i.type_desc in(''clustered'', ''nonclustered'') 	and (p.TableRows>='+cast(@TableRows as varchar(50))+' and p.TableRows<='+cast(@MaxTableRows*10 as varchar(50))+')
	 AND ((isnull(dm_ius.user_seeks,0)+ isnull(dm_ius.user_scans,0)+isnull(dm_ius.user_lookups,0)>'+cast(@dop as varchar(50))+'))
	 AND (last_user_seek>=cast(dateadd(MI,-'+cast(@MI_S as varchar(50))+',getdate()) as date)
	 OR last_user_scan>=cast(dateadd(MI,-'+cast(@MI_S as varchar(50))+',getdate()) as date)
	 OR last_user_lookup>=cast(dateadd(MI,-'+cast(@MI_S as varchar(50))+',getdate()) as date))
	 AND cast(last_user_update as date)>=cast(dateadd(MI,-'+cast(@MI_U as varchar(50))+',getdate()) as date)
	 order by (isnull(dm_ius.user_seeks,0)+ isnull(dm_ius.user_scans,0)+isnull(dm_ius.user_lookups,0)) desc, user_updates desc '

	insert into @tbl([index], [tbl],[schema_name],index_id, object_id, [type], [op])
	exec sp_executesql @SQL

	--print @SQL
	set @SQL=''

	--счетчик операций
	declare @k int=0

	DECLARE SSCur CURSOR LOCAL FOR SELECT k,'SET LOCK_TIMEOUT '+cast(@timeout as varchar(50))+';
	 ALTER INDEX ['+[index]+'] ON ['+@DB+'].['+[schema_name]+'].['+tbl+'] '+case when @op=1 or op=1 then 'REORGANIZE'
	 when @op=0 then 'REBUILD PARTITION = ALL WITH (SORT_IN_TEMPDB = ON,ALLOW_ROW_LOCKS = ON, FILLFACTOR = '+cast(@FillFactor as varchar(2))+')' end+'
	 UPDATE STATISTICS ['+@DB+'].['+[schema_name]+'].['+tbl+'] ['+[index]+']  WITH FULLSCAN' as script FROM (	SELECT [index],[tbl],[schema_name],op,k FROM @tbl a 
	CROSS APPLY (select top 1 avg_fragmentation_in_percent from sys.dm_db_index_physical_stats(DB_ID(@DB), a.object_id, a.index_id, NULL, NULL)) tbl
	where (tbl.avg_fragmentation_in_percent>@frag and a.[type]=1) OR (tbl.avg_fragmentation_in_percent>@frag*(@frag/2.0) and a.[type]=2)) t
	OPEN SSCur
	FETCH NEXT FROM SSCur INTO @k, @SQL
	WHILE @@FETCH_STATUS=0 BEGIN
		begin try
		    --запуск в цикле скриптов
			print @SQL
			exec sp_executesql @SQL
		end try
		begin catch
			insert into @tbl([index], [tbl],[schema_name],index_id, object_id, [type], [op])
			select top 1 [index], [tbl],[schema_name],index_id, object_id, [type], 1 as [op] from @tbl where k=@k

			select @SQL script,ERROR_MESSAGE() err_msg
		end catch
	FETCH NEXT FROM SSCur INTO @k, @SQL
	END
	CLOSE SSCur
	DEALLOCATE SSCur
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [srv].[Alter_index]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Анализ используемости, фрагментированности, важности индекса и его реорганизация/перестроение', 'SCHEMA', N'srv', 'PROCEDURE', N'Alter_index'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [srv].[All_Find_Ref_Other_DB]
--
GO



CREATE   proc [srv].[All_Find_Ref_Other_DB]
	@DBB sysname=null,
	@srv int=0--'MonopolySun'
as
begin
	set nocount on;
	set xact_abort on;
	
	DECLARE @dbContext nvarchar(256)=@DBB+N'.dbo.'+N'sp_executeSQL';
	DECLARE @DB sysname=N'';
	
	DECLARE ExecCurS CURSOR FOR
	select [name]
	from sys.databases
	where database_id>4; --and (@DB is null or [name]=@DB)

	OPEN ExecCurS;

	FETCH NEXT FROM ExecCurS INTO @DB;

	WHILE (@@FETCH_STATUS=0)
	BEGIN
		SET @dbContext=@DB+N'.dbo.'+N'sp_executeSQL';
	
		EXEC @dbContext N'srv.Find_Ref_Other_DB @DB=@param1,@srv=@param2',N'@param1 varchar(255),@param2 int',@param1=@DBB,@param2=@srv
	
		FETCH NEXT FROM ExecCurS INTO @DB;
	END

	CLOSE ExecCurS;
	DEALLOCATE ExecCurS;
end
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [srv].[All_Find_Ref_Other_DB]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Формирование картинки зависимостей sql stored objects для всего SQL Server-а.
В оснвое используется перебор всех пользовательских БД с вызовом ХП Find_Ref_Other_DB.', 'SCHEMA', N'srv', 'PROCEDURE', N'All_Find_Ref_Other_DB'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [srv].[AutoReadWriteTablesStatistics]
--
GO
ALTER PROCEDURE [srv].[AutoReadWriteTablesStatistics]
AS
BEGIN
	/*
		Сбор данных по чтению/записи таблицы (кучи не рассматриваются, т к у них нет индексов).
		Только те таблицы, к которым обращались после запуска SQL Server
	*/
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	declare @dt date=CAST(GetUTCDate() as date);
    declare @dbs nvarchar(255);
	declare @sql nvarchar(max);

	select [name]
	into #dbs3
	from [master].sys.databases;

	DECLARE sql_cursor CURSOR LOCAL FOR
	select [name]
	from #dbs3;
	
	OPEN sql_cursor;
	  
	FETCH NEXT FROM sql_cursor   
	INTO @dbs;

	while (@@FETCH_STATUS = 0 )
	begin
		set @sql=N'USE ['+@dbs+N'];
		if(exists(select top(1) 1 from sys.views where [name]=''vReadWriteTables'' and [schema_id]=schema_id(''inf'')))
		begin
			INSERT INTO [FortisAdmin].[srv].[ReadWriteTablesStatistics]
			([ServerName]
		     ,[DBName]
		     ,[SchemaTableName]
		     ,[TableName]
		     ,[Reads]
		     ,[Writes]
		     ,[Reads&Writes]
		     ,[SampleDays]
		     ,[SampleSeconds])
			SELECT [ServerName]
		     ,[DBName]
		     ,[SchemaTableName]
		     ,[TableName]
		     ,[Reads]
		     ,[Writes]
		     ,[Reads&Writes]
		     ,[SampleDays]
		     ,[SampleSeconds]
			FROM ['+@dbs+N'].[inf].[vReadWriteTables];
		end';

		exec sp_executesql @sql;

		FETCH NEXT FROM sql_cursor
		INTO @dbs;
	end

	CLOSE sql_cursor;
	DEALLOCATE sql_cursor;
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [srv].[AutoIndexStatistics]
--
GO




-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER   PROCEDURE [srv].[AutoIndexStatistics]
AS
BEGIN
	/*
		Сбор информацию по индексам и статистикам по всем помеченным БД экземпляра MS SQL Server
	*/
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	declare @servername nvarchar(255)=cast(SERVERPROPERTY(N'MachineName') as nvarchar(255));

	declare @dt date=CAST(GetUTCDate() as date);
    declare @dbs nvarchar(255);
	declare @sql nvarchar(max);
	declare @paramdef nvarchar(255)=N'@servername nvarchar(255)';

	--сбор фрагментации индексов
	select [name]
	into #dbs3
	from [master].sys.databases;

	while(exists(select top(1) 1 from #dbs3))
	begin
		select top(1)
		@dbs=[name]
		from #dbs3;

		set @sql=
		N'USE ['+@dbs+']; '
		+N'IF(object_id('+N''''+N'[inf].[vIndexDefrag]'+N''''+N') is not null) BEGIN '
		+N'insert into [FortisAdmin].[srv].[IndexDefragStatistics]
	         ([Server]
			 ,[db]
			 ,[shema]
			 ,[tb]
			 ,[idx]
			 ,[database_id]
			 ,[index_name]
			 ,[index_type_desc]
			 ,[level]
			 ,[object_id]
			 ,[frag_num]
			 ,[frag]
			 ,[frag_page]
			 ,[page]
			 ,[rec]
			 ,[ghost]
			 ,[func])
		SELECT @servername AS [Server]
		     ,[db]
			 ,[shema]
			 ,[tb]
			 ,[idx]
			 ,[database_id]
			 ,[index_name]
			 ,[index_type_desc]
			 ,[level]
			 ,[object_id]
			 ,[frag_num]
			 ,[frag]
			 ,[frag_page]
			 ,[page]
			 ,[rec]
			 ,[ghost]
			 ,[func]
		  FROM [inf].[vIndexDefrag]; END';

		exec sp_executesql @sql, @paramdef, @servername=@servername;

		delete from #dbs3
		where [name]=@dbs;
	end

	--сбор использования индексов
	select [name]
	into #dbs
	from sys.databases;

	while(exists(select top(1) 1 from #dbs))
	begin
		select top(1)
		@dbs=[name]
		from #dbs;

		set @sql=
		N'USE ['+@dbs+']; '
		+N'IF(object_id('+N''''+N'[inf].[vIndexUsageStats]'+N''''+N') is not null) BEGIN '
		+N'INSERT INTO [FortisAdmin].[srv].[IndexUsageStatsStatistics]
	         ([SERVER]
			,[DataBase]
			,[SCHEMA_NAME]
			,[OBJECT NAME]
			,[INDEX NAME]
			,[index_advantage]
			,[USER_SEEKS]
			,[USER_SCANS]
			,[USER_LOOKUPS]
			,[USER_UPDATES]
			,[Last_User_Seek]
			,[Last_User_Scan]
			,[Last_User_Lookup]
			,[Last_User_Update]
			,[System_Seeks]
			,[System_Scans]
			,[System_Lookups]
			,[System_Updates]
			,[Last_System_Seek]
			,[Last_System_Scan]
			,[Last_System_Lookup]
			,[Last_System_Update]
			,[schema_id]
			,[object_id]
			,[index_id]
			,[ObjectType]
			,[TYPE_DESC_OBJECT]
			,[IndexType]
			,[TYPE_DESC_INDEX]
			,[Is_Unique]
			,[Data_Space_ID]
			,[Ignore_Dup_Key]
			,[Is_Primary_Key]
			,[Is_Unique_Constraint]
			,[Fill_Factor]
			,[Is_Padded]
			,[Is_Disabled]
			,[Is_Hypothetical]
			,[Allow_Row_Locks]
			,[Allow_Page_Locks]
			,[Has_Filter]
			,[Filter_Definition]
			,[Columns]
			,[IncludeColumns])
	   SELECT @servername AS [Server]
			,DB_Name()
			,[SCHEMA_NAME]
			,[OBJECT NAME]
			,[INDEX NAME]
			,[index_advantage]
			,[USER_SEEKS]
			,[USER_SCANS]
			,[USER_LOOKUPS]
			,[USER_UPDATES]
			,[Last_User_Seek]
			,[Last_User_Scan]
			,[Last_User_Lookup]
			,[Last_User_Update]
			,[System_Seeks]
			,[System_Scans]
			,[System_Lookups]
			,[System_Updates]
			,[Last_System_Seek]
			,[Last_System_Scan]
			,[Last_System_Lookup]
			,[Last_System_Update]
			,[schema_id]
			,[object_id]
			,[index_id]
			,[ObjectType]
			,[TYPE_DESC_OBJECT]
			,[IndexType]
			,[TYPE_DESC_INDEX]
			,[Is_Unique]
			,[Data_Space_ID]
			,[Ignore_Dup_Key]
			,[Is_Primary_Key]
			,[Is_Unique_Constraint]
			,[Fill_Factor]
			,[Is_Padded]
			,[Is_Disabled]
			,[Is_Hypothetical]
			,[Allow_Row_Locks]
			,[Allow_Page_Locks]
			,[Has_Filter]
			,[Filter_Definition]
			,[Columns]
			,[IncludeColumns]
		FROM ['+@dbs+'].[inf].[vIndexUsageStats]; END';

		exec sp_executesql @sql, @paramdef, @servername=@servername;

		delete from #dbs
		where [name]=@dbs;
	end

	--сбор перекрывающихся индексов
	select [name]
	into #dbs4
	from sys.databases;

	while(exists(select top(1) 1 from #dbs4))
	begin
		select top(1)
		@dbs=[name]
		from #dbs4;

		set @sql=
		N'USE ['+@dbs+']; '
		+N'IF(object_id('+N''''+N'[srv].[vDelIndexInclude]'+N''''+N') is not null) BEGIN '
		+N'INSERT INTO [FortisAdmin].[srv].[DelIndexIncludeStatistics]
	         ([Server]
			,[DataBase]
			,[SchemaName]
			,[ObjectName]
			,[ObjectType]
			,[ObjectCreateDate]
			,[DelIndexName]
			,[IndexIsPrimaryKey]
			,[IndexType]
			,[IndexFragmentation]
			,[IndexFragmentCount]
			,[IndexAvgFragmentSizeInPages]
			,[IndexPages]
			,[IndexKeyColumns]
			,[IndexIncludedColumns]
			,[ActualIndexName])
	   SELECT @servername AS [Server]
			,DB_Name()
			,[SchemaName]
			,[ObjectName]
			,[ObjectType]
			,[ObjectCreateDate]
			,[DelIndexName]
			,[IndexIsPrimaryKey]
			,[IndexType]
			,[IndexFragmentation]
			,[IndexFragmentCount]
			,[IndexAvgFragmentSizeInPages]
			,[IndexPages]
			,[IndexKeyColumns]
			,[IndexIncludedColumns]
			,[ActualIndexName]
		FROM ['+@dbs+'].[srv].[vDelIndexInclude]; END';

		exec sp_executesql @sql, @paramdef, @servername=@servername;

		delete from #dbs4
		where [name]=@dbs;
	end

	--сбор устаревших статистик
	select [name]
	into #dbs5
	from sys.databases;

	while(exists(select top(1) 1 from #dbs5))
	begin
		select top(1)
		@dbs=[name]
		from #dbs5;

		set @sql=
		N'USE ['+@dbs+']; '
		+N'IF(object_id('+N''''+N'[inf].[vOldStatisticsState]'+N''''+N') is not null) BEGIN '
		+N'INSERT INTO [FortisAdmin].[srv].[OldStatisticsStateStatistics]
	         ([Server]
			,[DataBase]
			,[object_id]
			,[SchemaName]
			,[ObjectName]
			,[stats_id]
			,[StatName]
			,[row_count]
			,[ProcModified]
			,[ObjectSizeMB]
			,[type_desc]
			,[create_date]
			,[last_updated]
			,[ModificationCounter]
			,[ProcSampled]
			,[Func]
			,[IsScanned]
			,[ColumnType]
			,[auto_created]
			,[IndexName]
			,[has_filter])
	   SELECT @servername AS [Server]
			,DB_Name()
			,[object_id]
			,[SchemaName]
			,[ObjectName]
			,[stats_id]
			,[StatName]
			,[row_count]
			,[ProcModified]
			,[ObjectSizeMB]
			,[type_desc]
			,[create_date]
			,[last_updated]
			,[ModificationCounter]
			,[ProcSampled]
			,[Func]
			,[IsScanned]
			,[ColumnType]
			,[auto_created]
			,[IndexName]
			,[has_filter]
		FROM ['+@dbs+'].[inf].[vOldStatisticsState]; END';

		exec sp_executesql @sql, @paramdef, @servername=@servername;

		delete from #dbs5
		where [name]=@dbs;
	end

	drop table #dbs;
	drop table #dbs3;
	drop table #dbs4;
	drop table #dbs5;
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [srv].[AutoDeleteSnapshotNotDB]
--
GO


ALTER PROCEDURE [srv].[AutoDeleteSnapshotNotDB]
	@path nvarchar(2000)='E:\DB\'
AS
BEGIN
	/*
		удаление моментальных снимков, которые не привязаны к текущим БД
	*/

	SET QUERY_GOVERNOR_COST_LIMIT 0;
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	set xact_abort on;
	 
	declare @table table(a nvarchar(4000), b int, c int);
	 
	insert into @table(a,b,c)
	exec xp_dirtree @path, 1, 1;
	 
	declare @SQL nvarchar(max)=N'';
	 
	select @SQL=@SQL+N'
	exec xp_cmdshell ''del '+@path+N''+b.a+N'''
	'
	from
	(select b.physical_name as physical_name
	 from sys.databases a inner join sys.master_files as b on (a.database_id=b.database_id )
	where a.source_database_id is not null) as a
	full outer join @table as b on (a.physical_name=@path+b.a )
	where a.physical_name is null
	and b.a like N'%.ss';
	 
	--заменить print на exec
	--print @SQL;
	
	if(len(@SQL)>1)	exec sp_executesql @SQL;
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [srv].[AutoDeleteFileNotDB]
--
GO


ALTER PROCEDURE [srv].[AutoDeleteFileNotDB]
	@path_data nvarchar(4000)=N'E:\sql_data\' --каталог mdf файлов
   ,@path_log nvarchar(4000)=N'F:\sql_log\' --каталог ldf файлов
AS
BEGIN
	/*
		удаление не привязанных к серверу MS SQL mdf, ldf файлов
	*/

	SET QUERY_GOVERNOR_COST_LIMIT 0;
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	set xact_abort on;
	 
	declare @tbl table(a nvarchar(4000), b int, c int, d int); --собираем содержимое файлов
 
	insert into @tbl(a,b,c) --mdf файлы собираем
	exec xp_dirtree @path_data,1,1;
	 
	update @tbl --метка для пути @path
	set d=1;
	 
	insert into @tbl(a,b,c) --ldf файлы собираем
	exec xp_dirtree @path_log,1,1
	 
	--в для @path2 получит значение null
	 
	declare @SQL nvarchar(max)=N''--контейнер sql скрипта
	 
	select @SQL=@SQL+N'
	exec xp_cmdshell ''del '+case when d=1 then @path_data+p.a else @path_log+p.a end+N''''
	from
	(select db.name DB, mf.physical_name
	from sys.databases db
	INNER JOIN sys.master_files mf on(db.database_id=mf.database_id)
	where db.database_id>4 /*не системные, не смотрим онлайн БД и пр. это не важно*/) db
	right outer join @tbl p ON(db.physical_name=case when d=1 then @path_data+p.a else @path_log+p.a end)
	where db.DB is null
	and (p.a like N'%.mdf' or p.a like N'%.ldf');
	 
	begin try
	    exec sp_executesql @SQL; --выполняем удаление файлов (поскольку они не связанны, то должны удаляться на ура)
	    print @SQL;--печатаем скрипт
	end try
	begin catch --Обработчик ошибок
	    IF @@ERROR<>0
	    begin
	        print @SQL;
	        select ERROR_MESSAGE() err_msg; --обработка ошибок
	    end
	end catch
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [zabbix].[GetWriteStallMSTempDB]
--
GO




-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER PROCEDURE [zabbix].[GetWriteStallMSTempDB]
AS
BEGIN
	/*
		Максимальное из средних значений по задержке записи на файлы БД TempDB в МС
	*/

	--SET QUERY_GOVERNOR_COST_LIMIT 0;
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	SET XACT_ABORT ON;

	SELECT max([avg_write_stall_ms]) as [valueMS]
	FROM [srv].[vStatisticsIOInTempDB];
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [zabbix].[GetReadStallMSTempDB]
--
GO





-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER PROCEDURE [zabbix].[GetReadStallMSTempDB]
AS
BEGIN
	/*
		Максимальное из средних значений по задержке чтения на файлы БД TempDB в МС
	*/

	--SET QUERY_GOVERNOR_COST_LIMIT 0;
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	SET XACT_ABORT ON;

	SELECT max([avg_read_stall_ms]) as [valueMS]
	FROM [srv].[vStatisticsIOInTempDB];
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create table [srv].[history_dm_db_index_usage_stats]
--
CREATE TABLE [srv].[history_dm_db_index_usage_stats] (
  [database_id] [smallint] NOT NULL,
  [object_id] [int] NOT NULL,
  [index_id] [int] NOT NULL,
  [user_seeks] [bigint] NOT NULL,
  [user_scans] [bigint] NOT NULL,
  [user_lookups] [bigint] NOT NULL,
  [user_updates] [bigint] NOT NULL,
  [last_user_seek] [datetime] NULL,
  [last_user_scan] [datetime] NULL,
  [last_user_lookup] [datetime] NULL,
  [last_user_update] [datetime] NULL,
  [system_seeks] [bigint] NOT NULL,
  [system_scans] [bigint] NOT NULL,
  [system_lookups] [bigint] NOT NULL,
  [system_updates] [bigint] NOT NULL,
  [last_system_seek] [datetime] NULL,
  [last_system_scan] [datetime] NULL,
  [last_system_lookup] [datetime] NULL,
  [last_system_update] [datetime] NULL,
  [DateInsert] [datetime] NOT NULL CONSTRAINT [DF__history_d__DateI__0DCF0841] DEFAULT (getdate()),
  [Id] [bigint] IDENTITY,
  CONSTRAINT [PK__history___3214EC073A11781B] PRIMARY KEY CLUSTERED ([Id]) WITH (FILLFACTOR = 95)
)
ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indInsertUTCDate] from table [srv].[SessionTran]
--
DROP INDEX [indInsertUTCDate] ON [srv].[SessionTran]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop primary key [PK_SessionTran] on table [srv].[SessionTran]
--
ALTER TABLE [srv].[SessionTran]
  DROP CONSTRAINT [PK_SessionTran]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create primary key [PK_SessionTran] on table [srv].[SessionTran]
--
ALTER TABLE [srv].[SessionTran]
  ADD CONSTRAINT [PK_SessionTran] PRIMARY KEY CLUSTERED ([SessionID], [TransactionID]) WITH (FILLFACTOR = 95)
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indInsertUTCDate] on table [srv].[SessionTran]
--
CREATE INDEX [indInsertUTCDate]
  ON [srv].[SessionTran] ([InsertUTCDate])
  WITH (FILLFACTOR = 95)
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on index [srv].[SessionTran].[indInsertUTCDate]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Индекс по InsertUTCDate', 'SCHEMA', N'srv', 'TABLE', N'SessionTran', 'INDEX', N'indInsertUTCDate'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop primary key [PK_IndicatorStatistics] on table [srv].[IndicatorStatistics]
--
ALTER TABLE [srv].[IndicatorStatistics]
  DROP CONSTRAINT [PK_IndicatorStatistics]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create primary key [PK_IndicatorStatistics] on table [srv].[IndicatorStatistics]
--
ALTER TABLE [srv].[IndicatorStatistics]
  ADD CONSTRAINT [PK_IndicatorStatistics] PRIMARY KEY CLUSTERED ([DATE])
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter function [rep].[GetTimeFormat]
--
GO

ALTER FUNCTION [rep].[GetTimeFormat] 
(
	@dt datetime, -- input time
	@format int=0 -- specified format
)
RETURNS nvarchar(255)
AS
/*
	Returns the time as a string according to the specified format and input time.
	Dumps the necessary zeros:
	format 	input time		result
	0		17:04			"17:04:00"
	1		17:04			"17:04"
	1		8:04			"08:04"
	2		17:04			"17"
*/
BEGIN
	DECLARE @res nvarchar(255);
	DECLARE @hour int=DATEPART(HOUR, @dt);
	DECLARE @min int=DATEPART(MINUTE, @dt);
	DECLARE @sec int=DATEPART(SECOND, @dt);

	if(@format=0)
	begin
		set @res=case when(@hour<10) then '0'+cast(@hour as nvarchar(1)) else cast(@hour as nvarchar(2))+':' end;
		set @res=@res+case when(@min<10) then '0'+cast(@min as nvarchar(1)) else cast(@min as nvarchar(2))+':' end;
		set @res=@res+case when(@sec<10) then '0'+cast(@sec as nvarchar(1)) else cast(@sec as nvarchar(2)) end;
	end
	else if(@format=1)
	begin
		set @res=case when(@hour<10) then '0'+cast(@hour as nvarchar(1)) else cast(@hour as nvarchar(2))+':' end;
		set @res=@res+case when(@min<10) then '0'+cast(@min as nvarchar(1)) else cast(@min as nvarchar(2)) end;
	end
	else if(@format=2)
	begin
		set @res=case when(@hour<10) then '0'+cast(@hour as nvarchar(1)) else cast(@hour as nvarchar(2)) end;
	end

	RETURN @res;

END

GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Update extended property [MS_Description] on function [rep].[GetTimeFormat]
--
EXEC sys.sp_updateextendedproperty N'MS_Description', N'Returns the time as a string according to the specified format and input time', 'SCHEMA', N'rep', 'FUNCTION', N'GetTimeFormat'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter function [rep].[GetDateFormat]
--
GO

ALTER FUNCTION [rep].[GetDateFormat] 
(
	@dt datetime, -- input date
	@format int=0 -- specified format
)
RETURNS nvarchar(255)
AS
/*
	Returns the date as a string according to the specified format and input date.
	Dumps the necessary zeros:
	format  input date		result
	0		17.4.2014		"17.04.2014"
	1		17.4.2014		"04.2014"
	1		8.11.2014		"11.2014"
	2		17.04.2014		"2014"
*/
BEGIN
	DECLARE @res nvarchar(255);
	DECLARE @day int=DAY(@dt);
	DECLARE @month int=MONTH(@dt);
	DECLARE @year int=YEAR(@dt);

	if(@format=0)
	begin
		set @res=case when(@day<10) then '0'+cast(@day as nvarchar(1)) else cast(@day as nvarchar(2))+'.' end;
		set @res=@res+case when(@month<10) then '0'+cast(@month as nvarchar(1)) else cast(@month as nvarchar(2))+'.' end;
		set @res=@res+cast(@year as nvarchar(255));
	end
	else if(@format=1)
	begin
		set @res=case when(@month<10) then '0'+cast(@month as nvarchar(1)) else cast(@month as nvarchar(2))+'.' end;
		set @res=@res+cast(@year as nvarchar(255));
	end
	else if(@format=2)
	begin
		set @res=cast(@year as nvarchar(255));
	end

	RETURN @res;

END


GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Update extended property [MS_Description] on function [rep].[GetDateFormat]
--
EXEC sys.sp_updateextendedproperty N'MS_Description', N'Returns the date as a string according to the specified format and input date', 'SCHEMA', N'rep', 'FUNCTION', N'GetDateFormat'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [rep].[GetProjectHoursInDate]
--
GO
CREATE PROCEDURE [rep].[GetProjectHoursInDate]
(
	@user_display nvarchar(255),
	@stdate date,
	@fndate date
)
AS BEGIN
/*
	затраченное время в часах выбранного сотрудника по проектам и датам
*/  
    SET NOCOUNT ON;  
  
    set transaction isolation level read uncommitted;

	set @fndate=DateAdd(day,1, @fndate);
	
	declare @lower_user_name nvarchar(255);
	
	select top(1)
	@lower_user_name=[lower_user_name]
	FROM [Jira].[dbo].[cwd_user]
	  where [display_name] = @user_display;
	
	select p.[pkey] as [ProjectKey], p.[pname] as [ProjectName], ji.SUMMARY, cast(wl.[STARTDATE] as DATE) as [DATE], cast(cast(sum(wl.[timeworked]) as numeric(18,3))/3600 as numeric(18,3)) as [DurationHour]
	from [Jira].[dbo].[project]   as p
	join [Jira].[dbo].[jiraissue] as ji on (ji.[PROJECT] = p.[ID])
	join [Jira].[dbo].[worklog]   as wl on (wl.[issueid]=ji.[ID])
	where wl.[AUTHOR]=@lower_user_name--кто+также можно проект и диапазон дат
	and wl.[STARTDATE] between @stdate and @fndate
	group by cast(wl.[STARTDATE] as DATE), p.[pkey], p.[pname], ji.SUMMARY;
  
END  
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [rep].[GetProjectHoursInDate]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Возвращает затраченное время в часах выбранного сотрудника по проектам и датам', 'SCHEMA', N'rep', 'PROCEDURE', N'GetProjectHoursInDate'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [inf].[InfoAgentJobs]
--
GO
ALTER PROCEDURE [inf].[InfoAgentJobs]
AS
BEGIN
	--Необходимые типовые задания
	SET NOCOUNT ON;
	
		--Необходимо выполнить на каждой нужной БД, включая системные:

		--CREATE SCHEMA [inf]
		--GO

		--CREATE SCHEMA [srv]
		--GO
		
		--SET ANSI_NULLS ON
		--GO
		
		--SET QUOTED_IDENTIFIER ON
		--GO
		
		
		--CREATE VIEW [inf].[vCountRows]
				 
		--CREATE VIEW [inf].[vIndexDefrag]
				 
		--CREATE VIEW [inf].[vTableSize]
				 
		--CREATE PROCEDURE [srv].[AutoDefragIndex]
				 
		--CREATE PROCEDURE [srv].[AutoUpdateStatistics]

    /*
		1) syspolicy_purge_history – Удаляет журнал выполнения политик в соответствии с параметром интервала хранения журнала
		2) Автосбор данных о выполненных заданиях – запускается ежедневно:
		USE [SRV];
		go
		
		begin try
				declare @body nvarchar(max);
		        exec [SRV].[srv].[AutoShortInfoRunJobs]
						@second=60
					   ,@body=@body output;
		
				EXEC [msdb].[dbo].[sp_send_dbmail]
				-- Созданный нами профиль администратора почтовых рассылок
					@profile_name = 'profile_name',
				-- Адрес получателя
					@recipients = 'Gribkov@mkis.su;',--'Gribkov@mkis.su',
				-- Текст письма
					@body = @body,
				-- Тема
					@subject = N'ИНФОРМАЦИЯ ПО ОШИБКАМ ВЫПОЛНЕНИЯ',
					@body_format='HTML'--,
		end try
		begin catch
		    declare @str_mess nvarchar(max)=ERROR_MESSAGE(),
		            @str_num  nvarchar(max)=cast(ERROR_NUMBER() as nvarchar(max)),
		            @str_line nvarchar(max)=cast(ERROR_LINE()   as nvarchar(max)),
		            @str_proc nvarchar(max)=ERROR_PROCEDURE(),
		            @str_title nvarchar(max)=N'Автосбор данных о выполненных заданиях на сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)),
		            @str_pred_mess nvarchar(max)=N'На сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255))+N' возникла ошибка автосбора данных о выполненных заданиях';
		
		    exec [SRV].srv.ErrorInfoIncUpd
		         @ERROR_TITLE           = @str_title,
		         @ERROR_PRED_MESSAGE    = @str_pred_mess,
		         @ERROR_NUMBER          = @str_num,
		         @ERROR_MESSAGE         = @str_mess,
		         @ERROR_LINE            = @str_line,
		         @ERROR_PROCEDURE       = @str_proc,
		         @ERROR_POST_MESSAGE    = NULL,
		         @RECIPIENTS            = 'DBA;';
		
		     declare @err int=@@error;
		     raiserror(@str_mess,16,1);
		end catch
		3) Автосбор данных файлов баз данных – запускается ежедневно:
		USE [SRV];
		go
		
		begin try
				exec [srv].[MergeDBFileInfo];
				--exec [srv].[MergeDriverInfo]; --о дисках
		end try
		begin catch
		    declare @str_mess nvarchar(max)=ERROR_MESSAGE(),
		            @str_num  nvarchar(max)=cast(ERROR_NUMBER() as nvarchar(max)),
		            @str_line nvarchar(max)=cast(ERROR_LINE()   as nvarchar(max)),
		            @str_proc nvarchar(max)=ERROR_PROCEDURE(),
		            @str_title nvarchar(max)=N'Автосбор данных о дисках и файлов баз данных на сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)),
		            @str_pred_mess nvarchar(max)=N'На сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255))+N' возникла ошибка автосбора данных о дисках и файлов баз данных';
		
		    exec [SRV].srv.ErrorInfoIncUpd
		         @ERROR_TITLE           = @str_title,
		         @ERROR_PRED_MESSAGE    = @str_pred_mess,
		         @ERROR_NUMBER          = @str_num,
		         @ERROR_MESSAGE         = @str_mess,
		         @ERROR_LINE            = @str_line,
		         @ERROR_PROCEDURE       = @str_proc,
		         @ERROR_POST_MESSAGE    = NULL,
		         @RECIPIENTS            = 'DBA;';
		
		     declare @err int=@@error;
		     raiserror(@str_mess,16,1);
		end catch
		4) Автосбор данных об активных запросах для группировки – запускается ежедневно:
		USE [SRV];
		go
		
		begin try
		                exec [srv].[RunRequestGroupStatistics];
		end try
		begin catch
		    declare @str_mess nvarchar(max)=ERROR_MESSAGE(),
		            @str_num  nvarchar(max)=cast(ERROR_NUMBER() as nvarchar(max)),
		            @str_line nvarchar(max)=cast(ERROR_LINE()   as nvarchar(max)),
		            @str_proc nvarchar(max)=ERROR_PROCEDURE(),
		            @str_title nvarchar(max)=N'Автосбор данных об активных запросах на сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)),
		            @str_pred_mess nvarchar(max)=N'На сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255))+N' возникла ошибка автосбора данных об активных запросах';
		
		    exec [SRV].srv.ErrorInfoIncUpd
		         @ERROR_TITLE           = @str_title,
		         @ERROR_PRED_MESSAGE    = @str_pred_mess,
		         @ERROR_NUMBER          = @str_num,
		         @ERROR_MESSAGE         = @str_mess,
		         @ERROR_LINE            = @str_line,
		         @ERROR_PROCEDURE       = @str_proc,
		         @ERROR_POST_MESSAGE    = NULL,
		         @RECIPIENTS            = 'DBA;';
		
		     declare @err int=@@error;
		     raiserror(@str_mess,16,1);
		end catch
		5) Автосбор данных об активных подключениях – запускается каждые 10 минут:
		USE [SRV];
		go
		
		begin try
		    exec [srv].[AutoStatisticsActiveConnections];
		end try
		begin catch
		    declare @str_mess nvarchar(max)=ERROR_MESSAGE(),
		            @str_num  nvarchar(max)=cast(ERROR_NUMBER() as nvarchar(max)),
		            @str_line nvarchar(max)=cast(ERROR_LINE()   as nvarchar(max)),
		            @str_proc nvarchar(max)=ERROR_PROCEDURE(),
		            @str_title nvarchar(max)=N'Автосбор данных об активных подключениях на сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)),
		            @str_pred_mess nvarchar(max)=N'На сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255))+N' возникла ошибка автосбора данных об активных подключениях';
		
		    exec [SRV].srv.ErrorInfoIncUpd
		         @ERROR_TITLE           = @str_title,
		         @ERROR_PRED_MESSAGE    = @str_pred_mess,
		         @ERROR_NUMBER          = @str_num,
		         @ERROR_MESSAGE         = @str_mess,
		         @ERROR_LINE            = @str_line,
		         @ERROR_PROCEDURE       = @str_proc,
		         @ERROR_POST_MESSAGE    = NULL,
		         @RECIPIENTS            = 'DBA;';
		
		     declare @err int=@@error;
		     raiserror(@str_mess,16,1);
		end catch
		6) Автосбор данных об производительности СУБД – запускается ежедневно:
		USE [SRV];
		go
		
		begin try
		                exec [srv].[AutoStatisticsTimeRequests];
		end try
		begin catch
		    declare @str_mess nvarchar(max)=ERROR_MESSAGE(),
		            @str_num  nvarchar(max)=cast(ERROR_NUMBER() as nvarchar(max)),
		            @str_line nvarchar(max)=cast(ERROR_LINE()   as nvarchar(max)),
		            @str_proc nvarchar(max)=ERROR_PROCEDURE(),
		            @str_title nvarchar(max)=N'Автосбор данных об производительности СУБД на сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)),
		            @str_pred_mess nvarchar(max)=N'На сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255))+N' возникла ошибка автосбора данных об производительности СУБД';
		
		    exec [SRV].srv.ErrorInfoIncUpd
		         @ERROR_TITLE           = @str_title,
		         @ERROR_PRED_MESSAGE    = @str_pred_mess,
		         @ERROR_NUMBER          = @str_num,
		         @ERROR_MESSAGE         = @str_mess,
		         @ERROR_LINE            = @str_line,
		         @ERROR_PROCEDURE       = @str_proc,
		         @ERROR_POST_MESSAGE    = NULL,
		         @RECIPIENTS            = 'DBA;';
		
		     declare @err int=@@error;
		     raiserror(@str_mess,16,1);
		end catch
		7) Автосбор кол-ва строк кластерных структур и размера таблиц – запускается ежедневно:
		USE [SRV];
		go
		
		begin try
		                exec [srv].[InsertTableStatistics];
		end try
		begin catch
		    declare @str_mess nvarchar(max)=ERROR_MESSAGE(),
		            @str_num  nvarchar(max)=cast(ERROR_NUMBER() as nvarchar(max)),
		            @str_line nvarchar(max)=cast(ERROR_LINE()   as nvarchar(max)),
		            @str_proc nvarchar(max)=ERROR_PROCEDURE(),
		            @str_title nvarchar(max)=N'Автосбор кол-ва строк кластерных структур  и размер таблиц на сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)),
		            @str_pred_mess nvarchar(max)=N'На сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255))+N' возникла ошибка автосбора кол-ва строк кластерных структур и размера таблиц';
		
		    exec [SRV].srv.ErrorInfoIncUpd
		         @ERROR_TITLE           = @str_title,
		         @ERROR_PRED_MESSAGE    = @str_pred_mess,
		         @ERROR_NUMBER          = @str_num,
		         @ERROR_MESSAGE         = @str_mess,
		         @ERROR_LINE            = @str_line,
		         @ERROR_PROCEDURE       = @str_proc,
		         @ERROR_POST_MESSAGE    = NULL,
		         @RECIPIENTS            = 'DBA;';
		
		     declare @err int=@@error;
		     raiserror(@str_mess,16,1);
		end catch
		8) Автосбор статистики роста файлов БД – запускается ежедневно:
		USE [SRV];
		go
		
		begin try
		    exec [srv].[AutoStatisticsFileDB]
		end try
		begin catch
		    declare @str_mess nvarchar(max)=ERROR_MESSAGE(),
		            @str_num  nvarchar(max)=cast(ERROR_NUMBER() as nvarchar(max)),
		            @str_line nvarchar(max)=cast(ERROR_LINE()   as nvarchar(max)),
		            @str_proc nvarchar(max)=ERROR_PROCEDURE(),
		            @str_title nvarchar(max)=N'Автосбор статистики роста файлов БД на сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)),
		            @str_pred_mess nvarchar(max)=N'На сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255))+N' возникла ошибка автосбора статистики роста файлов БД';
		
		    exec [SRV].srv.ErrorInfoIncUpd
		         @ERROR_TITLE           = @str_title,
		         @ERROR_PRED_MESSAGE    = @str_pred_mess,
		         @ERROR_NUMBER          = @str_num,
		         @ERROR_MESSAGE         = @str_mess,
		         @ERROR_LINE            = @str_line,
		         @ERROR_PROCEDURE       = @str_proc,
		         @ERROR_POST_MESSAGE    = NULL,
		         @RECIPIENTS            = 'DBA;';
		
		     declare @err int=@@error;
		     raiserror(@str_mess,16,1);
		end catch
		
		9) Автоудаление зависших неактивных подключений – запускается ежедневно:
		USE [SRV];
		go
		
		begin try
		                exec [srv].[KillFullOldConnect];
		end try
		begin catch
		    declare @str_mess nvarchar(max)=ERROR_MESSAGE(),
		            @str_num  nvarchar(max)=cast(ERROR_NUMBER() as nvarchar(max)),
		            @str_line nvarchar(max)=cast(ERROR_LINE()   as nvarchar(max)),
		            @str_proc nvarchar(max)=ERROR_PROCEDURE(),
		            @str_title nvarchar(max)=N'Автоудаление зависших неактивных подключений на сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)),
		            @str_pred_mess nvarchar(max)=N'На сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255))+N' возникла ошибка автоудаления зависших подключений';
		
		    exec [SRV].srv.ErrorInfoIncUpd
		         @ERROR_TITLE           = @str_title,
		         @ERROR_PRED_MESSAGE    = @str_pred_mess,
		         @ERROR_NUMBER          = @str_num,
		         @ERROR_MESSAGE         = @str_mess,
		         @ERROR_LINE            = @str_line,
		         @ERROR_PROCEDURE       = @str_proc,
		         @ERROR_POST_MESSAGE    = NULL,
		         @RECIPIENTS            = 'DBA;';
		
		     declare @err int=@@error;
		     raiserror(@str_mess,16,1);
		end catch
		10) Автоудаление старых записей – запускается ежедневно:
		USE [SRV];
		go
		
		begin try
		                exec [srv].[DeleteArchive];
		end try
		begin catch
		    declare @str_mess nvarchar(max)=ERROR_MESSAGE(),
		            @str_num  nvarchar(max)=cast(ERROR_NUMBER() as nvarchar(max)),
		            @str_line nvarchar(max)=cast(ERROR_LINE()   as nvarchar(max)),
		            @str_proc nvarchar(max)=ERROR_PROCEDURE(),
		            @str_title nvarchar(max)=N'Автоудаление старых записей на сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)),
		            @str_pred_mess nvarchar(max)=N'На сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255))+N' возникла ошибка автоудаления старых записей';
		
		    exec [SRV].srv.ErrorInfoIncUpd
		         @ERROR_TITLE           = @str_title,
		         @ERROR_PRED_MESSAGE    = @str_pred_mess,
		         @ERROR_NUMBER          = @str_num,
		         @ERROR_MESSAGE         = @str_mess,
		         @ERROR_LINE            = @str_line,
		         @ERROR_PROCEDURE       = @str_proc,
		         @ERROR_POST_MESSAGE    = NULL,
		         @RECIPIENTS            = 'DBA;';
		
		     declare @err int=@@error;
		     raiserror(@str_mess,16,1);
		end catch
		11) ИНФОРМИРОВАНИЕ – запускается каждые 30 минут:
		USE [SRV];
		go
		
		EXECUTE [srv].[RunErrorInfoProc] 
		   @IsRealTime=0;
		12) ИНФОРМИРОВАНИЕ РЕАЛЬНОГО ВРЕМЕНИ – запускается каждые 60 секунд:
		USE [SRV];
		go
		
		EXECUTE [srv].[RunErrorInfoProc] 
		   @IsRealTime=1;
		13) Обслуживание до и после полного резервного копирования – запускается ежедневно, состоит из следующих этапов:
		13.1) Автоочистка кеша с последующим обновлением статистики по всем несистемным БД:
		USE [SRV];
		go
		
		begin try
				EXEC [srv].[AutoUpdateStatisticsCache] 
				@DB_Name=NULL
				,@IsUpdateStatistics=1;
		end try
		begin catch
		    declare @str_mess nvarchar(max)=ERROR_MESSAGE(),
		            @str_num  nvarchar(max)=cast(ERROR_NUMBER() as nvarchar(max)),
		            @str_line nvarchar(max)=cast(ERROR_LINE()   as nvarchar(max)),
		            @str_proc nvarchar(max)=ERROR_PROCEDURE(),
		            @str_title nvarchar(max)=N'Автоочистка кеша с последующим обновлением статистики по всем несистемным БД на сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)),
		            @str_pred_mess nvarchar(max)=N'На сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255))+N' возникла ошибка авточистки кеша с последующим обновлением статистики по всем несистемным БД';
		
		    exec [SRV].srv.ErrorInfoIncUpd
		         @ERROR_TITLE           = @str_title,
		         @ERROR_PRED_MESSAGE    = @str_pred_mess,
		         @ERROR_NUMBER          = @str_num,
		         @ERROR_MESSAGE         = @str_mess,
		         @ERROR_LINE            = @str_line,
		         @ERROR_PROCEDURE       = @str_proc,
		         @ERROR_POST_MESSAGE    = NULL,
		         @RECIPIENTS            = 'DBA;';
		
		     declare @err int=@@error;
		     raiserror(@str_mess,16,1);
		end catch
		13.2) Оптимизация индексов:
		USE [SRV];
		go
		
		begin try
			EXECUTE [srv].[AutoDefragIndexDB] @count=100000;
		end try
		begin catch
		    declare @str_mess nvarchar(max)=ERROR_MESSAGE(),
		            @str_num  nvarchar(max)=cast(ERROR_NUMBER() as nvarchar(max)),
		            @str_line nvarchar(max)=cast(ERROR_LINE()   as nvarchar(max)),
		            @str_proc nvarchar(max)=ERROR_PROCEDURE(),
		            @str_title nvarchar(max)=N'Оптимизация индексов на сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)),
		            @str_pred_mess nvarchar(max)=N'На сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255))+N' возникла ошибка оптимизации индексов';
		
		    exec [SRV].srv.ErrorInfoIncUpd
		         @ERROR_TITLE           = @str_title,
		         @ERROR_PRED_MESSAGE    = @str_pred_mess,
		         @ERROR_NUMBER          = @str_num,
		         @ERROR_MESSAGE         = @str_mess,
		         @ERROR_LINE            = @str_line,
		         @ERROR_PROCEDURE       = @str_proc,
		         @ERROR_POST_MESSAGE    = NULL,
		         @RECIPIENTS            = 'DBA;';
		
		     declare @err int=@@error;
		     raiserror(@str_mess,16,1);
		end catch
		13.3) Создание полных резервных копий:
		USE [SRV];
		go
		
		begin try
		                exec [srv].[RunFullBackupDB];
		end try
		begin catch
		    declare @str_mess nvarchar(max)=ERROR_MESSAGE(),
		            @str_num  nvarchar(max)=cast(ERROR_NUMBER() as nvarchar(max)),
		            @str_line nvarchar(max)=cast(ERROR_LINE()   as nvarchar(max)),
		            @str_proc nvarchar(max)=ERROR_PROCEDURE(),
		            @str_title nvarchar(max)=N'Создание полных резервных копий на сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)),
		            @str_pred_mess nvarchar(max)=N'На сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255))+N' возникла ошибка создания полных резервных копий';
		
		    exec [SRV].srv.ErrorInfoIncUpd
		         @ERROR_TITLE           = @str_title,
		         @ERROR_PRED_MESSAGE    = @str_pred_mess,
		         @ERROR_NUMBER          = @str_num,
		         @ERROR_MESSAGE         = @str_mess,
		         @ERROR_LINE            = @str_line,
		         @ERROR_PROCEDURE       = @str_proc,
		         @ERROR_POST_MESSAGE    = NULL,
		         @RECIPIENTS            = 'DBA;';
		
		     declare @err int=@@error;
		     raiserror(@str_mess,16,1);
		end catch
		13.4) Удаление старых файлов:
		USE [SRV];
		go
		
		begin try
			EXECUTE [srv].[XPDeleteFile] 
					@FolderPath=N'D:\Backup\LOG'
					,@FileExtension=N'*'
					,@OldDays=3
					,@SubFolder=1;
			EXECUTE [srv].[XPDeleteFile] 
					@FolderPath=N'D:\Backup\Diff'
					,@FileExtension=N'*'
					,@OldDays=3
					,@SubFolder=1;
			EXECUTE [srv].[XPDeleteFile] 
					@FolderPath=N'D:\Backup\FULL'
					,@FileExtension=N'*'
					,@OldDays=10
					,@SubFolder=1;
		end try
		begin catch
		    declare @str_mess nvarchar(max)=ERROR_MESSAGE(),
		            @str_num  nvarchar(max)=cast(ERROR_NUMBER() as nvarchar(max)),
		            @str_line nvarchar(max)=cast(ERROR_LINE()   as nvarchar(max)),
		            @str_proc nvarchar(max)=ERROR_PROCEDURE(),
		            @str_title nvarchar(max)=N'Удаление старых файлов на сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)),
		            @str_pred_mess nvarchar(max)=N'На сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255))+N' возникла ошибка удаления старых файлов';
		
		    exec [SRV].srv.ErrorInfoIncUpd
		         @ERROR_TITLE           = @str_title,
		         @ERROR_PRED_MESSAGE    = @str_pred_mess,
		         @ERROR_NUMBER          = @str_num,
		         @ERROR_MESSAGE         = @str_mess,
		         @ERROR_LINE            = @str_line,
		         @ERROR_PROCEDURE       = @str_proc,
		         @ERROR_POST_MESSAGE    = NULL,
		         @RECIPIENTS            = 'DBA;';
		
		     declare @err int=@@error;
		     raiserror(@str_mess,16,1);
		end catch
		14) Сбор данных о запросах – запускается ежедневно:
		USE [SRV];
		go
		
		begin try
		    exec [srv].[AutoStatisticsQuerys];
		end try
		begin catch
		    declare @str_mess nvarchar(max)=ERROR_MESSAGE(),
		            @str_num  nvarchar(max)=cast(ERROR_NUMBER() as nvarchar(max)),
		            @str_line nvarchar(max)=cast(ERROR_LINE()   as nvarchar(max)),
		            @str_proc nvarchar(max)=ERROR_PROCEDURE(),
		            @str_title nvarchar(max)=N'Сбор данных о запросах на сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)),
		            @str_pred_mess nvarchar(max)=N'На сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255))+N' возникла ошибка сбора данных о запросах';
		
		    exec [SRV].srv.ErrorInfoIncUpd
		         @ERROR_TITLE           = @str_title,
		         @ERROR_PRED_MESSAGE    = @str_pred_mess,
		         @ERROR_NUMBER          = @str_num,
		         @ERROR_MESSAGE         = @str_mess,
		         @ERROR_LINE            = @str_line,
		         @ERROR_PROCEDURE       = @str_proc,
		         @ERROR_POST_MESSAGE    = NULL,
		         @RECIPIENTS            = 'DBA;';
		
		     declare @err int=@@error;
		     raiserror(@str_mess,16,1);
		end catch
		15) Сбор данных об активных запросах – запускается каждые 10 секунд (а также по событию Новый запрос в Предупреждениях Агента) (необходимо обеспечить наивысшую скорость отработки, несмотря на то, что скан и сбор идут методом грязного чтения):
		USE [SRV];
		go
		
		begin try
		                exec [srv].[AutoStatisticsActiveRequests];
		end try
		begin catch
		    declare @str_mess nvarchar(max)=ERROR_MESSAGE(),
		            @str_num  nvarchar(max)=cast(ERROR_NUMBER() as nvarchar(max)),
		            @str_line nvarchar(max)=cast(ERROR_LINE()   as nvarchar(max)),
		            @str_proc nvarchar(max)=ERROR_PROCEDURE(),
		            @str_title nvarchar(max)=N'Сбор данных об активных запросах на сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)),
		            @str_pred_mess nvarchar(max)=N'На сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255))+N' возникла ошибка сбора данных об активных запросах';
		
		    exec [SRV].srv.ErrorInfoIncUpd
		         @ERROR_TITLE           = @str_title,
		         @ERROR_PRED_MESSAGE    = @str_pred_mess,
		         @ERROR_NUMBER          = @str_num,
		         @ERROR_MESSAGE         = @str_mess,
		         @ERROR_LINE            = @str_line,
		         @ERROR_PROCEDURE       = @str_proc,
		         @ERROR_POST_MESSAGE    = NULL,
		         @RECIPIENTS            = 'DBA;';
		
		     declare @err int=@@error;
		     raiserror(@str_mess,16,1);
		end catch
		16) Создание разностных резервных копий – по необходимости:
		USE [SRV];
		go
		
		begin try
		                exec [srv].[RunDiffBackupDB];
		end try
		begin catch
		    declare @str_mess nvarchar(max)=ERROR_MESSAGE(),
		            @str_num  nvarchar(max)=cast(ERROR_NUMBER() as nvarchar(max)),
		            @str_line nvarchar(max)=cast(ERROR_LINE()   as nvarchar(max)),
		            @str_proc nvarchar(max)=ERROR_PROCEDURE(),
		            @str_title nvarchar(max)=N'Создание разностных резервных копий на сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)),
		            @str_pred_mess nvarchar(max)=N'На сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255))+N' возникла ошибка создания разностных резервных копий';
		
		    exec [SRV].srv.ErrorInfoIncUpd
		         @ERROR_TITLE           = @str_title,
		         @ERROR_PRED_MESSAGE    = @str_pred_mess,
		         @ERROR_NUMBER          = @str_num,
		         @ERROR_MESSAGE         = @str_mess,
		         @ERROR_LINE            = @str_line,
		         @ERROR_PROCEDURE       = @str_proc,
		         @ERROR_POST_MESSAGE    = NULL,
		         @RECIPIENTS            = 'DBA;';
		
		     declare @err int=@@error;
		     raiserror(@str_mess,16,1);
		end catch
		17) Восстановление БД из их полных резервных копий:
		USE [SRV];
		go
		
		begin try
		                exec [srv].[RunFullRestoreDB];
		end try
		begin catch
		    declare @str_mess nvarchar(max)=ERROR_MESSAGE(),
		            @str_num  nvarchar(max)=cast(ERROR_NUMBER() as nvarchar(max)),
		            @str_line nvarchar(max)=cast(ERROR_LINE()   as nvarchar(max)),
		            @str_proc nvarchar(max)=ERROR_PROCEDURE(),
		            @str_title nvarchar(max)=N'Восстановление БД из их полных резервных копий на сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)),
		            @str_pred_mess nvarchar(max)=N'На сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255))+N' возникла ошибка восстановления БД из их полных резервных копий';
		
		    exec [SRV].srv.ErrorInfoIncUpd
		         @ERROR_TITLE           = @str_title,
		         @ERROR_PRED_MESSAGE    = @str_pred_mess,
		         @ERROR_NUMBER          = @str_num,
		         @ERROR_MESSAGE         = @str_mess,
		         @ERROR_LINE            = @str_line,
		         @ERROR_PROCEDURE       = @str_proc,
		         @ERROR_POST_MESSAGE    = NULL,
		         @RECIPIENTS            = 'DBA;';
		
		     declare @err int=@@error;
		     raiserror(@str_mess,16,1);
		end catch
		18) Автоудаление забытых транзакций:
		USE [SRV];
		go
		
		begin try
		                exec  [srv].[AutoKillSessionTranBegin];
		end try
		begin catch
		    declare @str_mess nvarchar(max)=ERROR_MESSAGE(),
		            @str_num  nvarchar(max)=cast(ERROR_NUMBER() as nvarchar(max)),
		            @str_line nvarchar(max)=cast(ERROR_LINE()   as nvarchar(max)),
		            @str_proc nvarchar(max)=ERROR_PROCEDURE(),
		            @str_title nvarchar(max)=N'Автоудаление забытых транзакций на сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)),
		            @str_pred_mess nvarchar(max)=N'На сервере '+cast(SERVERPROPERTY(N'MachineName') as nvarchar(255))+N' возникла ошибка автоудаления забытых транзакций';
		
		    exec [SRV].srv.ErrorInfoIncUpd
		         @ERROR_TITLE           = @str_title,
		         @ERROR_PRED_MESSAGE    = @str_pred_mess,
		         @ERROR_NUMBER          = @str_num,
		         @ERROR_MESSAGE         = @str_mess,
		         @ERROR_LINE            = @str_line,
		         @ERROR_PROCEDURE       = @str_proc,
		         @ERROR_POST_MESSAGE    = NULL,
		         @RECIPIENTS            = 'DBA;';
		
		     declare @err int=@@error;
		     raiserror(@str_mess,16,1);
		end catch

	*/
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create view [inf].[vIndFileGroup]
--
GO
CREATE VIEW [inf].[vIndFileGroup] AS
SELECT
	obj.[NAME] AS [parent_name]
   ,obj.[type] AS [parent_type]
   ,obj.[type_desc] AS [paretn_type_desc]
   ,SCHEMA_NAME(obj.[schema_id]) AS [schema_name]
   ,ind.[NAME] AS [index_name]
   ,ind.[index_id] AS [index_id]
   ,ind.[object_id] AS [parent_object_id]
   ,ind.[type_desc] AS [index_type_desc]
   ,f.[NAME] AS [filegroup_name]
   ,f.[data_space_id]
   ,f.[type] AS [filegroup_type]
   ,f.[type_desc] AS [filegroup_type_desc]
   ,f.[filegroup_guid]
   ,f.[is_read_only]
   ,f.[is_system]
   ,f.[is_default]
FROM sys.indexes AS ind
INNER JOIN sys.filegroups AS f
	ON ind.[data_space_id] = f.[data_space_id]
INNER JOIN sys.all_objects AS obj
	ON ind.[object_id] = obj.[object_id]
WHERE ind.[data_space_id] = f.[data_space_id]
--AND obj.[type] = 'U' -- User Created Tables
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [zabbix].[GetValRAMTypeWait]
--
GO


-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER PROCEDURE [zabbix].[GetValRAMTypeWait]
AS
BEGIN
	/*
		Сколько в миллисекундах занимают типы ожиданий по ОЗУ (максимальное значение из всех средних задержках по всем таким типам ожиданий)
	*/

	--SET QUERY_GOVERNOR_COST_LIMIT 0;
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	SELECT --sum([Percentage]) as [Percentage]
		   coalesce(max([AvgWait_S])*1000, 0.00)  as [AvgWait_S]
	FROM [inf].[vWaits]
	where [WaitType] in (
    --'PAGEIOLATCH_XX',
    'RESOURCE_SEMAPHORE',
    'RESOURCE_SEMAPHORE_QUERY_COMPILE'
    )
	or [WaitType] like 'PAGEIOLATCH%';
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [zabbix].[GetPercRAMTypeWait]
--
GO


-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER PROCEDURE [zabbix].[GetPercRAMTypeWait]
AS
BEGIN
	/*
		Сколько в процентах занимают типы ожиданий по ОЗУ (сумма по всем таким типам ожиданий)
	*/

	--SET QUERY_GOVERNOR_COST_LIMIT 0;
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	SELECT coalesce(sum([Percentage]), 0.00) as [Percentage]
		  --,max([AvgWait_S])  as [AvgWait_S]
	FROM [inf].[vWaits]
	where [WaitType] in (
    --'PAGEIOLATCH_XX',
    'RESOURCE_SEMAPHORE',
    'RESOURCE_SEMAPHORE_QUERY_COMPILE'
    )
	or [WaitType] like 'PAGEIOLATCH%';
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter view [inf].[vViews]
--
GO

ALTER view [inf].[vViews] as
--представления
select cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)) AS [Server],
       DB_NAME() AS DBName,
	   s.name as SchemaName,
	   t.name as TableName,
	   t.type as Type,
	   t.type_desc as TypeDesc,
	   t.create_date as CreateDate,
	   t.modify_date as ModifyDate
from sys.views as t
inner join sys.schemas as s on t.schema_id=s.schema_id
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter view [inf].[vTableSize]
--
GO
ALTER view [inf].[vTableSize] as
	with pagesizeKB as (
		SELECT low / 1024 as PageSizeKB
		FROM master.dbo.spt_values
		WHERE number = 1 AND type = 'E'
	)
	,f_size as (
		select p.[object_id], 
			   sum([total_pages]) as TotalPageSize,
			   sum([used_pages])  as UsedPageSize,
			   sum([data_pages])  as DataPageSize
		from sys.partitions p join sys.allocation_units a on p.partition_id = a.container_id
		left join sys.internal_tables it on p.object_id = it.object_id
		WHERE OBJECTPROPERTY(p.[object_id], N'IsUserTable') = 1
		group by p.[object_id]
	)
	,tbl as (
		SELECT
		  t.[schema_id],
		  t.[object_id],
		  i1.rowcnt as CountRows,
		  (COALESCE(SUM(i1.reserved), 0) + COALESCE(SUM(i2.reserved), 0)) * (select top(1) PageSizeKB from pagesizeKB) as ReservedKB,
		  (COALESCE(SUM(i1.dpages), 0) + COALESCE(SUM(i2.used), 0)) * (select top(1) PageSizeKB from pagesizeKB) as DataKB,
		  ((COALESCE(SUM(i1.used), 0) + COALESCE(SUM(i2.used), 0))
		    - (COALESCE(SUM(i1.dpages), 0) + COALESCE(SUM(i2.used), 0))) * (select top(1) PageSizeKB from pagesizeKB) as IndexSizeKB,
		  ((COALESCE(SUM(i1.reserved), 0) + COALESCE(SUM(i2.reserved), 0))
		    - (COALESCE(SUM(i1.used), 0) + COALESCE(SUM(i2.used), 0))) * (select top(1) PageSizeKB from pagesizeKB) as UnusedKB
		FROM sys.tables as t
		LEFT OUTER JOIN sysindexes as i1 ON i1.id = t.[object_id] AND i1.indid < 2
		LEFT OUTER JOIN sysindexes as i2 ON i2.id = t.[object_id] AND i2.indid = 255
		WHERE OBJECTPROPERTY(t.[object_id], N'IsUserTable') = 1
		OR (OBJECTPROPERTY(t.[object_id], N'IsView') = 1 AND OBJECTPROPERTY(t.[object_id], N'IsIndexed') = 1)
		GROUP BY t.[schema_id], t.[object_id], i1.rowcnt
	)
	SELECT
	  cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)) AS [Server],
	  DB_NAME() AS DBName,
	  SCHEMA_NAME(t.[schema_id]) as SchemaName,
	  OBJECT_NAME(t.[object_id]) as TableName,
	  t.CountRows,
	  t.ReservedKB,
	  t.DataKB,
	  t.IndexSizeKB,
	  t.UnusedKB,
	  f.TotalPageSize*(select top(1) PageSizeKB from pagesizeKB) as TotalPageSizeKB,
	  f.UsedPageSize*(select top(1) PageSizeKB from pagesizeKB) as UsedPageSizeKB,
	  f.DataPageSize*(select top(1) PageSizeKB from pagesizeKB) as DataPageSizeKB
	FROM f_size as f
	inner join tbl as t on t.[object_id]=f.[object_id]


GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Refresh view [inf].[vDataSize]
--
EXEC sp_refreshview '[inf].[vDataSize]'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter view [inf].[vTables]
--
GO

ALTER view [inf].[vTables] as
--таблицы
select cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)) AS [Server],
       DB_NAME() AS DBName,
	   s.name as SchemaName,
	   t.name as TableName,
	   t.type as Type,
	   t.type_desc as TypeDesc,
	   t.create_date as CreateDate,
	   t.modify_date as ModifyDate
from sys.tables as t
inner join sys.schemas as s on t.schema_id=s.schema_id
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter view [inf].[vSynonyms]
--
GO

ALTER view [inf].[vSynonyms] as
-- дополнительная информация о синонимах

SELECT  cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)) AS ServerName ,
        DB_NAME() AS DBName ,
		sch.name as SchemaName,
        s.name AS [Synonyms] ,
        s.create_date as CreateDate,
        s.base_object_name as BaseObjectName
FROM    sys.synonyms s
inner join sys.schemas as sch on sch.schema_id=s.schema_id
--ORDER BY s.name;


GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter view [inf].[vServerRunTime]
--
GO

ALTER view [inf].[vServerRunTime] as
--время работы сервера
SELECT  cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)) AS ServerName ,
        create_date AS  ServerStarted ,
        DATEDIFF(s, create_date, GETDATE()) / 86400.0 AS DaysRunning ,
        DATEDIFF(s, create_date, GETDATE()) AS SecondsRunnig
FROM    sys.databases
WHERE   name = 'tempdb'; 


GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter view [inf].[vServerOnlineDB]
--
GO

ALTER view [inf].[vServerOnlineDB] as
-- какие БД сейчас используются
SELECT  cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)) AS [Server] ,
        DB_NAME(database_id) AS DatabaseName ,
        COUNT(database_id) AS Connections ,
        Login_name AS  LoginName ,
        MIN(Login_Time) AS Login_Time ,
        MIN(COALESCE(last_request_end_time, last_request_start_time))
                                                         AS  Last_Batch
FROM    sys.dm_exec_sessions
WHERE   database_id > 0
        --AND DB_NAME(database_id) NOT IN ( 'master', 'msdb' )
GROUP BY database_id ,
         login_name
--ORDER BY DatabaseName;
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [zabbix].[GetOldBackupsCount]
--
GO




-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER   PROCEDURE [zabbix].[GetOldBackupsCount]
	@hours_full int=25 -- старость в часах для полной резервной копии
	,@hours_log int=1 -- старость в часах для резервной копии журнала транзакций
AS
BEGIN
	/*
		Количество тех БД, для которых давно не делались резервные копии
	*/

	--SET QUERY_GOVERNOR_COST_LIMIT 0;
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	SET XACT_ABORT ON;

	declare @server_name nvarchar(255)=cast(SERVERPROPERTY(N'ComputerNamePhysicalNetBIOS') as nvarchar(255));

	if((left(@server_name,3) in (N'PRD')) or (@server_name like 'SQL_SERVICES%') or (@server_name in ('com-dba-01')))
	begin
		select sum([count]) as [count]
		from(
			select count(*) as [count]
			from sys.databases as db
			left outer join [inf].[vServerLastBackupDB] as bak on db.[name]=bak.[DBName] and bak.[BackupType]=N'database'
			where db.[name] not in (N'tempdb', N'NewVeeamBackupDB')
			and (bak.BackupStartDate<DateAdd(hour,-@hours_full,GetDate()) or bak.BackupStartDate is null)
			and db.[create_date]<DateAdd(hour,-@hours_full,GetDate())
			union all
			select count(*) as [count]
			from sys.databases as db
			left outer join [inf].[vServerLastBackupDB] as bak on db.[name]=bak.[DBName] and bak.[BackupType]=N'log'
			where db.[name] not in (N'tempdb', N'NewVeeamBackupDB', N'NewVeeamBackupReporting', N'SRV', N'VeeamOne', N'FortisAdmin', N'SpotlightPlaybackDatabase', N'SpotlightStatisticsRepository')
			and db.[database_id]>4
			and (bak.BackupStartDate<DateAdd(hour,-@hours_log,GetDate()) or bak.BackupStartDate is null)
			and db.[create_date]<DateAdd(hour,-@hours_full,GetDate())
		) as t;
	end
	else select 0 as [count];
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter view [inf].[vServerFilesDB]
--
GO


ALTER view [inf].[vServerFilesDB] as
--основная информация о файлах БД
SELECT  cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)) AS [Server] ,
        d.name AS DBName ,
        create_date ,
        compatibility_level ,
        m.physical_name AS FileName,
		d.create_date as CreateDate
FROM    sys.databases d
        JOIN sys.master_files m ON d.database_id = m.database_id
WHERE   m.[type] = 0 -- data files only
--ORDER BY d.name;

GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [zabbix].[GetRunnableTasksCount]
--
GO


-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER PROCEDURE [zabbix].[GetRunnableTasksCount]
AS
BEGIN
	/*
		Максимальное количество ожидающих задач среди свободных ядер
	*/

	--SET QUERY_GOVERNOR_COST_LIMIT 0;
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	SELECT max([runnable_tasks_count]) as [runnable_tasks_count]
	from [inf].[vSchedulersOS];
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter view [inf].[vRequests]
--
GO

ALTER view [inf].[vRequests] as
/*
	ГЕМ: Сведения о запросах
*/
select ES.[session_id]
	      ,ER.[blocking_session_id]
		  ,ER.[request_id]
	      ,ER.[start_time]
		  ,DateDiff(second, ER.[start_time], GetDate()) as [date_diffSec] --Сколько в сек прошло времени от момента поступления запроса
		  , COALESCE(
						CAST(NULLIF(ER.[total_elapsed_time] / 1000, 0) as BIGINT)
					   ,CASE WHEN (ES.[status] <> 'running' and isnull(ER.[status], '')  <> 'running') 
								THEN  DATEDIFF(ss,0,getdate() - nullif(ES.[last_request_end_time], '1900-01-01T00:00:00.000'))
						END
					) as [total_time, sec] --Время всей работы запроса в сек
		  , CAST(NULLIF((CAST(ER.[total_elapsed_time] as BIGINT) - CAST(ER.[wait_time] AS BIGINT)) / 1000, 0 ) as bigint) as [work_time, sec] --Время работы запроса в сек без учета времени ожиданий
		  , CASE WHEN (ER.[status] <> 'running' AND ISNULL(ER.[status],'') <> 'running') 
		  			THEN  DATEDIFF(ss,0,getdate() - nullif(ES.[last_request_end_time], '1900-01-01T00:00:00.000'))
			END as [sleep_time, sec] --Время сна в сек
		  , NULLIF( CAST((ER.[logical_reads] + ER.[writes]) * 8 / 1024 as numeric(38,2)), 0) as [IO, MB] --операций чтения и записи в МБ
		  , CASE  ER.transaction_isolation_level
			WHEN 0 THEN 'Unspecified'
			WHEN 1 THEN 'ReadUncommited'
			WHEN 2 THEN 'ReadCommited'
			WHEN 3 THEN 'Repetable'
			WHEN 4 THEN 'Serializable'
			WHEN 5 THEN 'Snapshot'
			END as [transaction_isolation_level_desc] --уровень изоляции транзакции (расшифровка)
	      ,ER.[status]
		  ,ES.[status] as [status_session]
	      ,ER.[command]
		  ,ER.[percent_complete]
		  ,DB_Name(coalesce(ER.[database_id], ES.[database_id])) as [DBName]
		  , SUBSTRING(
						(select top(1) [text] from sys.dm_exec_sql_text(ER.[sql_handle]))
					  , ER.[statement_start_offset]/2+1
					  ,	(
							CASE WHEN ((ER.[statement_start_offset]<0) OR (ER.[statement_end_offset]<0))
									THEN DATALENGTH ((select top(1) [text] from sys.dm_exec_sql_text(ER.[sql_handle])))
								 ELSE ER.[statement_end_offset]
							END
							- ER.[statement_start_offset]
						)/2 +1
					 ) as [CURRENT_REQUEST] --Текущий выполняемый запрос в пакете
	      ,(select top(1) [text] from sys.dm_exec_sql_text(ER.[sql_handle])) as [TSQL]
		  ,(select top(1) [objectid] from sys.dm_exec_sql_text(ER.[sql_handle])) as [objectid]
		  ,(select top(1) [query_plan] from sys.dm_exec_query_plan(ER.[plan_handle])) as [QueryPlan]
		  ,NULL as [event_info]--(select top(1) [event_info] from sys.dm_exec_input_buffer(ES.[session_id], ER.[request_id])) as [event_info]
	      ,ER.[wait_type]
	      ,ES.[login_time]
		  ,ES.[host_name]
		  ,ES.[program_name]
		  ,cast(ER.[wait_time]/1000 as decimal(18,3)) as [wait_timeSec] --Если запрос в настоящий момент блокирован, в столбце содержится продолжительность текущего ожидания (в секундах)
	      ,ER.[wait_time]
	      ,ER.[last_wait_type]
	      ,ER.[wait_resource]
	      ,ER.[open_transaction_count]
	      ,ER.[open_resultset_count]
	      ,ER.[transaction_id]
	      ,ER.[context_info]
	      ,ER.[estimated_completion_time]
	      ,ER.[cpu_time]
	      ,ER.[total_elapsed_time]
	      ,ER.[scheduler_id]
	      ,ER.[task_address]
	      ,ER.[reads]
	      ,ER.[writes]
	      ,ER.[logical_reads]
	      ,ER.[text_size]
	      ,ER.[language]
	      ,ER.[date_format]
	      ,ER.[date_first]
	      ,ER.[quoted_identifier]
	      ,ER.[arithabort]
	      ,ER.[ansi_null_dflt_on]
	      ,ER.[ansi_defaults]
	      ,ER.[ansi_warnings]
	      ,ER.[ansi_padding]
	      ,ER.[ansi_nulls]
	      ,ER.[concat_null_yields_null]
	      ,ER.[transaction_isolation_level]
	      ,ER.[lock_timeout]
	      ,ER.[deadlock_priority]
	      ,ER.[row_count]
	      ,ER.[prev_error]
	      ,ER.[nest_level]
	      ,ER.[granted_query_memory]
	      ,ER.[executing_managed_code]
	      ,ER.[group_id]
	      ,ER.[query_hash]
	      ,ER.[query_plan_hash]
		  ,EC.[most_recent_session_id]
	      ,EC.[connect_time]
	      ,EC.[net_transport]
	      ,EC.[protocol_type]
	      ,EC.[protocol_version]
	      ,EC.[endpoint_id]
	      ,EC.[encrypt_option]
	      ,EC.[auth_scheme]
	      ,EC.[node_affinity]
	      ,EC.[num_reads]
	      ,EC.[num_writes]
	      ,EC.[last_read]
	      ,EC.[last_write]
	      ,EC.[net_packet_size]
	      ,EC.[client_net_address]
	      ,EC.[client_tcp_port]
	      ,EC.[local_net_address]
	      ,EC.[local_tcp_port]
	      ,EC.[parent_connection_id]
	      ,EC.[most_recent_sql_handle]
		  ,ES.[host_process_id]
		  ,ES.[client_version]
		  ,ES.[client_interface_name]
		  ,ES.[security_id]
		  ,ES.[login_name]
		  ,ES.[nt_domain]
		  ,ES.[nt_user_name]
		  ,ES.[memory_usage]
		  ,ES.[total_scheduled_time]
		  ,ES.[last_request_start_time]
		  ,ES.[last_request_end_time]
		  ,ES.[is_user_process]
		  ,ES.[original_security_id]
		  ,ES.[original_login_name]
		  ,ES.[last_successful_logon]
		  ,ES.[last_unsuccessful_logon]
		  ,ES.[unsuccessful_logons]
		  ,ES.[authenticating_database_id]
		  ,ER.[sql_handle]
	      ,ER.[statement_start_offset]
	      ,ER.[statement_end_offset]
	      ,ER.[plan_handle]
		  ,NULL as [dop]--ER.[dop]
	      ,coalesce(ER.[database_id], ES.[database_id]) as [database_id]
	      ,ER.[user_id]
	      ,ER.[connection_id]
	from sys.dm_exec_requests ER with(readuncommitted)
	right join sys.dm_exec_sessions ES with(readuncommitted)
	on ES.session_id = ER.session_id 
	left join sys.dm_exec_connections EC  with(readuncommitted)
	on EC.session_id = ES.session_id
	where ER.[status] in ('suspended', 'running', 'runnable')
	or exists (select top(1) 1 from sys.dm_exec_requests as ER0 where ER0.[blocking_session_id]=ES.[session_id])






GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter view [inf].[vRequestDetail]
--
GO





ALTER view [inf].[vRequestDetail] as
/*Активные, готовые к выполнению и ожидающие запросы, а также те, что явно блокируют другие сеансы*/
with tbl0 as (
	select ES.[session_id]
	      ,ER.[blocking_session_id]
		  ,ER.[request_id]
	      ,ER.[start_time]
	      ,ER.[status]
		  ,ES.[status] as [status_session]
	      ,ER.[command]
		  ,ER.[percent_complete]
		  ,DB_Name(coalesce(ER.[database_id], ES.[database_id])) as [DBName]
	      ,(select top(1) [text] from sys.dm_exec_sql_text(ER.[sql_handle])) as [TSQL]
		  ,(select top(1) [objectid] from sys.dm_exec_sql_text(ER.[sql_handle])) as [objectid]
		  ,(select top(1) [query_plan] from sys.dm_exec_query_plan(ER.[plan_handle])) as [QueryPlan]
		  ,NULL as [event_info]--(select top(1) [event_info] from sys.dm_exec_input_buffer(ES.[session_id], ER.[request_id])) as [event_info]
	      ,ER.[wait_type]
	      ,ES.[login_time]
		  ,ES.[host_name]
		  ,ES.[program_name]
	      ,ER.[wait_time]
	      ,ER.[last_wait_type]
	      ,ER.[wait_resource]
	      ,ER.[open_transaction_count]
	      ,ER.[open_resultset_count]
	      ,ER.[transaction_id]
	      ,ER.[context_info]
	      ,ER.[estimated_completion_time]
	      ,ER.[cpu_time]
	      ,ER.[total_elapsed_time]
	      ,ER.[scheduler_id]
	      ,ER.[task_address]
	      ,ER.[reads]
	      ,ER.[writes]
	      ,ER.[logical_reads]
	      ,ER.[text_size]
	      ,ER.[language]
	      ,ER.[date_format]
	      ,ER.[date_first]
	      ,ER.[quoted_identifier]
	      ,ER.[arithabort]
	      ,ER.[ansi_null_dflt_on]
	      ,ER.[ansi_defaults]
	      ,ER.[ansi_warnings]
	      ,ER.[ansi_padding]
	      ,ER.[ansi_nulls]
	      ,ER.[concat_null_yields_null]
	      ,ER.[transaction_isolation_level]
	      ,ER.[lock_timeout]
	      ,ER.[deadlock_priority]
	      ,ER.[row_count]
	      ,ER.[prev_error]
	      ,ER.[nest_level]
	      ,ER.[granted_query_memory]
	      ,ER.[executing_managed_code]
	      ,ER.[group_id]
	      ,ER.[query_hash]
	      ,ER.[query_plan_hash]
		  ,EC.[most_recent_session_id]
	      ,EC.[connect_time]
	      ,EC.[net_transport]
	      ,EC.[protocol_type]
	      ,EC.[protocol_version]
	      ,EC.[endpoint_id]
	      ,EC.[encrypt_option]
	      ,EC.[auth_scheme]
	      ,EC.[node_affinity]
	      ,EC.[num_reads]
	      ,EC.[num_writes]
	      ,EC.[last_read]
	      ,EC.[last_write]
	      ,EC.[net_packet_size]
	      ,EC.[client_net_address]
	      ,EC.[client_tcp_port]
	      ,EC.[local_net_address]
	      ,EC.[local_tcp_port]
	      ,EC.[parent_connection_id]
	      ,EC.[most_recent_sql_handle]
		  ,ES.[host_process_id]
		  ,ES.[client_version]
		  ,ES.[client_interface_name]
		  ,ES.[security_id]
		  ,ES.[login_name]
		  ,ES.[nt_domain]
		  ,ES.[nt_user_name]
		  ,ES.[memory_usage]
		  ,ES.[total_scheduled_time]
		  ,ES.[last_request_start_time]
		  ,ES.[last_request_end_time]
		  ,ES.[is_user_process]
		  ,ES.[original_security_id]
		  ,ES.[original_login_name]
		  ,ES.[last_successful_logon]
		  ,ES.[last_unsuccessful_logon]
		  ,ES.[unsuccessful_logons]
		  ,ES.[authenticating_database_id]
		  ,ER.[sql_handle]
	      ,ER.[statement_start_offset]
	      ,ER.[statement_end_offset]
	      ,ER.[plan_handle]
		  ,NULL as [dop]--ER.[dop]
	      ,coalesce(ER.[database_id], ES.[database_id]) as [database_id]
	      ,ER.[user_id]
	      ,ER.[connection_id]
	from sys.dm_exec_requests ER with(readuncommitted)
	right join sys.dm_exec_sessions ES with(readuncommitted)
	on ES.session_id = ER.session_id 
	left join sys.dm_exec_connections EC  with(readuncommitted)
	on EC.session_id = ES.session_id
)
, tbl as (
	select [session_id]
	      ,[blocking_session_id]
		  ,[request_id]
	      ,[start_time]
	      ,[status]
		  ,[status_session]
	      ,[command]
		  ,[percent_complete]
		  ,[DBName]
		  ,OBJECT_name([objectid], [database_id]) as [object]
	      ,[TSQL]
		  ,[QueryPlan]
		  ,[event_info]
	      ,[wait_type]
	      ,[login_time]
		  ,[host_name]
		  ,[program_name]
	      ,[wait_time]
	      ,[last_wait_type]
	      ,[wait_resource]
	      ,[open_transaction_count]
	      ,[open_resultset_count]
	      ,[transaction_id]
	      ,[context_info]
	      ,[estimated_completion_time]
	      ,[cpu_time]
	      ,[total_elapsed_time]
	      ,[scheduler_id]
	      ,[task_address]
	      ,[reads]
	      ,[writes]
	      ,[logical_reads]
	      ,[text_size]
	      ,[language]
	      ,[date_format]
	      ,[date_first]
	      ,[quoted_identifier]
	      ,[arithabort]
	      ,[ansi_null_dflt_on]
	      ,[ansi_defaults]
	      ,[ansi_warnings]
	      ,[ansi_padding]
	      ,[ansi_nulls]
	      ,[concat_null_yields_null]
	      ,[transaction_isolation_level]
	      ,[lock_timeout]
	      ,[deadlock_priority]
	      ,[row_count]
	      ,[prev_error]
	      ,[nest_level]
	      ,[granted_query_memory]
	      ,[executing_managed_code]
	      ,[group_id]
	      ,[query_hash]
	      ,[query_plan_hash]
		  ,[most_recent_session_id]
	      ,[connect_time]
	      ,[net_transport]
	      ,[protocol_type]
	      ,[protocol_version]
	      ,[endpoint_id]
	      ,[encrypt_option]
	      ,[auth_scheme]
	      ,[node_affinity]
	      ,[num_reads]
	      ,[num_writes]
	      ,[last_read]
	      ,[last_write]
	      ,[net_packet_size]
	      ,[client_net_address]
	      ,[client_tcp_port]
	      ,[local_net_address]
	      ,[local_tcp_port]
	      ,[parent_connection_id]
	      ,[most_recent_sql_handle]
		  ,[host_process_id]
		  ,[client_version]
		  ,[client_interface_name]
		  ,[security_id]
		  ,[login_name]
		  ,[nt_domain]
		  ,[nt_user_name]
		  ,[memory_usage]
		  ,[total_scheduled_time]
		  ,[last_request_start_time]
		  ,[last_request_end_time]
		  ,[is_user_process]
		  ,[original_security_id]
		  ,[original_login_name]
		  ,[last_successful_logon]
		  ,[last_unsuccessful_logon]
		  ,[unsuccessful_logons]
		  ,[authenticating_database_id]
		  ,[sql_handle]
	      ,[statement_start_offset]
	      ,[statement_end_offset]
	      ,[plan_handle]
		  ,[dop]
	      ,[database_id]
	      ,[user_id]
	      ,[connection_id]
	from tbl0
	where [status] in ('suspended', 'running', 'runnable')
)
, tbl_group as (
	select [blocking_session_id]
	from tbl
	where [blocking_session_id]<>0
	group by [blocking_session_id]
)
, tbl_res_rec as (
	select [session_id]
	      ,[blocking_session_id]
		  ,[request_id]
	      ,[start_time]
	      ,[status]
		  ,[status_session]
	      ,[command]
		  ,[percent_complete]
		  ,[DBName]
		  ,[object]
	      ,[TSQL]
		  ,[QueryPlan]
		  ,[event_info]
	      ,[wait_type]
	      ,[login_time]
		  ,[host_name]
		  ,[program_name]
	      ,[wait_time]
	      ,[last_wait_type]
	      ,[wait_resource]
	      ,[open_transaction_count]
	      ,[open_resultset_count]
	      ,[transaction_id]
	      ,[context_info]
	      ,[estimated_completion_time]
	      ,[cpu_time]
	      ,[total_elapsed_time]
	      ,[scheduler_id]
	      ,[task_address]
	      ,[reads]
	      ,[writes]
	      ,[logical_reads]
	      ,[text_size]
	      ,[language]
	      ,[date_format]
	      ,[date_first]
	      ,[quoted_identifier]
	      ,[arithabort]
	      ,[ansi_null_dflt_on]
	      ,[ansi_defaults]
	      ,[ansi_warnings]
	      ,[ansi_padding]
	      ,[ansi_nulls]
	      ,[concat_null_yields_null]
	      ,[transaction_isolation_level]
	      ,[lock_timeout]
	      ,[deadlock_priority]
	      ,[row_count]
	      ,[prev_error]
	      ,[nest_level]
	      ,[granted_query_memory]
	      ,[executing_managed_code]
	      ,[group_id]
	      ,[query_hash]
	      ,[query_plan_hash]
		  ,[most_recent_session_id]
	      ,[connect_time]
	      ,[net_transport]
	      ,[protocol_type]
	      ,[protocol_version]
	      ,[endpoint_id]
	      ,[encrypt_option]
	      ,[auth_scheme]
	      ,[node_affinity]
	      ,[num_reads]
	      ,[num_writes]
	      ,[last_read]
	      ,[last_write]
	      ,[net_packet_size]
	      ,[client_net_address]
	      ,[client_tcp_port]
	      ,[local_net_address]
	      ,[local_tcp_port]
	      ,[parent_connection_id]
	      ,[most_recent_sql_handle]
		  ,[host_process_id]
		  ,[client_version]
		  ,[client_interface_name]
		  ,[security_id]
		  ,[login_name]
		  ,[nt_domain]
		  ,[nt_user_name]
		  ,[memory_usage]
		  ,[total_scheduled_time]
		  ,[last_request_start_time]
		  ,[last_request_end_time]
		  ,[is_user_process]
		  ,[original_security_id]
		  ,[original_login_name]
		  ,[last_successful_logon]
		  ,[last_unsuccessful_logon]
		  ,[unsuccessful_logons]
		  ,[authenticating_database_id]
		  ,[sql_handle]
	      ,[statement_start_offset]
	      ,[statement_end_offset]
	      ,[plan_handle]
		  ,[dop]
	      ,[database_id]
	      ,[user_id]
	      ,[connection_id]
		  , 0 as [is_blocking_other_session]
from tbl
union all
select tbl0.[session_id]
	      ,tbl0.[blocking_session_id]
		  ,tbl0.[request_id]
	      ,tbl0.[start_time]
	      ,tbl0.[status]
		  ,tbl0.[status_session]
	      ,tbl0.[command]
		  ,tbl0.[percent_complete]
		  ,tbl0.[DBName]
		  ,OBJECT_name(tbl0.[objectid], tbl0.[database_id]) as [object]
	      ,tbl0.[TSQL]
		  ,tbl0.[QueryPlan]
		  ,tbl0.[event_info]
	      ,tbl0.[wait_type]
	      ,tbl0.[login_time]
		  ,tbl0.[host_name]
		  ,tbl0.[program_name]
	      ,tbl0.[wait_time]
	      ,tbl0.[last_wait_type]
	      ,tbl0.[wait_resource]
	      ,tbl0.[open_transaction_count]
	      ,tbl0.[open_resultset_count]
	      ,tbl0.[transaction_id]
	      ,tbl0.[context_info]
	      ,tbl0.[estimated_completion_time]
	      ,tbl0.[cpu_time]
	      ,tbl0.[total_elapsed_time]
	      ,tbl0.[scheduler_id]
	      ,tbl0.[task_address]
	      ,tbl0.[reads]
	      ,tbl0.[writes]
	      ,tbl0.[logical_reads]
	      ,tbl0.[text_size]
	      ,tbl0.[language]
	      ,tbl0.[date_format]
	      ,tbl0.[date_first]
	      ,tbl0.[quoted_identifier]
	      ,tbl0.[arithabort]
	      ,tbl0.[ansi_null_dflt_on]
	      ,tbl0.[ansi_defaults]
	      ,tbl0.[ansi_warnings]
	      ,tbl0.[ansi_padding]
	      ,tbl0.[ansi_nulls]
	      ,tbl0.[concat_null_yields_null]
	      ,tbl0.[transaction_isolation_level]
	      ,tbl0.[lock_timeout]
	      ,tbl0.[deadlock_priority]
	      ,tbl0.[row_count]
	      ,tbl0.[prev_error]
	      ,tbl0.[nest_level]
	      ,tbl0.[granted_query_memory]
	      ,tbl0.[executing_managed_code]
	      ,tbl0.[group_id]
	      ,tbl0.[query_hash]
	      ,tbl0.[query_plan_hash]
		  ,tbl0.[most_recent_session_id]
	      ,tbl0.[connect_time]
	      ,tbl0.[net_transport]
	      ,tbl0.[protocol_type]
	      ,tbl0.[protocol_version]
	      ,tbl0.[endpoint_id]
	      ,tbl0.[encrypt_option]
	      ,tbl0.[auth_scheme]
	      ,tbl0.[node_affinity]
	      ,tbl0.[num_reads]
	      ,tbl0.[num_writes]
	      ,tbl0.[last_read]
	      ,tbl0.[last_write]
	      ,tbl0.[net_packet_size]
	      ,tbl0.[client_net_address]
	      ,tbl0.[client_tcp_port]
	      ,tbl0.[local_net_address]
	      ,tbl0.[local_tcp_port]
	      ,tbl0.[parent_connection_id]
	      ,tbl0.[most_recent_sql_handle]
		  ,tbl0.[host_process_id]
		  ,tbl0.[client_version]
		  ,tbl0.[client_interface_name]
		  ,tbl0.[security_id]
		  ,tbl0.[login_name]
		  ,tbl0.[nt_domain]
		  ,tbl0.[nt_user_name]
		  ,tbl0.[memory_usage]
		  ,tbl0.[total_scheduled_time]
		  ,tbl0.[last_request_start_time]
		  ,tbl0.[last_request_end_time]
		  ,tbl0.[is_user_process]
		  ,tbl0.[original_security_id]
		  ,tbl0.[original_login_name]
		  ,tbl0.[last_successful_logon]
		  ,tbl0.[last_unsuccessful_logon]
		  ,tbl0.[unsuccessful_logons]
		  ,tbl0.[authenticating_database_id]
		  ,tbl0.[sql_handle]
	      ,tbl0.[statement_start_offset]
	      ,tbl0.[statement_end_offset]
	      ,tbl0.[plan_handle]
		  ,tbl0.[dop]
	      ,tbl0.[database_id]
	      ,tbl0.[user_id]
	      ,tbl0.[connection_id]
		  , 1 as [is_blocking_other_session]
	from tbl_group as tg
	inner join tbl0 on tg.blocking_session_id=tbl0.session_id
)
,tbl_res_rec_g as (
	select [plan_handle],
		   [sql_handle],
		   cast([start_time] as date) as [start_time]
	from tbl_res_rec
	group by [plan_handle],
			 [sql_handle],
			 cast([start_time] as date)
)
,tbl_rec_stat_g as (
	select qs.[plan_handle]
		  ,qs.[sql_handle]
		  --,cast(qs.[last_execution_time] as date)	as [last_execution_time]
		  ,min(qs.[creation_time])					as [creation_time]
		  ,max(qs.[execution_count])				as [execution_count]
		  ,max(qs.[total_worker_time])				as [total_worker_time]
		  ,min(qs.[last_worker_time])				as [min_last_worker_time]
		  ,max(qs.[last_worker_time])				as [max_last_worker_time]
		  ,min(qs.[min_worker_time])				as [min_worker_time]
		  ,max(qs.[max_worker_time])				as [max_worker_time]
		  ,max(qs.[total_physical_reads])			as [total_physical_reads]
		  ,min(qs.[last_physical_reads])			as [min_last_physical_reads]
		  ,max(qs.[last_physical_reads])			as [max_last_physical_reads]
		  ,min(qs.[min_physical_reads])				as [min_physical_reads]
		  ,max(qs.[max_physical_reads])				as [max_physical_reads]
		  ,max(qs.[total_logical_writes])			as [total_logical_writes]
		  ,min(qs.[last_logical_writes])			as [min_last_logical_writes]
		  ,max(qs.[last_logical_writes])			as [max_last_logical_writes]
		  ,min(qs.[min_logical_writes])				as [min_logical_writes]
		  ,max(qs.[max_logical_writes])				as [max_logical_writes]
		  ,max(qs.[total_logical_reads])			as [total_logical_reads]
		  ,min(qs.[last_logical_reads])				as [min_last_logical_reads]
		  ,max(qs.[last_logical_reads])				as [max_last_logical_reads]
		  ,min(qs.[min_logical_reads])				as [min_logical_reads]
		  ,max(qs.[max_logical_reads])				as [max_logical_reads]
		  ,max(qs.[total_clr_time])					as [total_clr_time]
		  ,min(qs.[last_clr_time])					as [min_last_clr_time]
		  ,max(qs.[last_clr_time])					as [max_last_clr_time]
		  ,min(qs.[min_clr_time])					as [min_clr_time]
		  ,max(qs.[max_clr_time])					as [max_clr_time]
		  ,max(qs.[total_elapsed_time])				as [total_elapsed_time]
		  ,min(qs.[last_elapsed_time])				as [min_last_elapsed_time]
		  ,max(qs.[last_elapsed_time])				as [max_last_elapsed_time]
		  ,min(qs.[min_elapsed_time])				as [min_elapsed_time]
		  ,max(qs.[max_elapsed_time])				as [max_elapsed_time]
		  ,max(qs.[total_rows])						as [total_rows]
		  ,min(qs.[last_rows])						as [min_last_rows]
		  ,max(qs.[last_rows])						as [max_last_rows]
		  ,min(qs.[min_rows])						as [min_rows]
		  ,max(qs.[max_rows])						as [max_rows]
		  ,/*max(qs.[total_dop])			 */NULL as [total_dop]
		  ,/*min(qs.[last_dop])				 */NULL as [min_last_dop]
		  ,/*max(qs.[last_dop])				 */NULL as [max_last_dop]
		  ,/*min(qs.[min_dop])				 */NULL as [min_dop]
		  ,/*max(qs.[max_dop])				 */NULL as [max_dop]
		  ,/*max(qs.[total_grant_kb])		 */NULL as [total_grant_kb]
		  ,/*min(qs.[last_grant_kb])		 */NULL as [min_last_grant_kb]
		  ,/*max(qs.[last_grant_kb])		 */NULL as [max_last_grant_kb]
		  ,/*min(qs.[min_grant_kb])			 */NULL as [min_grant_kb]
		  ,/*max(qs.[max_grant_kb])			 */NULL as [max_grant_kb]
		  ,/*max(qs.[total_used_grant_kb])	 */NULL as [total_used_grant_kb]
		  ,/*min(qs.[last_used_grant_kb])	 */NULL as [min_last_used_grant_kb]
		  ,/*max(qs.[last_used_grant_kb])	 */NULL as [max_last_used_grant_kb]
		  ,/*min(qs.[min_used_grant_kb])	 */NULL as [min_used_grant_kb]
		  ,/*max(qs.[max_used_grant_kb])	 */NULL as [max_used_grant_kb]
		  ,/*max(qs.[total_ideal_grant_kb])	 */NULL as [total_ideal_grant_kb]
		  ,/*min(qs.[last_ideal_grant_kb])	 */NULL as [min_last_ideal_grant_kb]
		  ,/*max(qs.[last_ideal_grant_kb])	 */NULL as [max_last_ideal_grant_kb]
		  ,/*min(qs.[min_ideal_grant_kb])	 */NULL as [min_ideal_grant_kb]
		  ,/*max(qs.[max_ideal_grant_kb])	 */NULL as [max_ideal_grant_kb]
		  ,/*max(qs.[total_reserved_threads])*/NULL as [total_reserved_threads]
		  ,/*min(qs.[last_reserved_threads]) */NULL as [min_last_reserved_threads]
		  ,/*max(qs.[last_reserved_threads]) */NULL as [max_last_reserved_threads]
		  ,/*min(qs.[min_reserved_threads])	 */NULL as [min_reserved_threads]
		  ,/*max(qs.[max_reserved_threads])	 */NULL as [max_reserved_threads]
		  ,/*max(qs.[total_used_threads])	 */NULL as [total_used_threads]
		  ,/*min(qs.[last_used_threads])	 */NULL as [min_last_used_threads]
		  ,/*max(qs.[last_used_threads])	 */NULL as [max_last_used_threads]
		  ,/*min(qs.[min_used_threads])		 */NULL as [min_used_threads]
		  ,/*max(qs.[max_used_threads])		 */NULL as [max_used_threads]
	from tbl_res_rec_g as t
	inner join sys.dm_exec_query_stats as qs with(readuncommitted) on t.[plan_handle]=qs.[plan_handle] 
																  and t.[sql_handle]=qs.[sql_handle] 
																  and t.[start_time]=cast(qs.[last_execution_time] as date)
	group by qs.[plan_handle]
			,qs.[sql_handle]
			--,qs.[last_execution_time]
)
select t.[session_id] --Сессия
	      ,t.[blocking_session_id] --Сессия, которая явно блокирует сессию [session_id]
		  ,t.[request_id] --Идентификатор запроса. Уникален в контексте сеанса
	      ,t.[start_time] --Метка времени поступления запроса
		  ,DateDiff(second, t.[start_time], GetDate()) as [date_diffSec] --Сколько в сек прошло времени от момента поступления запроса
	      ,t.[status] --Состояние запроса
		  ,t.[status_session] --Состояние сессии
	      ,t.[command] --Тип выполняемой в данный момент команды
		  , COALESCE(
						CAST(NULLIF(t.[total_elapsed_time] / 1000, 0) as BIGINT)
					   ,CASE WHEN (t.[status_session] <> 'running' and isnull(t.[status], '')  <> 'running') 
								THEN  DATEDIFF(ss,0,getdate() - nullif(t.[last_request_end_time], '1900-01-01T00:00:00.000'))
						END
					) as [total_time, sec] --Время всей работы запроса в сек
		  , CAST(NULLIF((CAST(t.[total_elapsed_time] as BIGINT) - CAST(t.[wait_time] AS BIGINT)) / 1000, 0 ) as bigint) as [work_time, sec] --Время работы запроса в сек без учета времени ожиданий
		  , CASE WHEN (t.[status_session] <> 'running' AND ISNULL(t.[status],'') <> 'running') 
		  			THEN  DATEDIFF(ss,0,getdate() - nullif(t.[last_request_end_time], '1900-01-01T00:00:00.000'))
			END as [sleep_time, sec] --Время сна в сек
		  , NULLIF( CAST((t.[logical_reads] + t.[writes]) * 8 / 1024 as numeric(38,2)), 0) as [IO, MB] --операций чтения и записи в МБ
		  , CASE  t.transaction_isolation_level
			WHEN 0 THEN 'Unspecified'
			WHEN 1 THEN 'ReadUncommited'
			WHEN 2 THEN 'ReadCommited'
			WHEN 3 THEN 'Repetable'
			WHEN 4 THEN 'Serializable'
			WHEN 5 THEN 'Snapshot'
			END as [transaction_isolation_level_desc] --уровень изоляции транзакции (расшифровка)
		  ,t.[percent_complete] --Процент завершения работы для следующих команд
		  ,t.[DBName] --БД
		  ,t.[object] --Объект
		  , SUBSTRING(
						t.[TSQL]
					  , t.[statement_start_offset]/2+1
					  ,	(
							CASE WHEN ((t.[statement_start_offset]<0) OR (t.[statement_end_offset]<0))
									THEN DATALENGTH (t.[TSQL])
								 ELSE t.[statement_end_offset]
							END
							- t.[statement_start_offset]
						)/2 +1
					 ) as [CURRENT_REQUEST] --Текущий выполняемый запрос в пакете
	      ,t.[TSQL] --Запрос всего пакета
		  ,t.[QueryPlan] --План всего пакета
		  ,t.[event_info] --Текст инструкции из входного буфера для данным идентификатором spid
	      ,t.[wait_type] --Если запрос в настоящий момент блокирован, в столбце содержится тип ожидания (sys.dm_os_wait_stats)
	      ,t.[login_time] --Время подключения сеанса
		  ,t.[host_name] --Имя клиентской рабочей станции, указанное в сеансе. Для внутреннего сеанса это значение равно NULL
		  ,t.[program_name] --Имя клиентской программы, которая инициировала сеанс. Для внутреннего сеанса это значение равно NULL
		  ,cast(t.[wait_time]/1000 as decimal(18,3)) as [wait_timeSec] --Если запрос в настоящий момент блокирован, в столбце содержится продолжительность текущего ожидания (в секундах)
	      ,t.[wait_time] --Если запрос в настоящий момент блокирован, в столбце содержится продолжительность текущего ожидания (в миллисекундах)
	      ,t.[last_wait_type] --Если запрос был блокирован ранее, в столбце содержится тип последнего ожидания
	      ,t.[wait_resource] --Если запрос в настоящий момент блокирован, в столбце указан ресурс, освобождения которого ожидает запрос
	      ,t.[open_transaction_count] --Число транзакций, открытых для данного запроса
	      ,t.[open_resultset_count] --Число результирующих наборов, открытых для данного запроса
	      ,t.[transaction_id] --Идентификатор транзакции, в которой выполняется запрос
	      ,t.[context_info] --Значение CONTEXT_INFO сеанса
		  ,cast(t.[estimated_completion_time]/1000 as decimal(18,3)) as [estimated_completion_timeSec] --Только для внутреннего использования. Не допускает значение NULL
	      ,t.[estimated_completion_time] --Только для внутреннего использования. Не допускает значение NULL
		  ,cast(t.[cpu_time]/1000 as decimal(18,3)) as [cpu_timeSec] --Время ЦП (в секундах), затраченное на выполнение запроса
	      ,t.[cpu_time] --Время ЦП (в миллисекундах), затраченное на выполнение запроса
		  ,cast(t.[total_elapsed_time]/1000 as decimal(18,3)) as [total_elapsed_timeSec] --Общее время, истекшее с момента поступления запроса (в секундах)
	      ,t.[total_elapsed_time] --Общее время, истекшее с момента поступления запроса (в миллисекундах)
	      ,t.[scheduler_id] --Идентификатор планировщика, который планирует данный запрос
	      ,t.[task_address] --Адрес блока памяти, выделенного для задачи, связанной с этим запросом
	      ,t.[reads] --Число операций чтения, выполненных данным запросом
	      ,t.[writes] --Число операций записи, выполненных данным запросом
	      ,t.[logical_reads] --Число логических операций чтения, выполненных данным запросом
	      ,t.[text_size] --Установка параметра TEXTSIZE для данного запроса
	      ,t.[language] --Установка языка для данного запроса
	      ,t.[date_format] --Установка параметра DATEFORMAT для данного запроса
	      ,t.[date_first] --Установка параметра DATEFIRST для данного запроса
	      ,t.[quoted_identifier] --1 = Параметр QUOTED_IDENTIFIER для запроса включен (ON). В противном случае — 0
	      ,t.[arithabort] --1 = Параметр ARITHABORT для запроса включен (ON). В противном случае — 0
	      ,t.[ansi_null_dflt_on] --1 = Параметр ANSI_NULL_DFLT_ON для запроса включен (ON). В противном случае — 0
	      ,t.[ansi_defaults] --1 = Параметр ANSI_DEFAULTS для запроса включен (ON). В противном случае — 0
	      ,t.[ansi_warnings] --1 = Параметр ANSI_WARNINGS для запроса включен (ON). В противном случае — 0
	      ,t.[ansi_padding] --1 = Параметр ANSI_PADDING для запроса включен (ON)
	      ,t.[ansi_nulls] --1 = Параметр ANSI_NULLS для запроса включен (ON). В противном случае — 0
	      ,t.[concat_null_yields_null] --1 = Параметр CONCAT_NULL_YIELDS_NULL для запроса включен (ON). В противном случае — 0
	      ,t.[transaction_isolation_level] --Уровень изоляции, с которым создана транзакция для данного запроса
		  ,cast(t.[lock_timeout]/1000 as decimal(18,3)) as [lock_timeoutSec] --Время ожидания блокировки для данного запроса (в секундах)
		  ,t.[lock_timeout] --Время ожидания блокировки для данного запроса (в миллисекундах)
	      ,t.[deadlock_priority] --Значение параметра DEADLOCK_PRIORITY для данного запроса
	      ,t.[row_count] --Число строк, возвращенных клиенту по данному запросу
	      ,t.[prev_error] --Последняя ошибка, происшедшая при выполнении запроса
	      ,t.[nest_level] --Текущий уровень вложенности кода, выполняемого для данного запроса
	      ,t.[granted_query_memory] --Число страниц, выделенных для выполнения поступившего запроса (1 страница-это примерно 8 КБ)
	      ,t.[executing_managed_code] --Указывает, выполняет ли данный запрос в настоящее время код объекта среды CLR (например, процедуры, типа или триггера).
									  --Этот флаг установлен в течение всего времени, когда объект среды CLR находится в стеке, даже когда из среды вызывается код Transact-SQL
	      
		  ,t.[group_id]	--Идентификатор группы рабочей нагрузки, которой принадлежит этот запрос
	      ,t.[query_hash] --Двоичное хэш-значение рассчитывается для запроса и используется для идентификации запросов с аналогичной логикой.
						  --Можно использовать хэш запроса для определения использования статистических ресурсов для запросов, которые отличаются только своими литеральными значениями
	      
		  ,t.[query_plan_hash] --Двоичное хэш-значение рассчитывается для плана выполнения запроса и используется для идентификации аналогичных планов выполнения запросов.
							   --Можно использовать хэш плана запроса для нахождения совокупной стоимости запросов со схожими планами выполнения
		  
		  ,t.[most_recent_session_id] --Представляет собой идентификатор сеанса самого последнего запроса, связанного с данным соединением
	      ,t.[connect_time] --Отметка времени установления соединения
	      ,t.[net_transport] --Содержит описание физического транспортного протокола, используемого данным соединением
	      ,t.[protocol_type] --Указывает тип протокола передачи полезных данных
	      ,t.[protocol_version] --Версия протокола доступа к данным, связанного с данным соединением
	      ,t.[endpoint_id] --Идентификатор, описывающий тип соединения. Этот идентификатор endpoint_id может использоваться для запросов к представлению sys.endpoints
	      ,t.[encrypt_option] --Логическое значение, указывающее, разрешено ли шифрование для данного соединения
	      ,t.[auth_scheme] --Указывает схему проверки подлинности (SQL Server или Windows), используемую с данным соединением
	      ,t.[node_affinity] --Идентифицирует узел памяти, которому соответствует данное соединение
	      ,t.[num_reads] --Число пакетов, принятых посредством данного соединения
	      ,t.[num_writes] --Число пакетов, переданных посредством данного соединения
	      ,t.[last_read] --Отметка времени о последнем полученном пакете данных
	      ,t.[last_write] --Отметка времени о последнем отправленном пакете данных
	      ,t.[net_packet_size] --Размер сетевого пакета, используемый для передачи данных
	      ,t.[client_net_address] --Сетевой адрес удаленного клиента
	      ,t.[client_tcp_port] --Номер порта на клиентском компьютере, который используется при осуществлении соединения
	      ,t.[local_net_address] --IP-адрес сервера, с которым установлено данное соединение. Доступен только для соединений, которые в качестве транспорта данных используют протокол TCP
	      ,t.[local_tcp_port] --TCP-порт сервера, если соединение использует протокол TCP
	      ,t.[parent_connection_id] --Идентифицирует первичное соединение, используемое в сеансе MARS
	      ,t.[most_recent_sql_handle] --Дескриптор последнего запроса SQL, выполненного с помощью данного соединения. Постоянно проводится синхронизация между столбцом most_recent_sql_handle и столбцом most_recent_session_id
		  ,t.[host_process_id] --Идентификатор процесса клиентской программы, которая инициировала сеанс. Для внутреннего сеанса это значение равно NULL
		  ,t.[client_version] --Версия TDS-протокола интерфейса, который используется клиентом для подключения к серверу. Для внутреннего сеанса это значение равно NULL
		  ,t.[client_interface_name] --Имя библиотеки или драйвер, используемый клиентом для обмена данными с сервером. Для внутреннего сеанса это значение равно NULL
		  ,t.[security_id] --Идентификатор безопасности Microsoft Windows, связанный с именем входа
		  ,t.[login_name] --SQL Server Имя входа, под которой выполняется текущий сеанс.
						  --Чтобы узнать первоначальное имя входа, с помощью которого был создан сеанс, см. параметр original_login_name.
						  --Может быть SQL Server проверка подлинности имени входа или имени пользователя домена, прошедшего проверку подлинности Windows
		  
		  ,t.[nt_domain] --Домен Windows для клиента, если во время сеанса применяется проверка подлинности Windows или доверительное соединение.
						 --Для внутренних сеансов и пользователей, не принадлежащих к домену, это значение равно NULL
		  
		  ,t.[nt_user_name] --Имя пользователя Windows для клиента, если во время сеанса используется проверка подлинности Windows или доверительное соединение.
							--Для внутренних сеансов и пользователей, не принадлежащих к домену, это значение равно NULL
		  
		  ,t.[memory_usage] --Количество 8-килобайтовых страниц памяти, используемых данным сеансом
		  ,t.[total_scheduled_time] --Общее время, назначенное данному сеансу (включая его вложенные запросы) для исполнения, в миллисекундах
		  ,t.[last_request_start_time] --Время, когда начался последний запрос данного сеанса. Это может быть запрос, выполняющийся в данный момент
		  ,t.[last_request_end_time] --Время завершения последнего запроса в рамках данного сеанса
		  ,t.[is_user_process] --0, если сеанс является системным. В противном случае значение равно 1
		  ,t.[original_security_id] --Microsoft Идентификатор безопасности Windows, связанный с параметром original_login_name
		  ,t.[original_login_name] --SQL Server Имя входа, которую использует клиент создал данный сеанс.
								   --Это может быть имя входа SQL Server, прошедшее проверку подлинности, имя пользователя домена Windows, 
								   --прошедшее проверку подлинности, или пользователь автономной базы данных.
								   --Обратите внимание, что после первоначального соединения для сеанса может быть выполнено много неявных или явных переключений контекста.
								   --Например если EXECUTE AS используется
		  
		  ,t.[last_successful_logon] --Время последнего успешного входа в систему для имени original_login_name до запуска текущего сеанса
		  ,t.[last_unsuccessful_logon] --Время последнего неуспешного входа в систему для имени original_login_name до запуска текущего сеанса
		  ,t.[unsuccessful_logons] --Число неуспешных попыток входа в систему для имени original_login_name между временем last_successful_logon и временем login_time
		  ,t.[authenticating_database_id] --Идентификатор базы данных, выполняющей проверку подлинности участника.
										  --Для имен входа это значение будет равно 0.
										  --Для пользователей автономной базы данных это значение будет содержать идентификатор автономной базы данных
		  
		  ,t.[sql_handle] --Хэш-карта текста SQL-запроса
	      ,t.[statement_start_offset] --Количество символов в выполняемом в настоящий момент пакете или хранимой процедуре, в которой запущена текущая инструкция.
									  --Может применяться вместе с функциями динамического управления sql_handle, statement_end_offset и sys.dm_exec_sql_text
									  --для извлечения исполняемой в настоящий момент инструкции по запросу
	      
		  ,t.[statement_end_offset] --Количество символов в выполняемом в настоящий момент пакете или хранимой процедуре, в которой завершилась текущая инструкция.
									--Может применяться вместе с функциями динамического управления sql_handle, statement_end_offset и sys.dm_exec_sql_text
									--для извлечения исполняемой в настоящий момент инструкции по запросу
	      
		  ,t.[plan_handle] --Хэш-карта плана выполнения SQL
	      ,t.[database_id] --Идентификатор базы данных, к которой выполняется запрос
	      ,t.[user_id] --Идентификатор пользователя, отправившего данный запрос
	      ,t.[connection_id] --Идентификатор соединения, по которому поступил запрос
		  ,t.[is_blocking_other_session] --1-сессия явно блокирует другие сессии, 0-сессия явно не блокирует другие сессии
		  ,coalesce(t.[dop], mg.[dop]) as [dop] --Степень параллелизма запроса
		  ,mg.[request_time] --Дата и время обращения запроса за предоставлением памяти
		  ,mg.[grant_time] --Дата и время, когда запросу была предоставлена память. Возвращает значение NULL, если память еще не была предоставлена
		  ,mg.[requested_memory_kb] --Общий объем запрошенной памяти в килобайтах
		  ,mg.[granted_memory_kb] --Общий объем фактически предоставленной памяти в килобайтах.
								  --Может быть значение NULL, если память еще не была предоставлена.
								  --Обычно это значение должно быть одинаковым с requested_memory_kb.
								  --Для создания индекса сервер может разрешить дополнительное предоставление по требованию памяти,
								  --объем которой выходит за рамки изначально предоставленной памяти
		  
		  ,mg.[required_memory_kb] --Минимальный объем памяти в килобайтах (КБ), необходимый для выполнения данного запроса.
								   --Значение requested_memory_kb равно этому объему или больше его
		  
		  ,mg.[used_memory_kb] --Используемый в данный момент объем физической памяти (в килобайтах)
		  ,mg.[max_used_memory_kb] --Максимальный объем используемой до данного момента физической памяти в килобайтах
		  ,mg.[query_cost] --Ожидаемая стоимость запроса
		  ,mg.[timeout_sec] --Время ожидания данного запроса в секундах до отказа от обращения за предоставлением памяти
		  ,mg.[resource_semaphore_id] --Неуникальный идентификатор семафора ресурса, которого ожидает данный запрос
		  ,mg.[queue_id] --Идентификатор ожидающей очереди, в которой данный запрос ожидает предоставления памяти.
						 --Значение NULL, если память уже предоставлена
		  
		  ,mg.[wait_order] --Последовательный порядок ожидающих запросов в указанной очереди queue_id.
						   --Это значение может изменяться для заданного запроса, если другие запросы отказываются от предоставления памяти или получают ее.
						   --Значение NULL, если память уже предоставлена
		  
		  ,mg.[is_next_candidate] --Является следующим кандидатом на предоставление памяти (1 = да, 0 = нет, NULL = память уже предоставлена)
		  ,mg.[wait_time_ms] --Время ожидания в миллисекундах. Значение NULL, если память уже предоставлена
		  ,mg.[pool_id] --Идентификатор пула ресурсов, к которому принадлежит данная группа рабочей нагрузки
		  ,mg.[is_small] --Значение 1 означает, что для данной операции предоставления памяти используется малый семафор ресурса.
						 --Значение 0 означает использование обычного семафора
		  
		  ,mg.[ideal_memory_kb] --Объем, в килобайтах (КБ), предоставленной памяти, необходимый для размещения всех данных в физической памяти.
								--Основывается на оценке количества элементов
		  
		  ,NULL as [reserved_worker_count]--mg.[reserved_worker_count] --Число рабочих процессов, зарезервированной с помощью параллельных запросов, а также число основных рабочих процессов, используемых всеми запросами
		  ,NULL as [used_worker_count]--mg.[used_worker_count] --Число рабочих процессов, используемых параллельных запросов
		  ,NULL as [max_used_worker_count]--mg.[max_used_worker_count] --???
		  ,NULL as [reserved_node_bitmap]--mg.[reserved_node_bitmap] --???
		  ,pl.[bucketid] --Идентификатор сегмента хэша, в который кэшируется запись.
						 --Значение указывает диапазон от 0 до значения размера хэш-таблицы для типа кэша.
						 --Для кэшей SQL Plans и Object Plans размер хэш-таблицы может достигать 10007 на 32-разрядных версиях систем и 40009 — на 64-разрядных.
						 --Для кэша Bound Trees размер хэш-таблицы может достигать 1009 на 32-разрядных версиях систем и 4001 на 64-разрядных.
						 --Для кэша расширенных хранимых процедур размер хэш-таблицы может достигать 127 на 32-разрядных и 64-разрядных версиях систем
		  
		  ,pl.[refcounts] --Число объектов кэша, ссылающихся на данный объект кэша.
						  --Значение refcounts для записи должно быть не меньше 1, чтобы размещаться в кэше
		  
		  ,pl.[usecounts] --Количество повторений поиска объекта кэша.
						  --Остается без увеличения, если параметризованные запросы обнаруживают план в кэше.
						  --Может быть увеличен несколько раз при использовании инструкции showplan
		  
		  ,pl.[size_in_bytes] --Число байтов, занимаемых объектом кэша
		  ,pl.[memory_object_address] --Адрес памяти кэшированной записи.
									  --Это значение можно использовать с представлением sys.dm_os_memory_objects,
									  --чтобы проанализировать распределение памяти кэшированного плана, 
									  --и с представлением sys.dm_os_memory_cache_entries для определения затрат на кэширование записи
		  
		  ,pl.[cacheobjtype] --Тип объекта в кэше. Значение может быть одним из следующих
		  ,pl.[objtype] --Тип объекта. Значение может быть одним из следующих
		  ,pl.[parent_plan_handle] --Родительский план
		  
		  --данные из sys.dm_exec_query_stats брались за сутки, в которых была пара (запрос, план)
		  ,qs.[creation_time] --Время компиляции плана
		  ,qs.[execution_count] --Количество выполнений плана с момента последней компиляции
		  ,qs.[total_worker_time] --Общее время ЦП, затраченное на выполнение плана с момента компиляции, в микросекундах (но с точностью до миллисекунды)
		  ,qs.[min_last_worker_time] --Минимальное время ЦП, затраченное на последнее выполнение плана, в микросекундах (но с точностью до миллисекунды)
		  ,qs.[max_last_worker_time] --Максимальное время ЦП, затраченное на последнее выполнение плана, в микросекундах (но с точностью до миллисекунды)
		  ,qs.[min_worker_time] --Минимальное время ЦП, когда-либо затраченное на выполнение плана, в микросекундах (но с точностью до миллисекунды)
		  ,qs.[max_worker_time] --Максимальное время ЦП, когда-либо затраченное на выполнение плана, в микросекундах (но с точностью до миллисекунды)
		  ,qs.[total_physical_reads] --Общее количество операций физического считывания при выполнении плана с момента его компиляции.
									 --Значение всегда равно 0 при запросе оптимизированной для памяти таблицы
		  
		  ,qs.[min_last_physical_reads] --Минимальное количество операций физического считывания за время последнего выполнения плана.
										--Значение всегда равно 0 при запросе оптимизированной для памяти таблицы
		  
		  ,qs.[max_last_physical_reads] --Максимальное количество операций физического считывания за время последнего выполнения плана.
										--Значение всегда равно 0 при запросе оптимизированной для памяти таблицы
		  
		  ,qs.[min_physical_reads] --Минимальное количество операций физического считывания за одно выполнение плана.
								   --Значение всегда равно 0 при запросе оптимизированной для памяти таблицы
		  
		  ,qs.[max_physical_reads] --Максимальное количество операций физического считывания за одно выполнение плана.
								   --Значение всегда равно 0 при запросе оптимизированной для памяти таблицы
		  
		  ,qs.[total_logical_writes] --Общее количество операций логической записи при выполнении плана с момента его компиляции.
									 --Значение всегда равно 0 при запросе оптимизированной для памяти таблицы
		  
		  ,qs.[min_last_logical_writes] --Минимальное количество страниц в буферном пуле, загрязненных во время последнего выполнения плана.
										--Если страница уже является «грязной» (т. е. измененной), операции записи не учитываются.
										--Значение всегда равно 0 при запросе оптимизированной для памяти таблицы
		  
		  ,qs.[max_last_logical_writes] --Максимальное количество страниц в буферном пуле, загрязненных во время последнего выполнения плана.
										--Если страница уже является «грязной» (т. е. измененной), операции записи не учитываются.
										--Значение всегда равно 0 при запросе оптимизированной для памяти таблицы
		  
		  ,qs.[min_logical_writes] --Минимальное количество операций логической записи за одно выполнение плана.
								   --Значение всегда равно 0 при запросе оптимизированной для памяти таблицы
		  
		  ,qs.[max_logical_writes] --Максимальное количество операций логической записи за одно выполнение плана.
								   --Значение всегда равно 0 при запросе оптимизированной для памяти таблицы
		  
		  ,qs.[total_logical_reads] --Общее количество операций логического считывания при выполнении плана с момента его компиляции.
									--Значение всегда равно 0 при запросе оптимизированной для памяти таблицы
		  
		  ,qs.[min_last_logical_reads] --Минимальное количество операций логического считывания за время последнего выполнения плана.
									   --Значение всегда равно 0 при запросе оптимизированной для памяти таблицы
		  
		  ,qs.[max_last_logical_reads] --Максимальное количество операций логического считывания за время последнего выполнения плана.
									   --Значение всегда равно 0 при запросе оптимизированной для памяти таблицы
		  
		  ,qs.[min_logical_reads]	   --Минимальное количество операций логического считывания за одно выполнение плана.
									   --Значение всегда равно 0 при запросе оптимизированной для памяти таблицы
		  
		  ,qs.[max_logical_reads]	--Максимальное количество операций логического считывания за одно выполнение плана.
									--Значение всегда равно 0 при запросе оптимизированной для памяти таблицы
		  
		  ,qs.[total_clr_time]	--Время, в микросекундах (но с точностью до миллисекунды),
								--внутри Microsoft .NET Framework общеязыковая среда выполнения (CLR) объекты при выполнении плана с момента его компиляции.
								--Объекты среды CLR могут быть хранимыми процедурами, функциями, триггерами, типами и статистическими выражениями
		  
		  ,qs.[min_last_clr_time] --Минимальное время, в микросекундах (но с точностью до миллисекунды),
								  --затраченное внутри .NET Framework объекты среды CLR во время последнего выполнения плана.
								  --Объекты среды CLR могут быть хранимыми процедурами, функциями, триггерами, типами и статистическими выражениями
		  
		  ,qs.[max_last_clr_time] --Максимальное время, в микросекундах (но с точностью до миллисекунды),
								  --затраченное внутри .NET Framework объекты среды CLR во время последнего выполнения плана.
								  --Объекты среды CLR могут быть хранимыми процедурами, функциями, триггерами, типами и статистическими выражениями
		  
		  ,qs.[min_clr_time] --Минимальное время, когда-либо затраченное на выполнение плана внутри объектов .NET Framework среды CLR,
							 --в микросекундах (но с точностью до миллисекунды).
							 --Объекты среды CLR могут быть хранимыми процедурами, функциями, триггерами, типами и статистическими выражениями
		  
		  ,qs.[max_clr_time] --Максимальное время, когда-либо затраченное на выполнение плана внутри среды CLR .NET Framework,
							 --в микросекундах (но с точностью до миллисекунды).
							 --Объекты среды CLR могут быть хранимыми процедурами, функциями, триггерами, типами и статистическими выражениями
		  
		  --,qs.[total_elapsed_time] --Общее время, затраченное на выполнение плана, в микросекундах (но с точностью до миллисекунды)
		  ,qs.[min_last_elapsed_time] --Минимальное время, затраченное на последнее выполнение плана, в микросекундах (но с точностью до миллисекунды)
		  ,qs.[max_last_elapsed_time] --Максимальное время, затраченное на последнее выполнение плана, в микросекундах (но с точностью до миллисекунды)
		  ,qs.[min_elapsed_time] --Минимальное время, когда-либо затраченное на выполнение плана, в микросекундах (но с точностью до миллисекунды)
		  ,qs.[max_elapsed_time] --Максимальное время, когда-либо затраченное на выполнение плана, в микросекундах (но с точностью до миллисекунды)
		  ,qs.[total_rows] --Общее число строк, возвращаемых запросом. Не может иметь значение null.
						   --Значение всегда равно 0, если скомпилированная в собственном коде хранимая процедура запрашивает оптимизированную для памяти таблицу
		  
		  ,qs.[min_last_rows] --Минимальное число строк, возвращенных последним выполнением запроса. Не может иметь значение null.
							  --Значение всегда равно 0, если скомпилированная в собственном коде хранимая процедура запрашивает оптимизированную для памяти таблицу
		  
		  ,qs.[max_last_rows] --Максимальное число строк, возвращенных последним выполнением запроса. Не может иметь значение null.
							  --Значение всегда равно 0, если скомпилированная в собственном коде хранимая процедура запрашивает оптимизированную для памяти таблицу
		  
		  ,qs.[min_rows] --Минимальное количество строк, когда-либо возвращенных по запросу во время выполнения один
						 --Значение всегда равно 0, если скомпилированная в собственном коде хранимая процедура запрашивает оптимизированную для памяти таблицу
		  
		  ,qs.[max_rows] --Максимальное число строк, когда-либо возвращенных по запросу во время выполнения один
						 --Значение всегда равно 0, если скомпилированная в собственном коде хранимая процедура запрашивает оптимизированную для памяти таблицу
		  
		  ,qs.[total_dop] --Общую сумму по степени параллелизма плана используется с момента его компиляции.
						  --Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[min_last_dop] --Минимальная степень параллелизма, если время последнего выполнения плана.
							 --Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[max_last_dop] --Максимальная степень параллелизма, если время последнего выполнения плана.
							 --Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[min_dop] --Минимальная степень параллелизма этот план когда-либо используется во время одного выполнения.
						--Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[max_dop] --Максимальная степень параллелизма этот план когда-либо используется во время одного выполнения.
						--Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[total_grant_kb] --Общий объем зарезервированной памяти в КБ предоставить этот план, полученных с момента его компиляции.
							   --Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[min_last_grant_kb] --Минимальный объем зарезервированной памяти предоставляет в КБ, когда время последнего выполнения плана.
								  --Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[max_last_grant_kb] --Максимальный объем зарезервированной памяти предоставляет в КБ, когда время последнего выполнения плана.
								  --Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[min_grant_kb] --Минимальный объем зарезервированной памяти в КБ предоставить никогда не получено в ходе одного выполнения плана.
							 --Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[max_grant_kb] --Максимальный объем зарезервированной памяти в КБ предоставить никогда не получено в ходе одного выполнения плана.
							 --Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[total_used_grant_kb] --Общий объем зарезервированной памяти в КБ предоставить этот план, используемый с момента его компиляции.
									--Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[min_last_used_grant_kb] --Минимальная сумма предоставления используемой памяти в КБ, если время последнего выполнения плана.
									   --Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[max_last_used_grant_kb] --Максимальная сумма предоставления используемой памяти в КБ, если время последнего выполнения плана.
									   --Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[min_used_grant_kb] --Минимальный объем используемой памяти в КБ предоставить никогда не используется при выполнении одного плана.
								  --Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[max_used_grant_kb] --Максимальный объем используемой памяти в КБ предоставить никогда не используется при выполнении одного плана.
								  --Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[total_ideal_grant_kb] --Общий объем идеальный память в КБ, оценка плана с момента его компиляции.
									 --Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[min_last_ideal_grant_kb] --Минимальный объем памяти, идеальным предоставляет в КБ, когда время последнего выполнения плана.
										--Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[max_last_ideal_grant_kb] --Максимальный объем памяти, идеальным предоставляет в КБ, когда время последнего выполнения плана.
										--Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[min_ideal_grant_kb] --Минимальный объем памяти идеальный предоставления в этот план когда-либо оценка во время выполнения один КБ.
								   --Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[max_ideal_grant_kb] --Максимальный объем памяти идеальный предоставления в этот план когда-либо оценка во время выполнения один КБ.
								   --Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[total_reserved_threads] --Общая сумма по зарезервированным параллельного потоков этот план когда-либо использовавшегося с момента его компиляции.
									   --Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[min_last_reserved_threads] --Минимальное число зарезервированных параллельных потоков, когда время последнего выполнения плана.
										  --Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[max_last_reserved_threads] --Максимальное число зарезервированных параллельных потоков, когда время последнего выполнения плана.
										  --Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[min_reserved_threads] --Минимальное число зарезервированных параллельного потоков, когда-либо использовать при выполнении одного плана.
									 --Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[max_reserved_threads] --Максимальное число зарезервированных параллельного потоков никогда не используется при выполнении одного плана.
									 --Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[total_used_threads] --Общая сумма используется параллельных потоков этот план когда-либо использовавшегося с момента его компиляции.
								   --Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[min_last_used_threads] --Минимальное число используемых параллельных потоков, когда время последнего выполнения плана.
									  --Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[max_last_used_threads] --Максимальное число используемых параллельных потоков, когда время последнего выполнения плана.
									  --Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[min_used_threads] --Минимальное число используемых параллельных потоков, при выполнении одного плана использовали.
								 --Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
		  
		  ,qs.[max_used_threads] --Максимальное число используемых параллельных потоков, при выполнении одного плана использовали.
								 --Он всегда будет равно 0 для запроса к таблице, оптимизированной для памяти
from tbl_res_rec as t
left outer join sys.dm_exec_query_memory_grants as mg on t.[plan_handle]=mg.[plan_handle] and t.[sql_handle]=mg.[sql_handle]
left outer join sys.dm_exec_cached_plans as pl on t.[plan_handle]=pl.[plan_handle]
left outer join tbl_rec_stat_g as qs on t.[plan_handle]=qs.[plan_handle] and t.[sql_handle]=qs.[sql_handle] --and qs.[last_execution_time]=cast(t.[start_time] as date)
;
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter view [inf].[vRecomendateIndex]
--
GO


ALTER view [inf].[vRecomendateIndex] as

-- Отсутствующие индексы из DMV

SELECT  cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)) AS ServerName ,
        DB_Name(ddmid.[database_id]) as [DBName] ,
        t.name AS 'Affected_table' ,
		ddmigs.user_seeks * ddmigs.avg_total_user_cost * (ddmigs.avg_user_impact * 0.01) AS index_advantage,
		ddmigs.group_handle,
		ddmigs.unique_compiles,
		ddmigs.last_user_seek,
		ddmigs.last_user_scan,
		ddmigs.avg_total_user_cost,
		ddmigs.avg_user_impact,
		ddmigs.system_seeks,
		ddmigs.last_system_scan,
		ddmigs.last_system_seek,
		ddmigs.avg_total_system_cost,
		ddmigs.avg_system_impact,
		ddmig.index_group_handle,
		ddmig.index_handle,
		ddmid.database_id,
		ddmid.[object_id],
		ddmid.equality_columns,	  -- =
		ddmid.inequality_columns,
		ddmid.[statement],
        ( LEN(ISNULL(ddmid.equality_columns, N'')
              + CASE WHEN ddmid.equality_columns IS NOT NULL
                          AND ddmid.inequality_columns IS NOT NULL THEN ','
                     ELSE ''
                END) - LEN(REPLACE(ISNULL(ddmid.equality_columns, N'')
                                   + CASE WHEN ddmid.equality_columns
                                                             IS NOT NULL
                                               AND ddmid.inequality_columns
                                                             IS NOT NULL
                                          THEN ','
                                          ELSE ''
                                     END, ',', '')) ) + 1 AS K ,
        COALESCE(ddmid.equality_columns, '')
        + CASE WHEN ddmid.equality_columns IS NOT NULL
                    AND ddmid.inequality_columns IS NOT NULL THEN ','
               ELSE ''
          END + COALESCE(ddmid.inequality_columns, '') AS Keys ,
        ddmid.included_columns AS [include] ,
        'Create NonClustered Index IX_' + t.name + '_missing_'
        + CAST(ddmid.index_handle AS VARCHAR(20)) 
        + ' On ' + ddmid.[statement] COLLATE database_default
        + ' (' + ISNULL(ddmid.equality_columns, '')
        + CASE WHEN ddmid.equality_columns IS NOT NULL
                    AND ddmid.inequality_columns IS NOT NULL THEN ','
               ELSE ''
          END + ISNULL(ddmid.inequality_columns, '') + ')'
        + ISNULL(' Include (' + ddmid.included_columns + ');', ';')
                                                  AS sql_statement ,
        ddmigs.user_seeks ,
        ddmigs.user_scans ,
        CAST(( ddmigs.user_seeks + ddmigs.user_scans )
        * ddmigs.avg_user_impact AS BIGINT) AS 'est_impact' ,
        ( SELECT    DATEDIFF(Second, create_date, GETDATE()) Seconds
          FROM      sys.databases
          WHERE     name = 'tempdb'
        ) SecondsUptime 
FROM    sys.dm_db_missing_index_groups ddmig
        INNER JOIN sys.dm_db_missing_index_group_stats ddmigs
               ON ddmigs.group_handle = ddmig.index_group_handle
        INNER JOIN sys.dm_db_missing_index_details ddmid
               ON ddmig.index_handle = ddmid.index_handle
        INNER JOIN sys.tables t ON ddmid.OBJECT_ID = t.OBJECT_ID
WHERE   ddmid.database_id = DB_ID()
--ORDER BY est_impact DESC;


GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter view [inf].[vReadWriteTables]
--
GO
ALTER view [inf].[vReadWriteTables] as
	-- Чтение/запись таблицы
	-- Кучи не рассматриваются, у них нет индексов
	-- Только те таблицы, к которым обращались после запуска SQL Server
	
	SELECT  cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)) AS ServerName ,
	        DB_NAME() AS DBName ,
			s.name AS SchemaTableName ,
	        OBJECT_NAME(ddius.object_id) AS TableName ,
	        SUM(ddius.user_seeks + ddius.user_scans + ddius.user_lookups)
	                                                               AS  Reads ,
	        SUM(ddius.user_updates) AS Writes ,
	        SUM(ddius.user_seeks + ddius.user_scans + ddius.user_lookups
	            + ddius.user_updates) AS [Reads&Writes] ,
	        ( SELECT    DATEDIFF(s, create_date, GETDATE()) / 86400.0
	          FROM      master.sys.databases
	          WHERE     name = 'tempdb'
	        ) AS SampleDays ,
	        ( SELECT    DATEDIFF(s, create_date, GETDATE()) AS SecoundsRunnig
	          FROM      master.sys.databases
	          WHERE     name = 'tempdb'
	        ) AS SampleSeconds
	FROM    sys.dm_db_index_usage_stats ddius
			inner join sys.tables as t on t.object_id=ddius.object_id
			inner join sys.schemas as s on t.schema_id=s.schema_id
			INNER JOIN sys.indexes i ON ddius.object_id = i.object_id
	                                     AND i.index_id = ddius.index_id
	WHERE    OBJECTPROPERTY(ddius.object_id, 'IsUserTable') = 1
	        AND ddius.database_id = DB_ID()
	GROUP BY s.name, OBJECT_NAME(ddius.object_id)
	--ORDER BY [Reads&Writes] DESC

GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on view [inf].[vRAM]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Информация по использованию ОЗУ', 'SCHEMA', N'inf', 'VIEW', N'vRAM'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter view [inf].[vProcedures]
--
GO


ALTER view [inf].[vProcedures] as
-- Additional information about SP 

SELECT  cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)) AS ServerName ,
        DB_NAME() AS DB_Name ,
		s.name as SchemaName,
        o.name AS 'ViewName' ,
        o.[type] ,
        o.Create_date ,
        sm.[definition] AS 'Stored Procedure script'
FROM    sys.objects o
		inner join sys.schemas s on o.schema_id=s.schema_id
        INNER JOIN sys.sql_modules sm ON o.object_id = sm.object_id
WHERE   o.[type] in ('P', 'PC') -- Stored Procedures 
        -- AND sm.[definition] LIKE '%insert%'
        -- AND sm.[definition] LIKE '%update%'
        -- AND sm.[definition] LIKE '%delete%'
        -- AND sm.[definition] LIKE '%tablename%'
--ORDER BY o.name;


GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Update extended property [MS_Description] on view [inf].[vProcedures]
--
EXEC sys.sp_updateextendedproperty N'MS_Description', N'Stored procedures with their definitions', 'SCHEMA', N'inf', 'VIEW', N'vProcedures'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter view [inf].[vNewIndexOptimize]
--
GO

ALTER view [inf].[vNewIndexOptimize] as
/*
	ГЕМ: степень полезности новых индексов
	index_advantage: >50 000 - очень выгодно создать индекс
					 >10 000 - можно создать индекс, однако нужно анализировать и его поддержку
					 <=10000 - индекс можно не создавать
*/
SELECT cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)) AS ServerName,
       DB_Name(ddmid.[database_id]) as [DBName],
	   OBJECT_SCHEMA_NAME(ddmid.[object_id], ddmid.[database_id]) as [Schema],
	   OBJECT_NAME(ddmid.[object_id], ddmid.[database_id]) as [Name],
	   ddmigs.user_seeks * ddmigs.avg_total_user_cost * (ddmigs.avg_user_impact * 0.01) AS index_advantage,
	   ddmigs.group_handle,
	   ddmigs.unique_compiles,
	   ddmigs.last_user_seek,
	   ddmigs.last_user_scan,
	   ddmigs.avg_total_user_cost,
	   ddmigs.avg_user_impact,
	   ddmigs.system_seeks,
	   ddmigs.last_system_scan,
	   ddmigs.last_system_seek,
	   ddmigs.avg_total_system_cost,
	   ddmigs.avg_system_impact,
	   ddmig.index_group_handle,
	   ddmig.index_handle,
	   ddmid.database_id,
	   ddmid.[object_id],
	   ddmid.equality_columns,	  -- =
	   ddmid.inequality_columns,
	   ddmid.[statement],
       ( LEN(ISNULL(ddmid.equality_columns, N'')
             + CASE WHEN ddmid.equality_columns IS NOT NULL
                         AND ddmid.inequality_columns IS NOT NULL THEN ','
                    ELSE ''
               END) - LEN(REPLACE(ISNULL(ddmid.equality_columns, N'')
                                  + CASE WHEN ddmid.equality_columns
                                                            IS NOT NULL
                                              AND ddmid.inequality_columns
                                                            IS NOT NULL
                                         THEN ','
                                         ELSE ''
                                    END, ',', '')) ) + 1 AS K ,
       COALESCE(ddmid.equality_columns, '')
       + CASE WHEN ddmid.equality_columns IS NOT NULL
                   AND ddmid.inequality_columns IS NOT NULL THEN ','
              ELSE ''
         END + COALESCE(ddmid.inequality_columns, '') AS Keys ,
       ddmid.included_columns AS [include] ,
       'Create NonClustered Index [IX_' + OBJECT_NAME(ddmid.[object_id], ddmid.[database_id]) + '_missing_'
       + CAST(ddmid.index_handle AS VARCHAR(20)) 
       + '] On ' + ddmid.[statement] COLLATE database_default
       + ' (' + ISNULL(ddmid.equality_columns, '')
       + CASE WHEN ddmid.equality_columns IS NOT NULL
                   AND ddmid.inequality_columns IS NOT NULL THEN ','
              ELSE ''
         END + ISNULL(ddmid.inequality_columns, '') + ')'
       + ISNULL(' Include (' + ddmid.included_columns + ');', ';')
                                                 AS sql_statement ,
       ddmigs.user_seeks ,
       ddmigs.user_scans ,
       CAST(( ddmigs.user_seeks + ddmigs.user_scans )
       * ddmigs.avg_user_impact AS BIGINT) AS 'est_impact' ,
       ( SELECT    DATEDIFF(Second, create_date, GETDATE()) Seconds
         FROM      sys.databases
         WHERE     name = 'tempdb'
       ) SecondsUptime 
FROM
sys.dm_db_missing_index_group_stats ddmigs
INNER JOIN sys.dm_db_missing_index_groups AS ddmig
ON ddmigs.group_handle = ddmig.index_group_handle
INNER JOIN sys.dm_db_missing_index_details AS ddmid
ON ddmig.index_handle = ddmid.index_handle
--WHERE   mid.database_id = DB_ID()
--ORDER BY migs_adv.index_advantage


GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter view [inf].[vJobRunShortInfo]
--
GO







ALTER view [inf].[vJobRunShortInfo] as
SELECT sj.[job_id] as Job_GUID
      ,j.name as Job_Name
      ,case sj.[last_run_outcome]
		when 0 then 'Error'
		when 1 then 'Success'
		when 3 then 'Canceled'
		else case when sj.[last_run_date] is not null and len(sj.[last_run_date])=8 then 'Indefinite state'
				else NULL
				end
	   end as LastFinishRunState
	  ,sj.[last_run_outcome] as LastRunOutcome
	  ,case when sj.[last_run_date] is not null and len(sj.[last_run_date])=8 then
		DATETIMEFROMPARTS(
							substring(cast(sj.[last_run_date] as nvarchar(255)),1,4),
							substring(cast(sj.[last_run_date] as nvarchar(255)),5,2),
							substring(cast(sj.[last_run_date] as nvarchar(255)),7,2),
							case when len(cast(sj.[last_run_time] as nvarchar(255)))>=5 then substring(cast(sj.[last_run_time] as nvarchar(255)),1,len(cast(sj.[last_run_time] as nvarchar(255)))-4)
								else 0
							end,
							case when len(right(cast(sj.[last_run_time] as nvarchar(255)),4))>=4 then substring(right(cast(sj.[last_run_time] as nvarchar(255)),4),1,2)
								 when len(right(cast(sj.[last_run_time] as nvarchar(255)),4))=3  then substring(right(cast(sj.[last_run_time] as nvarchar(255)),4),1,1)
								 else 0
							end,
							right(cast(sj.[last_run_duration] as nvarchar(255)),2),
							0
						)
		else NULL
	   end as LastDateTime
       ,case when len(cast(sj.[last_run_duration] as nvarchar(255)))>5 then substring(cast(sj.[last_run_duration] as nvarchar(255)),1,len(cast(sj.[last_run_duration] as nvarchar(255)))-4)
		    when len(cast(sj.[last_run_duration] as nvarchar(255)))=5 then '0'+substring(cast(sj.[last_run_duration] as nvarchar(255)),1,len(cast(sj.[last_run_duration] as nvarchar(255)))-4)
		    else '00'
	   end
	   +':'
	   +case when len(cast(sj.[last_run_duration] as nvarchar(255)))>=4 then substring(right(cast(sj.[last_run_duration] as nvarchar(255)),4),1,2)
			 when len(cast(sj.[last_run_duration] as nvarchar(255)))=3  then '0'+substring(right(cast(sj.[last_run_duration] as nvarchar(255)),4),1,1)
			 else '00'
	   end
	   +':'
	   +case when len(cast(sj.[last_run_duration] as nvarchar(255)))>=2 then substring(right(cast(sj.[last_run_duration] as nvarchar(255)),2),1,2)
			 when len(cast(sj.[last_run_duration] as nvarchar(255)))=2  then '0'+substring(right(cast(sj.[last_run_duration] as nvarchar(255)),2),1,1)
			 else '00'
	   end as [LastRunDurationString]
	  ,sj.last_run_duration as LastRunDurationInt
	  ,sj.[last_outcome_message] as LastOutcomeMessage
	  ,j.enabled as [Enabled]
	  ,sj.[trg_server] as [TargetServer]
  FROM [inf].[vJobServers] as sj
  inner join [inf].[vJOBS] as j on j.job_id=sj.job_id




GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Update extended property [MS_Description] on view [inf].[vJobRunShortInfo]
--
EXEC sys.sp_updateextendedproperty N'MS_Description', N'Summary of the latest tasks of the MS SQL Server Instance Agent jobs', 'SCHEMA', N'inf', 'VIEW', N'vJobRunShortInfo'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [zabbix].[GetJobAgentProblemCount]
--
GO




-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER PROCEDURE [zabbix].[GetJobAgentProblemCount]
	@run_minutes int = 30 --максимальное время работы задания Агента
AS
BEGIN
	/*
		Количество проблемных заданий Агента (завершившиеся с ошибкой за последние 24 часа или которые выполняются на текущий момент времени более установленных минут)
	*/

	--SET QUERY_GOVERNOR_COST_LIMIT 0;
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	SET XACT_ABORT ON;

	if(@run_minutes<60) set @run_minutes=60;

	;with tbl as (
		SELECT [Job_GUID]
		      ,[Job_Name]
		  FROM [inf].[vJobStepRunShortInfo]
		  where ([LastRunOutcome]<>1 or [LastRunOutcomeStep]<>1)
			 and [LastDateTime]>=DateAdd(day,-1,GetDate())
			 and [LastDateTimeStep]>=DateAdd(day,-1,GetDate())
		union all
		select [job_id]
			  ,[name]
		from [inf].[vJobActivity]
		where [start_execution_date]<=DateAdd(minute, -@run_minutes, GetDate())
	)
	select count(*) as [count]
	from tbl;
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter view [inf].[vIndexesUser]
--
GO

ALTER view [inf].[vIndexesUser] as
-- Пользовательские индексы
SELECT  cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)) AS ServerName ,
        DB_NAME() AS DB_Name ,
        obj.Name AS TableName ,
        i.Name AS IndexName ,
		i.Filter_Definition,
		STUFF(
				(
					SELECT N', [' + [name] +N'] '+case ic.[is_descending_key] when 0 then N'ASC' when 1 then N'DESC' end FROM sys.index_columns ic
								   INNER JOIN sys.columns c on c.[object_id] = obj.[object_id] and ic.[column_id] = c.[column_id]
					WHERE ic.[object_id] = obj.[object_id]
					  and ic.[index_id]=i.[index_id]
					  and ic.[is_included_column]=0
					order by ic.[key_ordinal] asc
					FOR XML PATH(''),TYPE
				).value('.','NVARCHAR(MAX)'),1,2,''
			  ) as [Columns],
		STUFF(
				(
					SELECT N', [' + [name] +N']' FROM sys.index_columns ic
								   INNER JOIN sys.columns c on c.[object_id] = obj.[object_id] and ic.[column_id] = c.[column_id]
					WHERE ic.[object_id] = obj.[object_id]
					  and ic.[index_id]=i.[index_id]
					  and ic.[is_included_column]=1
					order by ic.[key_ordinal] asc
					FOR XML PATH(''),TYPE
				).value('.','NVARCHAR(MAX)'),1,2,''
			  ) as [IncludeColumns]
FROM    sys.objects obj
        INNER JOIN sys.indexes i ON obj.[object_id] = i.[object_id]
WHERE   obj.[Type] = 'U' -- User table 
        AND LEFT(i.Name, 1) <> '_' -- Remove hypothetical indexes 
--ORDER BY o.NAME ,
--        i.name; 
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [srv].[AutoDefragIndex]
--
GO
ALTER PROCEDURE [srv].[AutoDefragIndex]
	@count int=null --кол-во одновременно обрабатываемых индексов
	,@isrebuild bit=0 --позволять ли перестраиваться индексам (фрагментация которых свыше 30%)
	,@isclear bit=1 --очистить обработанные индексы (т е заново оптимизировать индексы)
AS
BEGIN
	/*
		оптимизация индексов
	*/
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	if(@isclear=1)
	begin
		delete from [FortisAdmin].[srv].[ListDefragIndex]
		where [db_id]=DB_ID();
	end

	--определяем возможность перестраивать индекс в режиме ONLINE
	declare @isRebuildOnline bit=CASE WHEN (CAST (SERVERPROPERTY ('Edition') AS nvarchar (max)) LIKE '%Enterprise%' OR CAST (SERVERPROPERTY ('Edition') AS nvarchar (max)) LIKE '%Developer%' OR CAST (SERVERPROPERTY ('Edition') AS nvarchar (max)) LIKE '%Evaluation%') THEN 1 ELSE 0 END;

	declare @IndexName		nvarchar(255)
			,@db			nvarchar(255)
			,@db_id			int
			,@Shema			nvarchar(255)
			,@Table			nvarchar(255)
			,@SQL_Str		nvarchar (max)=N''
			,@frag			decimal(6,2)
			,@frag_after	decimal(6,2)
			,@frag_num		int
			,@page			int
			,@ts			datetime
			,@tsg			datetime
			,@tf			datetime
			,@object_id		int
			,@idx			int
			,@rec			int;

	--для обработки
	declare @tbl table (
						IndexName		nvarchar(255)
						,db				nvarchar(255)
						,[db_id]		int
						,Shema			nvarchar(255)
						,[Table]		nvarchar(255)
						,frag			decimal(6,2)
						,frag_num		int
						,[page]			int
						,[object_id]	int
						,idx			int
						,rec			int
					   );

	--для истории
	declare @tbl_copy table (
						IndexName		nvarchar(255)
						,db				nvarchar(255)
						,[db_id]		int
						,Shema			nvarchar(255)
						,[Table]		nvarchar(255)
						,frag			decimal(6,2)
						,frag_num		int
						,[page]			int
						,[object_id]	int
						,idx			int
						,rec			int
					   );

	set @ts = getdate()
	set @tsg = @ts;
	
	--выбираем индексы, которые фрагментированы не менее, чем на 10%
	--и которые еще не выбирались
	if(@count is null)
	begin
		insert into @tbl (
						IndexName	
						,db			
						,[db_id]	
						,Shema		
						,[Table]		
						,frag		
						,frag_num	
						,[page]				
						,[object_id]
						,idx		
						,rec		
					 )
		select				ind.index_name,
							ind.db,
							ind.database_id,
							ind.shema,
							ind.tb,
							ind.frag,
							ind.frag_num,
							ind.[page],
							ind.[object_id],
							ind.idx ,
							ind.rec
		from  [inf].[vIndexDefrag] as ind
		where not exists(
							select top(1) 1 from [FortisAdmin].[srv].[ListDefragIndex] as lind
							where lind.[db_id]=ind.database_id
							  and lind.[idx]=ind.idx
							  and lind.[object_id]=ind.[object_id]
						)
		--order by ind.[page] desc, ind.[frag] desc
	end
	else
	begin
		insert into @tbl (
						IndexName	
						,db			
						,[db_id]	
						,Shema		
						,[Table]		
						,frag		
						,frag_num	
						,[page]				
						,[object_id]
						,idx		
						,rec		
					 )
		select top (@count)
							ind.index_name,
							ind.db,
							ind.database_id,
							ind.shema,
							ind.tb,
							ind.frag,
							ind.frag_num,
							ind.[page],
							ind.[object_id],
							ind.idx ,
							ind.rec
		from  [inf].[vIndexDefrag] as ind
		where not exists(
							select top(1) 1 from [FortisAdmin].[srv].[ListDefragIndex] as lind
							where lind.[db_id]=ind.database_id
							  and lind.[idx]=ind.idx
							  and lind.[object_id]=ind.[object_id]
						)
		--order by ind.[page] desc, ind.[frag] desc
	end
	
	--если все индексы выбирались (т е выборка пуста)
	--то очищаем таблицу обработанных индексов
	--и начинаем заново
	if(not exists(select top(1) 1 from @tbl))
	begin
		delete from [FortisAdmin].[srv].[ListDefragIndex]
		where [db_id]=DB_ID();

		if(@count is null)
		begin
			insert into @tbl (
							IndexName	
							,db			
							,[db_id]	
							,Shema		
							,[Table]		
							,frag		
							,frag_num	
							,[page]				
							,[object_id]
							,idx		
							,rec		
						 )
			select				ind.index_name,
								ind.db,
								ind.database_id,
								ind.shema,
								ind.tb,
								ind.frag,
								ind.frag_num,
								ind.[page],
								ind.[object_id],
								ind.idx ,
								ind.rec
			from  [inf].[vIndexDefrag] as ind
			where not exists(
								select top(1) 1 from [FortisAdmin].[srv].[ListDefragIndex] as lind
								where lind.[db_id]=ind.database_id
								  and lind.[idx]=ind.idx
								  and lind.[object_id]=ind.[object_id]
							)
			--order by ind.[page] desc, ind.[frag] desc
		end
		else
		begin
			insert into @tbl (
							IndexName	
							,db			
							,[db_id]	
							,Shema		
							,[Table]		
							,frag		
							,frag_num	
							,[page]				
							,[object_id]
							,idx		
							,rec		
						 )
			select top (@count)
								ind.index_name,
								ind.db,
								ind.database_id,
								ind.shema,
								ind.tb,
								ind.frag,
								ind.frag_num,
								ind.[page],
								ind.[object_id],
								ind.idx ,
								ind.rec
			from  [inf].[vIndexDefrag] as ind
			where not exists(
								select top(1) 1 from [FortisAdmin].[srv].[ListDefragIndex] as lind
								where lind.[db_id]=ind.database_id
								  and lind.[idx]=ind.idx
								  and lind.[object_id]=ind.[object_id]
							)
			--order by ind.[page] desc, ind.[frag] desc
		end
	end

	--если выборка не пустая
	if(exists(select top(1) 1 from @tbl))
	begin
		--запоминаем выбранные индексы
		INSERT INTO [FortisAdmin].[srv].[ListDefragIndex]
		       (
				 [db]
				,[shema]
				,[table]
				,[IndexName]
				,[object_id]
				,[idx]
				,[db_id]
				,[frag]
			   )
		select	 [db]
				,[shema]
				,[table]
				,[IndexName]
				,[object_id]
				,[idx]
				,[db_id]
				,[frag]
		from @tbl;

		insert into @tbl_copy (
						IndexName	
						,db			
						,[db_id]	
						,Shema		
						,[Table]	
						,frag		
						,frag_num	
						,[page]			
						,[object_id]
						,idx		
						,rec		
					 )
		select			IndexName	
						,db			
						,[db_id]	
						,Shema		
						,[Table]	
						,frag			
						,frag_num	
						,[page]				
						,[object_id]
						,idx		
						,rec	
		from @tbl;
		
		DECLARE sql_cursor CURSOR LOCAL FOR
		select replace([IndexName], N']', N']]'),
			   replace([Shema], N']', N']]'),
			   replace([Table], N']', N']]')
		from @tbl;
		
		OPEN sql_cursor;
		  
		FETCH NEXT FROM sql_cursor   
		INTO @IndexName, @Shema, @Table;
		
		--формируем запрос на оптимизацию выбранных индексов (в случае реорганизации-с последующим обновлением статистики по ним)
		while (@@FETCH_STATUS = 0)
		begin
			if(@frag>=30 and @isrebuild=1 and @isRebuildOnline=1)
			begin
				set @SQL_Str = @SQL_Str+'begin try SET LOCK_TIMEOUT 4000;  ALTER INDEX ['+@IndexName+'] on ['+@Shema+'].['+@Table+'] REBUILD WITH(ONLINE=ON); end try begin catch print 0; end catch '
			end
			else
			begin
				set @SQL_Str = @SQL_Str+'begin try SET LOCK_TIMEOUT 4000;  ALTER INDEX ['+@IndexName+'] on ['+@Shema+'].['+@Table+'] REORGANIZE;'
									   +'UPDATE STATISTICS ['+@Shema+'].['+@Table+'] ['+@IndexName+']; end try begin catch print 0; end catch ';
			end

			FETCH NEXT FROM sql_cursor   
			INTO @IndexName, @Shema, @Table;
		end

		CLOSE sql_cursor;
		DEALLOCATE sql_cursor;

		--оптимизируем выбранные индексы
		execute sp_executesql  @SQL_Str;

		--записываем результат оптимизации индексов
		insert into [FortisAdmin].srv.Defrag(
									[db],
									[shema],
									[table],
									[IndexName],
									[frag_num],
									[frag],
									[page],
									ts,
									tf,
									frag_after,
									[object_id],
									idx,
									rec
								  )
						select
									[db],
									[shema],
									[table],
									[IndexName],
									[frag_num],
									[frag],
									[page],
									@ts,
									getdate(),
									(SELECT top(1) avg_fragmentation_in_percent
									FROM sys.dm_db_index_physical_stats
										(DB_ID([db]), [object_id], [idx], NULL ,
										N'LIMITED')
									where index_level = 0) as frag_after,
									[object_id],
									[idx],
									[rec]
						from	@tbl_copy;
	end
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter view [inf].[vIdentityColumns]
--
GO

ALTER view [inf].[vIdentityColumns] as
--Колонки identity
SELECT  cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)) AS ServerName ,
        DB_NAME() AS DBName ,
        OBJECT_SCHEMA_NAME(object_id) AS SchemaName ,
        OBJECT_NAME(object_id) AS TableName ,
        Column_id ,
        Name AS  IdentityColumn ,
        Seed_Value ,
        Last_Value
FROM    sys.identity_columns
--ORDER BY SchemaName ,
--        TableName ,
--        Column_id; 


GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter view [inf].[vHeaps]
--
GO

ALTER view [inf].[vHeaps] as
-- Кучи + количество записей

SELECT  cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)) AS [Server] ,
        DB_NAME() AS DBName ,
        OBJECT_SCHEMA_NAME(ddps.object_id) AS SchemaName ,
        OBJECT_NAME(ddps.object_id) AS TableName ,
        i.Type_Desc ,
        SUM(ddps.row_count) AS Rows
FROM    sys.dm_db_partition_stats AS ddps
        JOIN sys.indexes i ON i.object_id = ddps.object_id
                              AND i.index_id = ddps.index_id
WHERE   i.type_desc = 'HEAP'
        AND OBJECT_SCHEMA_NAME(ddps.object_id) <> 'sys'
GROUP BY ddps.object_id ,
        i.type_desc
--ORDER BY TableName;
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter view [inf].[vFuncs]
--
GO

ALTER view [inf].[vFuncs] as
-- Дополнительная информация о функциях

SELECT  cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)) AS ServerName ,
        DB_NAME() AS DB_Name ,
        o.name AS 'FunctionName' ,
        o.[type] ,
        o.create_date ,
        sm.[DEFINITION] AS 'Function script'
FROM    sys.objects o
        INNER JOIN sys.sql_modules sm ON o.object_id = sm.OBJECT_ID
WHERE   o.[Type] in ('FN', 'AF', 'FS', 'FT', 'IF', 'TF') -- Function 
--ORDER BY o.NAME;



GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on view [inf].[vDisk]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Данные о размерах всей емкости и свободного места по логическим дискам', 'SCHEMA', N'inf', 'VIEW', N'vDisk'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter view [inf].[vDefaultsConstraints]
--
GO


ALTER view [inf].[vDefaultsConstraints] as
-- Column Defaults 

SELECT  cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)) AS ServerName ,
        DB_NAME() AS DB_Name ,
        OBJECT_SCHEMA_NAME(t.object_id) AS SchemaName ,
        t.Name AS TableName ,
        c.Column_ID AS Column_NBR ,
        c.Name AS Column_Name ,
        OBJECT_NAME(default_object_id) AS DefaultName ,
        OBJECT_DEFINITION(default_object_id) AS Defaults,
        dc.[type] ,
        dc.type_desc ,
        dc.create_date
FROM    sys.tables t
        INNER JOIN sys.columns c ON t.object_id = c.object_id
		inner join sys.default_constraints as dc on dc.object_id=c.default_object_id
WHERE    default_object_id <> 0
--ORDER BY TableName ,
--        SchemaName ,
--        c.Column_ID 


GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter view [inf].[vDBFileInfo]
--
GO

ALTER view [inf].[vDBFileInfo] as
--информация о файлах БД
SELECT  cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)) AS [Server] ,
        DB_NAME() AS DB_Name ,
        File_id ,
        Type_desc ,
        Name ,
        LEFT(Physical_Name, 1) AS Drive ,
        Physical_Name ,
        RIGHT(physical_name, 3) AS Ext ,
        Size ,
        Growth
FROM    sys.database_files
--ORDER BY File_id; 


GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter view [inf].[vCountRows]
--
GO
ALTER view [inf].[vCountRows] as
	-- Метод получения количества записей с использованием DMV dm_db_partition_stats 
	SELECT  cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)) AS ServerName ,
	        DB_NAME() AS DBName ,
	        OBJECT_SCHEMA_NAME(ddps.object_id) AS SchemaName ,
	        OBJECT_NAME(ddps.object_id) AS TableName ,
	        i.Type_Desc ,
	        i.Name AS IndexUsedForCounts ,
	        SUM(ddps.row_count) AS Rows
	FROM    sys.dm_db_partition_stats ddps
	        JOIN sys.indexes i ON i.object_id = ddps.object_id
	                              AND i.index_id = ddps.index_id
	WHERE   i.type_desc IN ( 'CLUSTERED', 'HEAP' )
	                              -- This is key (1 index per table) 
	        AND OBJECT_SCHEMA_NAME(ddps.object_id) <> 'sys'
	GROUP BY ddps.object_id ,
	        i.type_desc ,
	        i.Name
	--ORDER BY SchemaName ,
	--        TableName;

GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter view [inf].[vComputedColumns]
--
GO



ALTER view [inf].[vComputedColumns] as
-- Вычисляемые столбцы

SELECT  cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)) AS ServerName ,
        DB_NAME() AS DBName ,
        OBJECT_SCHEMA_NAME(t.object_id) AS SchemaName ,
        OBJECT_NAME(t.object_id) AS Tablename ,
        t.Column_id ,
        t.Name AS  Computed_Column ,
        t.[Definition] ,
        t.is_persisted 
FROM    sys.computed_columns as t
--ORDER BY SchemaName ,
--        Tablename ,
--        [Definition];




GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter view [inf].[vColumnsStatisticsCount]
--
GO


ALTER view [inf].[vColumnsStatisticsCount] as
-- Имена столбцов и количество повторов
-- Используется для поиска одноимённых столбцов с разными типами данных/длиной

SELECT  cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)) AS [Server] ,
        DB_NAME() AS DBName ,
        Column_Name ,
        Data_Type ,
        Numeric_Precision AS  Prec ,
        Numeric_Scale AS  Scale ,
        Character_Maximum_Length ,
        COUNT(*) AS Count
FROM     INFORMATION_SCHEMA.COLUMNS isc
        INNER JOIN  INFORMATION_SCHEMA.TABLES ist
               ON isc.table_name = ist.table_name
WHERE   Table_type = 'BASE TABLE'
GROUP BY Column_Name ,
        Data_Type ,
        Numeric_Precision ,
        Numeric_Scale ,
        Character_Maximum_Length; 

GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter view [inf].[vColumns]
--
GO

ALTER view [inf].[vColumns] as
SELECT  cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)) AS [Server] ,
        DB_NAME() AS DBName ,
        isc.Table_Name AS TableName ,
        isc.Table_Schema AS SchemaName ,
        Ordinal_Position AS  Ord ,
        Column_Name ,
        Data_Type ,
        Numeric_Precision AS  Prec ,
        Numeric_Scale AS  Scale ,
        Character_Maximum_Length AS LEN , -- -1 means MAX like Varchar(MAX) 
        Is_Nullable ,
        Column_Default ,
        Table_Type
FROM     INFORMATION_SCHEMA.COLUMNS isc
        INNER JOIN  INFORMATION_SCHEMA.TABLES ist
              ON isc.table_name = ist.table_name 
--      WHERE Table_Type = 'BASE TABLE' -- 'Base Table' or 'View' 
--ORDER BY DBName ,
--        TableName ,
--        SchemaName ,
--        Ordinal_position;


GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter view [inf].[ServerDBFileInfo]
--
GO



ALTER view [inf].[ServerDBFileInfo] as
SELECT  cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)) AS [Server] ,
        File_id ,--Идентификатор файла в базе данных. Основное значение file_id всегда равно 1
        Type_desc ,--Описание типа файла
        Name as [FileName] ,--Логическое имя файла в базе данных
        LEFT(Physical_Name, 1) AS Drive ,--Метка тома, где располагается файл БД
        Physical_Name ,--Полное имя файла в операционной системе
        RIGHT(physical_name, 3) AS Ext ,--Расширение файла
        Size as CountPage, --Текущий размер файла в страницах по 8 КБ
		round((cast(Size*8 as float))/1024,3) as SizeMb, --Размер файла в МБ
		round((cast(Size*8 as float))/1024/1024,3) as SizeGb, --Размер файла в ГБ
        case when is_percent_growth=0 then Growth*8 else 0 end as Growth, --Прирост файла в страницах по 8 КБ
		case when is_percent_growth=0 then round((cast(Growth*8 as float))/1024,3) end as GrowthMb, --Прирост файла в МБ
		case when is_percent_growth=0 then round((cast(Growth*8 as float))/1024/1024,3) end as GrowthGb, --Прирост файла в ГБ
		case when is_percent_growth=1 then Growth else 0 end as GrowthPercent, --Прирост файла в целых процентах
		is_percent_growth, --Признак процентного приращения
		database_id,
		DB_Name(database_id) as [DB_Name],
		State,--состояние файла
		state_desc as StateDesc,--описание состояния файла
		is_media_read_only as IsMediaReadOnly,--файл находится на носителе только для чтения (0-и для записи)
		is_read_only as IsReadOnly,--файл помечен как файл только для чтения (0-и записи)
		is_sparse as IsSpace,--разреженный файл
		is_name_reserved as IsNameReserved,--1 - Имя удаленного файла, доступно для использования.
		--Необходимо получить резервную копию журнала, прежде чем удастся повторно использовать имя (аргументы name или physical_name) для нового имени файла
		--0 - Имя файла, недоступно для использовани
		create_lsn as CreateLsn,--Регистрационный номер транзакции в журнале (LSN), на котором создан файл
		drop_lsn as DropLsn,--Номер LSN, с которым файл удален
		read_only_lsn as ReadOnlyLsn,--Номер LSN, на котором файловая группа, содержащая файл, изменила тип с «для чтения и записи» на «только для чтения» (самое последнее изменение)
		read_write_lsn as ReadWriteLsn,--Номер LSN, на котором файловая группа, содержащая файл, изменила тип с «только для чтения» на «для чтения и записи» (самое последнее изменение)
		differential_base_lsn as DifferentialBaseLsn,--Основа для разностных резервных копий. Экстенты данных, измененных после того, как этот номер LSN будет включен в разностную резервную копию
		differential_base_guid as DifferentialBaseGuid,--Уникальный идентификатор базовой резервной копии, на которой будет основываться разностная резервная копия
		differential_base_time as DifferentialBaseTime,--Время, соответствующее differential_base_lsn
		redo_start_lsn as RedoStartLsn,--Номер LSN, с которого должен начаться следующий накат
		--Равно NULL, за исключением случаев, когда значение аргумента state = RESTORING или значение аргумента state = RECOVERY_PENDING
		redo_start_fork_guid as RedoStartForkGuid,--Уникальный идентификатор точки вилки восстановления.
		--Значение аргумента first_fork_guid следующей восстановленной резервной копии журнала должно соответствовать этому значению. Это отражает текущее состояние контейнера
		redo_target_lsn as RedoTargetLsn,--Номер LSN, на котором накат в режиме «в сети» по данному файлу может остановиться
		--Равно NULL, за исключением случаев, когда значение аргумента state = RESTORING или значение аргумента state = RECOVERY_PENDING
		redo_target_fork_guid as RedoTargetForkGuid,--Вилка восстановления, на которой может быть восстановлен контейнер. Используется в паре с redo_target_lsn
		backup_lsn as BackupLsn--Номер LSN самых новых данных или разностная резервная копия файла
FROM    sys.master_files--database_files

GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

ALTER view [inf].[vDBFilesOperationsStat]
as
select	t2.[DB_Name] as [DBName]
			,t1.FileId 
			,t1.NumberReads
			,t1.BytesRead
			,t1.IoStallReadMS
			,t1.NumberWrites
			,t1.BytesWritten
			,t1.IoStallWriteMS 
			,t1.IoStallMS
			,t1.BytesOnDisk
			,t1.[TimeStamp]
			,(1.0 * t1.IoStallWriteMS / t1.NumberWrites) AS avg_write_stall_ms
			,(1.0 * t1.IoStallReadMS / t1.NumberReads) AS avg_read_stall_ms
			,t1.FileHandle
			,t2.[Type_desc]
			,t2.[FileName]
			,t2.[Drive]
			,t2.[Physical_Name]
			,t2.[Ext]
			,t2.[CountPage]
			,t2.[SizeMb]
			,t2.[SizeGb]
			,t2.[Growth]
			,t2.[GrowthMb]
			,t2.[GrowthGb]
			,t2.[GrowthPercent]
			,t2.[is_percent_growth]
			,t2.[database_id]
			,t2.[State]
			,t2.[StateDesc]
			,t2.[IsMediaReadOnly]
			,t2.[IsReadOnly]
			,t2.[IsSpace]
			,t2.[IsNameReserved]
			,t2.[CreateLsn]
			,t2.[DropLsn]
			,t2.[ReadOnlyLsn]
			,t2.[ReadWriteLsn]
			,t2.[DifferentialBaseLsn]
			,t2.[DifferentialBaseGuid]
			,t2.[DifferentialBaseTime]
			,t2.[RedoStartLsn]
			,t2.[RedoStartForkGuid]
			,t2.[RedoTargetLsn]
			,t2.[RedoTargetForkGuid]
			,t2.[BackupLsn]
from fn_virtualfilestats(NULL, NULL) as t1
inner join [inf].[ServerDBFileInfo] as t2 on t1.[DbId]=t2.[database_id] and t1.[FileId]=t2.[File_Id]
--order by IoStallReadMS desc
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO
--
-- Refresh view [inf].[vDBFilesOperationsStat]
--
EXEC sp_refreshview '[inf].[vDBFilesOperationsStat]'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Refresh view [srv].[vDBSizeShortStatistics]
--
EXEC sp_refreshview '[srv].[vDBSizeShortStatistics]'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create table [srv].[vLoginEnable]
--
CREATE TABLE [srv].[vLoginEnable] (
  [name] [sysname] NOT NULL,
  [type_desc] [nvarchar](60) COLLATE Latin1_General_CI_AS_KS_WS NULL
)
ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [zabbix].[GetActiveRequestDiff_MSec]
--
GO
CREATE PROCEDURE [zabbix].[GetActiveRequestDiff_MSec]
AS
BEGIN
	/*
		Максимальное время работы активных запросов в мсек по скульным входам кроме системных
	*/

	SET QUERY_GOVERNOR_COST_LIMIT 0;
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	;WITH tbl AS (
		SELECT [name]
		FROM srv.vLoginEnable
		WHERE [type_desc]=N'SQL_LOGIN'
		OR [name] IN (
			N'MONOPOLY\prd-c2wts',
			N'MONOPOLY\prd-spadmin',
			N'MONOPOLY\prd-spcontent',
			N'MONOPOLY\prd-spfarm',
			N'MONOPOLY\prd-spservices'
		)
	)
	SELECT COALESCE(MAX(DATEDIFF(MILLISECOND, ER.[start_time], GETDATE())), 0) AS Diff_MSec
	FROM tbl AS t
	INNER JOIN sys.dm_exec_sessions AS ES WITH(READUNCOMMITTED) ON ES.[login_name]=t.[name]
	INNER JOIN sys.dm_exec_requests AS ER WITH(READUNCOMMITTED) ON ES.session_id = ER.session_id
	WHERE ER.[start_time]>=0;
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [zabbix].[GetActiveRequestDiff_MSec]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Возвращает максимальное время работы активных запросов в мсек по скульным входам кроме системных', 'SCHEMA', N'zabbix', 'PROCEDURE', N'GetActiveRequestDiff_MSec'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create table [srv].[KillSessionArchive]
--
CREATE TABLE [srv].[KillSessionArchive] (
  [ID] [int] IDENTITY,
  [session_id] [smallint] NOT NULL,
  [session_login_time] [datetime] NOT NULL,
  [session_host_name] [nvarchar](128) NULL,
  [session_program_name] [nvarchar](128) NULL,
  [session_host_process_id] [int] NULL,
  [session_client_version] [int] NULL,
  [session_client_interface_name] [nvarchar](32) NULL,
  [session_security_id] [varbinary](85) NOT NULL,
  [session_login_name] [nvarchar](128) NOT NULL,
  [session_nt_domain] [nvarchar](128) NULL,
  [session_nt_user_name] [nvarchar](128) NULL,
  [session_status] [nvarchar](30) NOT NULL,
  [session_cpu_time] [int] NOT NULL,
  [session_memory_usage] [int] NOT NULL,
  [session_total_scheduled_time] [int] NOT NULL,
  [session_total_elapsed_time] [int] NOT NULL,
  [session_endpoint_id] [int] NOT NULL,
  [session_last_request_start_time] [datetime] NOT NULL,
  [session_last_request_end_time] [datetime] NULL,
  [session_reads] [bigint] NOT NULL,
  [session_writes] [bigint] NOT NULL,
  [session_logical_reads] [bigint] NOT NULL,
  [session_is_user_process] [bit] NOT NULL,
  [session_text_size] [int] NOT NULL,
  [session_language] [nvarchar](128) NULL,
  [session_date_format] [nvarchar](3) NULL,
  [session_date_first] [smallint] NOT NULL,
  [session_quoted_identifier] [bit] NOT NULL,
  [session_arithabort] [bit] NOT NULL,
  [session_ansi_null_dflt_on] [bit] NOT NULL,
  [session_ansi_defaults] [bit] NOT NULL,
  [session_ansi_warnings] [bit] NOT NULL,
  [session_ansi_padding] [bit] NOT NULL,
  [session_ansi_nulls] [bit] NOT NULL,
  [session_concat_null_yields_null] [bit] NOT NULL,
  [session_transaction_isolation_level] [smallint] NOT NULL,
  [session_lock_timeout] [int] NOT NULL,
  [session_deadlock_priority] [int] NOT NULL,
  [session_row_count] [bigint] NOT NULL,
  [session_prev_error] [int] NOT NULL,
  [session_original_security_id] [varbinary](85) NOT NULL,
  [session_original_login_name] [nvarchar](128) NOT NULL,
  [session_last_successful_logon] [datetime] NULL,
  [session_last_unsuccessful_logon] [datetime] NULL,
  [session_unsuccessful_logons] [bigint] NULL,
  [session_group_id] [int] NOT NULL,
  [session_database_id] [smallint] NOT NULL,
  [session_authenticating_database_id] [int] NULL,
  [session_open_transaction_count] [int] NOT NULL,
  [request_id] [int] NOT NULL,
  [request_start_time] [datetime] NOT NULL,
  [request_status] [nvarchar](30) NOT NULL,
  [request_command] [nvarchar](32) NOT NULL,
  [request_sql_handle] [varbinary](64) NULL,
  [request_statement_start_offset] [int] NULL,
  [request_statement_end_offset] [int] NULL,
  [request_plan_handle] [varbinary](64) NULL,
  [request_user_id] [int] NOT NULL,
  [request_connection_id] [uniqueidentifier] NULL,
  [request_blocking_session_id] [smallint] NULL,
  [request_wait_type] [nvarchar](60) NULL,
  [request_wait_time] [int] NOT NULL,
  [request_last_wait_type] [nvarchar](60) NOT NULL,
  [request_wait_resource] [nvarchar](256) NOT NULL,
  [request_open_transaction_count] [int] NOT NULL,
  [request_open_resultset_count] [int] NOT NULL,
  [request_transaction_id] [bigint] NOT NULL,
  [request_percent_complete] [real] NOT NULL,
  [request_estimated_completion_time] [bigint] NOT NULL,
  [request_cpu_time] [int] NOT NULL,
  [request_total_elapsed_time] [int] NOT NULL,
  [request_scheduler_id] [int] NULL,
  [request_task_address] [varbinary](8) NULL,
  [request_reads] [bigint] NOT NULL,
  [request_writes] [bigint] NOT NULL,
  [request_logical_reads] [bigint] NOT NULL,
  [request_text_size] [int] NOT NULL,
  [request_language] [nvarchar](128) NULL,
  [request_date_format] [nvarchar](3) NULL,
  [request_date_first] [smallint] NOT NULL,
  [request_quoted_identifier] [bit] NOT NULL,
  [request_arithabort] [bit] NOT NULL,
  [request_ansi_null_dflt_on] [bit] NOT NULL,
  [request_ansi_defaults] [bit] NOT NULL,
  [request_ansi_warnings] [bit] NOT NULL,
  [request_ansi_padding] [bit] NOT NULL,
  [request_ansi_nulls] [bit] NOT NULL,
  [request_concat_null_yields_null] [bit] NOT NULL,
  [request_transaction_isolation_level] [smallint] NOT NULL,
  [request_lock_timeout] [int] NOT NULL,
  [request_deadlock_priority] [int] NOT NULL,
  [request_row_count] [bigint] NOT NULL,
  [request_prev_error] [int] NOT NULL,
  [request_nest_level] [int] NOT NULL,
  [request_granted_query_memory] [int] NOT NULL,
  [request_executing_managed_code] [bit] NOT NULL,
  [request_group_id] [int] NOT NULL,
  [request_query_hash] [binary](8) NULL,
  [request_query_plan_hash] [binary](8) NULL,
  [request_statement_sql_handle] [varbinary](64) NULL,
  [request_statement_context_id] [bigint] NULL,
  [request_dop] [int] NULL,
  [request_parallel_worker_count] [int] NULL,
  [request_external_script_request_id] [uniqueidentifier] NULL,
  [ERROR_MESSAGE] [nvarchar](4000) NULL,
  [DBName] [nvarchar](255) NULL,
  [TSQL] [nvarchar](max) NULL,
  [QueryPlan] [xml] NULL,
  [InsertUTCDate] [datetime] NOT NULL CONSTRAINT [DF_KillSessionArchive_InsertUTCDate] DEFAULT (getutcdate()),
  CONSTRAINT [PK_KillSessionArchive] PRIMARY KEY CLUSTERED ([ID]) WITH (FILLFACTOR = 95)
)
ON [PRIMARY]
TEXTIMAGE_ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [srv].[AutoKillLongSessionUser]
--
GO


CREATE PROCEDURE [srv].[AutoKillLongSessionUser]
	@oldsec INT=10 --максимально допустимая длительность выполнения запроса от пользователей
AS
BEGIN
	/*
		автоудаление долгих запросов от пользовательских сессий через удаление самих этих сессий
	*/

	SET QUERY_GOVERNOR_COST_LIMIT 0;
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @session_id INT;
	DECLARE @sql NVARCHAR(2000);
	DECLARE @error_message NVARCHAR(4000);
	
	--собираем все сессии, в которых запущены запросы с SSMS и выполняющиеся более 10 сек
	SELECT ES.[session_id]
	      ,ES.[login_time]					as [session_login_time]
	      ,ES.[host_name]					as [session_host_name]
	      ,ES.[program_name]				as [session_program_name]
	      ,ES.[host_process_id]				as [session_host_process_id]
	      ,ES.[client_version]				as [session_client_version]
	      ,ES.[client_interface_name]		as [session_client_interface_name]
	      ,ES.[security_id]					as [session_security_id]
	      ,ES.[login_name]					as [session_login_name]
	      ,ES.[nt_domain]					as [session_nt_domain]
	      ,ES.[nt_user_name]				as [session_nt_user_name]
	      ,ES.[status]						AS [session_status]
	      ,ES.[cpu_time]					AS [session_cpu_time]
	      ,ES.[memory_usage]				as [session_memory_usage]
	      ,ES.[total_scheduled_time]		as [session_total_scheduled_time]
	      ,ES.[total_elapsed_time]			as [session_total_elapsed_time]
	      ,ES.[endpoint_id]					as [session_endpoint_id]
	      ,ES.[last_request_start_time]		as [session_last_request_start_time]
	      ,ES.[last_request_end_time]		as [session_last_request_end_time]
	      ,ES.[reads]						as [session_reads]
	      ,ES.[writes]						as [session_writes]
	      ,ES.[logical_reads]				as [session_logical_reads]
	      ,ES.[is_user_process]				as [session_is_user_process]
	      ,ES.[text_size]					as [session_text_size]
	      ,ES.[language]					as [session_language]
	      ,ES.[date_format]					as [session_date_format]
	      ,ES.[date_first]					as [session_date_first]
	      ,ES.[quoted_identifier]			as [session_quoted_identifier]
	      ,ES.[arithabort]					as [session_arithabort]
	      ,ES.[ansi_null_dflt_on]			as [session_ansi_null_dflt_on]
	      ,ES.[ansi_defaults]				as [session_ansi_defaults]
	      ,ES.[ansi_warnings]				as [session_ansi_warnings]
	      ,ES.[ansi_padding]				as [session_ansi_padding]
	      ,ES.[ansi_nulls]					as [session_ansi_nulls]
	      ,ES.[concat_null_yields_null]		as [session_concat_null_yields_null]
	      ,ES.[transaction_isolation_level]	as [session_transaction_isolation_level]
	      ,ES.[lock_timeout]				as [session_lock_timeout]
	      ,ES.[deadlock_priority]			as [session_deadlock_priority]
	      ,ES.[row_count]					as [session_row_count]
	      ,ES.[prev_error]					as [session_prev_error]
	      ,ES.[original_security_id]		as [session_original_security_id]
	      ,ES.[original_login_name]			as [session_original_login_name]
	      ,ES.[last_successful_logon]		as [session_last_successful_logon]
	      ,ES.[last_unsuccessful_logon]		as [session_last_unsuccessful_logon]
	      ,ES.[unsuccessful_logons]			as [session_unsuccessful_logons]
	      ,ES.[group_id]					as [session_group_id]
	      ,ES.[database_id]					as [session_database_id]
	      ,ES.[authenticating_database_id]	as [session_authenticating_database_id]
	      ,ES.[open_transaction_count]		AS [session_open_transaction_count]
		  ,ER.[request_id]					as [request_id]
	      ,ER.[start_time]					as [request_start_time]
	      ,ER.[status]						AS [request_status]
	      ,ER.[command]						as [request_command]
	      ,ER.[sql_handle]					as [request_sql_handle]
	      ,ER.[statement_start_offset]		as [request_statement_start_offset]
	      ,ER.[statement_end_offset]		as [request_statement_end_offset]
	      ,ER.[plan_handle]					as [request_plan_handle]
	      ,ER.[user_id]						as [request_user_id]
	      ,ER.[connection_id]				as [request_connection_id]
	      ,ER.[blocking_session_id]			as [request_blocking_session_id]
	      ,ER.[wait_type]					as [request_wait_type]
	      ,ER.[wait_time]					as [request_wait_time]
	      ,ER.[last_wait_type]				as [request_last_wait_type]
	      ,ER.[wait_resource]				as [request_wait_resource]
	      ,ER.[open_transaction_count]		as [request_open_transaction_count]
	      ,ER.[open_resultset_count]		as [request_open_resultset_count]
	      ,ER.[transaction_id]				as [request_transaction_id]
	      ,ER.[percent_complete]			as [request_percent_complete]
	      ,ER.[estimated_completion_time]	as [request_estimated_completion_time]
	      ,ER.[cpu_time]					AS [request_cpu_time]
	      ,ER.[total_elapsed_time]			as [request_total_elapsed_time]
	      ,ER.[scheduler_id]				as [request_scheduler_id]
	      ,ER.[task_address]				as [request_task_address]
	      ,ER.[reads]						as [request_reads]
	      ,ER.[writes]						as [request_writes]
	      ,ER.[logical_reads]				as [request_logical_reads]
	      ,ER.[text_size]					as [request_text_size]
	      ,ER.[language]					as [request_language]
	      ,ER.[date_format]					as [request_date_format]
	      ,ER.[date_first]					as [request_date_first]
	      ,ER.[quoted_identifier]			as [request_quoted_identifier]
	      ,ER.[arithabort]					as [request_arithabort]
	      ,ER.[ansi_null_dflt_on]			as [request_ansi_null_dflt_on]
	      ,ER.[ansi_defaults]				as [request_ansi_defaults]
	      ,ER.[ansi_warnings]				as [request_ansi_warnings]
	      ,ER.[ansi_padding]				as [request_ansi_padding]
	      ,ER.[ansi_nulls]					as [request_ansi_nulls]
	      ,ER.[concat_null_yields_null]		as [request_concat_null_yields_null]
	      ,ER.[transaction_isolation_level]	as [request_transaction_isolation_level]
	      ,ER.[lock_timeout]				as [request_lock_timeout]
	      ,ER.[deadlock_priority]			as [request_deadlock_priority]
	      ,ER.[row_count]					as [request_row_count]
	      ,ER.[prev_error]					as [request_prev_error]
	      ,ER.[nest_level]					as [request_nest_level]
	      ,ER.[granted_query_memory]		as [request_granted_query_memory]
	      ,ER.[executing_managed_code]		as [request_executing_managed_code]
	      ,ER.[group_id]					as [request_group_id]
	      ,ER.[query_hash]					as [request_query_hash]
	      ,ER.[query_plan_hash]				as [request_query_plan_hash]
	      ,ER.[statement_sql_handle]		as [request_statement_sql_handle]
	      ,ER.[statement_context_id]		as [request_statement_context_id]
	      --,ER.[dop]							as [request_dop]
	      --,ER.[parallel_worker_count]		as [request_parallel_worker_count]
	      --,ER.[external_script_request_id]	as [request_external_script_request_id]
		  ,DB_Name(coalesce(ER.[database_id], ES.[database_id])) as [DBName]
		  ,(select top(1) [text] from sys.dm_exec_sql_text(ER.[sql_handle])) as [TSQL]
		  ,(select top(1) [query_plan] from sys.dm_exec_query_plan(ER.[plan_handle])) as [QueryPlan]
		  , CAST(N'' AS NVARCHAR(4000))		AS [ERROR_MESSAGE]
	INTO #tbl
	FROM sys.dm_exec_sessions AS ES WITH(READUNCOMMITTED)
	INNER JOIN sys.dm_exec_requests AS ER WITH(READUNCOMMITTED) ON ES.[session_id]=ER.[session_id]
	WHERE ER.[start_time]<=DATEADD(SECOND, -@oldsec, GetDate())
	  AND ES.[program_name] LIKE N'Microsoft SQL Server Management Studio%';
	
	DECLARE sql_cursor CURSOR LOCAL FOR
	select [session_id]
	from #tbl;
	
	OPEN sql_cursor;
		  
	FETCH NEXT FROM sql_cursor   
	INTO @session_id;
	
	while (@@FETCH_STATUS = 0)
	BEGIN
		BEGIN TRY
			SET @sql=N'KILL '+CAST(@session_id AS NVARCHAR(255));
			EXEC sys.sp_executesql @sql;--KILL @session_id;
		END TRY
		BEGIN CATCH
			UPDATE t
			SET [error_message]=ERROR_MESSAGE()
			FROM #tbl AS t
			WHERE [session_id]=@session_id;
		END CATCH
		
		FETCH NEXT FROM sql_cursor
		INTO @session_id;
	end
	
	CLOSE sql_cursor;
	DEALLOCATE sql_cursor;
	
	INSERT INTO srv.KillSessionArchive(
										[session_id]
										,[session_login_time]
										,[session_host_name]
										,[session_program_name]
										,[session_host_process_id]
										,[session_client_version]
										,[session_client_interface_name]
										,[session_security_id]
										,[session_login_name]
										,[session_nt_domain]
										,[session_nt_user_name]
										,[session_status]
										,[session_cpu_time]
										,[session_memory_usage]
										,[session_total_scheduled_time]
										,[session_total_elapsed_time]
										,[session_endpoint_id]
										,[session_last_request_start_time]
										,[session_last_request_end_time]
										,[session_reads]
										,[session_writes]
										,[session_logical_reads]
										,[session_is_user_process]
										,[session_text_size]
										,[session_language]
										,[session_date_format]
										,[session_date_first]
										,[session_quoted_identifier]
										,[session_arithabort]
										,[session_ansi_null_dflt_on]
										,[session_ansi_defaults]
										,[session_ansi_warnings]
										,[session_ansi_padding]
										,[session_ansi_nulls]
										,[session_concat_null_yields_null]
										,[session_transaction_isolation_level]
										,[session_lock_timeout]
										,[session_deadlock_priority]
										,[session_row_count]
										,[session_prev_error]
										,[session_original_security_id]
										,[session_original_login_name]
										,[session_last_successful_logon]
										,[session_last_unsuccessful_logon]
										,[session_unsuccessful_logons]
										,[session_group_id]
										,[session_database_id]
										,[session_authenticating_database_id]
										,[session_open_transaction_count]
										,[request_id]
										,[request_start_time]
										,[request_status]
										,[request_command]
										,[request_sql_handle]
										,[request_statement_start_offset]
										,[request_statement_end_offset]
										,[request_plan_handle]
										,[request_user_id]
										,[request_connection_id]
										,[request_blocking_session_id]
										,[request_wait_type]
										,[request_wait_time]
										,[request_last_wait_type]
										,[request_wait_resource]
										,[request_open_transaction_count]
										,[request_open_resultset_count]
										,[request_transaction_id]
										,[request_percent_complete]
										,[request_estimated_completion_time]
										,[request_cpu_time]
										,[request_total_elapsed_time]
										,[request_scheduler_id]
										,[request_task_address]
										,[request_reads]
										,[request_writes]
										,[request_logical_reads]
										,[request_text_size]
										,[request_language]
										,[request_date_format]
										,[request_date_first]
										,[request_quoted_identifier]
										,[request_arithabort]
										,[request_ansi_null_dflt_on]
										,[request_ansi_defaults]
										,[request_ansi_warnings]
										,[request_ansi_padding]
										,[request_ansi_nulls]
										,[request_concat_null_yields_null]
										,[request_transaction_isolation_level]
										,[request_lock_timeout]
										,[request_deadlock_priority]
										,[request_row_count]
										,[request_prev_error]
										,[request_nest_level]
										,[request_granted_query_memory]
										,[request_executing_managed_code]
										,[request_group_id]
										,[request_query_hash]
										,[request_query_plan_hash]
										,[request_statement_sql_handle]
										,[request_statement_context_id]
										--,[request_dop]
										--,[request_parallel_worker_count]
										--,[request_external_script_request_id]
										,[DBName]
										,[TSQL]
										,[QueryPlan]
										,[ERROR_MESSAGE]							
									  )
								 SELECT [session_id]
										,[session_login_time]
										,[session_host_name]
										,[session_program_name]
										,[session_host_process_id]
										,[session_client_version]
										,[session_client_interface_name]
										,[session_security_id]
										,[session_login_name]
										,[session_nt_domain]
										,[session_nt_user_name]
										,[session_status]
										,[session_cpu_time]
										,[session_memory_usage]
										,[session_total_scheduled_time]
										,[session_total_elapsed_time]
										,[session_endpoint_id]
										,[session_last_request_start_time]
										,[session_last_request_end_time]
										,[session_reads]
										,[session_writes]
										,[session_logical_reads]
										,[session_is_user_process]
										,[session_text_size]
										,[session_language]
										,[session_date_format]
										,[session_date_first]
										,[session_quoted_identifier]
										,[session_arithabort]
										,[session_ansi_null_dflt_on]
										,[session_ansi_defaults]
										,[session_ansi_warnings]
										,[session_ansi_padding]
										,[session_ansi_nulls]
										,[session_concat_null_yields_null]
										,[session_transaction_isolation_level]
										,[session_lock_timeout]
										,[session_deadlock_priority]
										,[session_row_count]
										,[session_prev_error]
										,[session_original_security_id]
										,[session_original_login_name]
										,[session_last_successful_logon]
										,[session_last_unsuccessful_logon]
										,[session_unsuccessful_logons]
										,[session_group_id]
										,[session_database_id]
										,[session_authenticating_database_id]
										,[session_open_transaction_count]
										,[request_id]
										,[request_start_time]
										,[request_status]
										,[request_command]
										,[request_sql_handle]
										,[request_statement_start_offset]
										,[request_statement_end_offset]
										,[request_plan_handle]
										,[request_user_id]
										,[request_connection_id]
										,[request_blocking_session_id]
										,[request_wait_type]
										,[request_wait_time]
										,[request_last_wait_type]
										,[request_wait_resource]
										,[request_open_transaction_count]
										,[request_open_resultset_count]
										,[request_transaction_id]
										,[request_percent_complete]
										,[request_estimated_completion_time]
										,[request_cpu_time]
										,[request_total_elapsed_time]
										,[request_scheduler_id]
										,[request_task_address]
										,[request_reads]
										,[request_writes]
										,[request_logical_reads]
										,[request_text_size]
										,[request_language]
										,[request_date_format]
										,[request_date_first]
										,[request_quoted_identifier]
										,[request_arithabort]
										,[request_ansi_null_dflt_on]
										,[request_ansi_defaults]
										,[request_ansi_warnings]
										,[request_ansi_padding]
										,[request_ansi_nulls]
										,[request_concat_null_yields_null]
										,[request_transaction_isolation_level]
										,[request_lock_timeout]
										,[request_deadlock_priority]
										,[request_row_count]
										,[request_prev_error]
										,[request_nest_level]
										,[request_granted_query_memory]
										,[request_executing_managed_code]
										,[request_group_id]
										,[request_query_hash]
										,[request_query_plan_hash]
										,[request_statement_sql_handle]
										,[request_statement_context_id]
										--,[request_dop]
										--,[request_parallel_worker_count]
										--,[request_external_script_request_id]
										,[DBName]
										,[TSQL]
										,[QueryPlan]
										,[ERROR_MESSAGE]
	FROM #tbl;
	
	DROP TABLE #tbl;
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [srv].[AutoKillLongSessionUser]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Автоудаление долгих запросов от пользовательских сессий через удаление самих этих сессий', 'SCHEMA', N'srv', 'PROCEDURE', N'AutoKillLongSessionUser'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on table [srv].[WaitsStatistics]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Статистика типов ожиданий по всей СУБД', 'SCHEMA', N'srv', 'TABLE', N'WaitsStatistics'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [srv].[AutoWaitStatistics]
--
GO
ALTER PROCEDURE [srv].[AutoWaitStatistics]
AS
BEGIN
	/*
		Сбор данных по ожиданиям MS SQL Server
	*/
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	declare @servername nvarchar(255)=cast(SERVERPROPERTY(N'MachineName') as nvarchar(255));

	INSERT INTO [srv].[WaitsStatistics]
           ([Server]
           ,[WaitType]
           ,[Wait_S]
           ,[Resource_S]
           ,[Signal_S]
           ,[WaitCount]
           ,[Percentage]
           ,[AvgWait_S]
           ,[AvgRes_S]
           ,[AvgSig_S])
	 SELECT @servername AS [Server]
           ,[WaitType]
           ,[Wait_S]
           ,[Resource_S]
           ,[Signal_S]
           ,[WaitCount]
           ,[Percentage]
           ,[AvgWait_S]
           ,[AvgRes_S]
           ,[AvgSig_S]
	 FROM [inf].[vWaits];
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indClustered] from table [srv].[TSQL_DAY_Statistics]
--
DROP INDEX [indClustered] ON [srv].[TSQL_DAY_Statistics]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indDATE] from table [srv].[TSQL_DAY_Statistics]
--
DROP INDEX [indDATE] ON [srv].[TSQL_DAY_Statistics]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indClustered] on table [srv].[TSQL_DAY_Statistics]
--
CREATE CLUSTERED INDEX [indClustered]
  ON [srv].[TSQL_DAY_Statistics] ([PlanHandle], [SqlHandle], [DATE])
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indDATE] on table [srv].[TSQL_DAY_Statistics]
--
CREATE INDEX [indDATE]
  ON [srv].[TSQL_DAY_Statistics] ([DATE])
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [srv].[InsertTableStatistics]
--
GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER     PROCEDURE [srv].[InsertTableStatistics]
AS
BEGIN
	/*
		собирает кол-во строк в каждой таблице по кластерным индексам (примерное кол-во)+размеры таблиц
	*/
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	declare @dt date=CAST(GetUTCDate() as date);
    declare @dbs nvarchar(255);
	declare @sql nvarchar(max);

	select [name]
	into #dbs3
	from [master].sys.databases;

	while(exists(select top(1) 1 from #dbs3))
	begin
		select top(1)
		@dbs=[name]
		from #dbs3;

		set @sql=
		N'USE ['+@dbs+']; '
		+N'IF(object_id('+N''''+N'[inf].[vCountRows]'+N''''+N') is not null) BEGIN '
		+N'insert into [FortisAdmin].[srv].[TableIndexStatistics]
	         ([ServerName]
				   ,[DBName]
		           ,[SchemaName]
		           ,[TableName]
		           ,[IndexUsedForCounts]
		           ,[CountRows])
		SELECT [ServerName]
			  ,[DBName]
		      ,[SchemaName]
		      ,[TableName]
		      ,[IndexUsedForCounts]
		      ,[Rows]
		  FROM [inf].[vCountRows]
		  where [Type_Desc]='+''''+'CLUSTERED'+''''+'; END';

		exec sp_executesql @sql;

		delete from #dbs3
		where [name]=@dbs;
	end

	select [name]
	into #dbs
	from sys.databases;

	while(exists(select top(1) 1 from #dbs))
	begin
		select top(1)
		@dbs=[name]
		from #dbs;

		set @sql=
		N'USE ['+@dbs+']; '
		+N'IF(object_id('+N''''+N'[inf].[vTableSize]'+N''''+N') is not null) BEGIN '
		+N'INSERT INTO [FortisAdmin].[srv].[TableStatistics]
	         ([ServerName]
			   ,[DBName]
	         ,[SchemaName]
	         ,[TableName]
	         ,[CountRows]
	         ,[DataKB]
	         ,[IndexSizeKB]
	         ,[UnusedKB]
	         ,[ReservedKB]
			 ,[TotalPageSizeKB]
			 ,[UsedPageSizeKB]
			 ,[DataPageSizeKB])
	   SELECT [Server]
		  ,[DBName]
	         ,[SchemaName]
	         ,[TableName]
	         ,[CountRows]
	         ,[DataKB]
	         ,[IndexSizeKB]
	         ,[UnusedKB]
	         ,[ReservedKB]
			 ,[TotalPageSizeKB]
			 ,[UsedPageSizeKB]
			 ,[DataPageSizeKB]
		FROM ['+@dbs+'].[inf].[vTableSize]; END';

		exec sp_executesql @sql;

		delete from #dbs
		where [name]=@dbs;
	end

	drop table #dbs;
	drop table #dbs3;

	declare @dt_back date=CAST(DateAdd(day,-1,@dt) as date);

	;with tbl1 as (
		select [Date], 
			   [CountRows],
			   [DataKB],
			   [IndexSizeKB],
			   [UnusedKB],
			   [ReservedKB],
			   [ServerName], 
			   [DBName], 
			   [SchemaName], 
			   [TableName],
			   [TotalPageSizeKB],
			   [UsedPageSizeKB],
			   [DataPageSizeKB]
		from [srv].[TableStatistics]
		where [Date]=@dt_back
	)
	, tbl2 as (
		select [Date], 
			   [CountRows], 
			   [CountRowsBack],
			   [DataKBBack],
			   [IndexSizeKBBack],
			   [UnusedKBBack],
			   [ReservedKBBack],
			   [ServerName], 
			   [DBName], 
			   [SchemaName], 
			   [TableName],
			   [TotalPageSizeKBBack],
			   [UsedPageSizeKBBack],
			   [DataPageSizeKBBack]
		from [srv].[TableStatistics]
		where [Date]=@dt
	)
	update t2
	set t2.[CountRowsBack]		=t1.[CountRows],
		t2.[DataKBBack]			=t1.[DataKB],
		t2.[IndexSizeKBBack]	=t1.[IndexSizeKB],
		t2.[UnusedKBBack]		=t1.[UnusedKB],
		t2.[ReservedKBBack]		=t1.[ReservedKB],
		t2.[TotalPageSizeKBBack]=t1.[TotalPageSizeKB],
		t2.[UsedPageSizeKBBack]	=t1.[UsedPageSizeKB],
		t2.[DataPageSizeKBBack]	=t1.[DataPageSizeKB]
	from tbl1 as t1
	inner join tbl2 as t2 on t1.[Date]=DateAdd(day,-1,t2.[Date])
	and t1.[ServerName]=t2.[ServerName]
	and t1.[DBName]=t2.[DBName]
	and t1.[SchemaName]=t2.[SchemaName]
	and t1.[TableName]=t2.[TableName];

	;with tbl1 as (
		select [Date], 
			   [CountRows], 
			   [CountRowsNext],
			   [DataKBNext],
			   [IndexSizeKBNext],
			   [UnusedKBNext],
			   [ReservedKBNext],
			   [ServerName], 
			   [DBName], 
			   [SchemaName], 
			   [TableName],
			   [TotalPageSizeKBNext],
			   [UsedPageSizeKBNext],
			   [DataPageSizeKBNext]
		from [srv].[TableStatistics]
		where [Date]=@dt_back
	)
	, tbl2 as (
		select [Date], 
			   [CountRows],
			   [DataKB],
			   [IndexSizeKB],
			   [UnusedKB],
			   [ReservedKB],
			   [ServerName], 
			   [DBName], 
			   [SchemaName], 
			   [TableName],
			   [TotalPageSizeKB],
			   [UsedPageSizeKB],
			   [DataPageSizeKB]
		from [srv].[TableStatistics]
		where [Date]=@dt
	)
	update t1
	set t1.[CountRowsNext]		=t2.[CountRows],
		t1.[DataKBNext]			=t2.[DataKB],
		t1.[IndexSizeKBNext]	=t2.[IndexSizeKB],
		t1.[UnusedKBNext]		=t2.[UnusedKB],
		t1.[ReservedKBNext]		=t2.[ReservedKB],
		t1.[TotalPageSizeKBNext]=t2.[TotalPageSizeKB],
		t1.[UsedPageSizeKBNext]	=t2.[UsedPageSizeKB],
		t1.[DataPageSizeKBNext]	=t2.[DataPageSizeKB]
	from tbl1 as t1
	inner join tbl2 as t2 on t1.[Date]=DateAdd(day,-1,t2.[Date])
	and t1.[ServerName]=t2.[ServerName]
	and t1.[DBName]=t2.[DBName]
	and t1.[SchemaName]=t2.[SchemaName]
	and t1.[TableName]=t2.[TableName];
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on table [srv].[StatisticsIOInTempDBStatistics]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Статистика по IO на файлы БД', 'SCHEMA', N'srv', 'TABLE', N'StatisticsIOInTempDBStatistics'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [srv].[AutoStatisticsIOInTempDBStatistics]
--
GO


-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER   PROCEDURE [srv].[AutoStatisticsIOInTempDBStatistics]
AS
BEGIN
	/*
		Сбор данных по нагрузке на файлы данных БД tempdb MS SQL Server
	*/
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	declare @servername nvarchar(255)=cast(SERVERPROPERTY(N'MachineName') as nvarchar(255));

	INSERT INTO [srv].[StatisticsIOInTempDBStatistics]
           ([Server]
           ,[physical_name]
           ,[name]
           ,[num_of_writes]
           ,[avg_write_stall_ms]
           ,[num_of_reads]
           ,[avg_read_stall_ms])
	SELECT @servername AS [ServerName]
		  ,[physical_name]
          ,[name]
          ,[num_of_writes]
          ,[avg_write_stall_ms]
          ,[num_of_reads]
          ,[avg_read_stall_ms]
	FROM [srv].[vStatisticsIOInTempDB];
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indInsertUTCDate] from table [srv].[SQLQuery]
--
DROP INDEX [indInsertUTCDate] ON [srv].[SQLQuery]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop primary key [PK_SQLQuery] on table [srv].[SQLQuery]
--
ALTER TABLE [srv].[SQLQuery]
  DROP CONSTRAINT [PK_SQLQuery]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create primary key [PK_SQLQuery] on table [srv].[SQLQuery]
--
ALTER TABLE [srv].[SQLQuery]
  ADD CONSTRAINT [PK_SQLQuery] PRIMARY KEY CLUSTERED ([SQLHandle]) WITH (FILLFACTOR = 95)
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indInsertUTCDate] on table [srv].[SQLQuery]
--
CREATE INDEX [indInsertUTCDate]
  ON [srv].[SQLQuery] ([InsertUTCDate])
  WITH (FILLFACTOR = 95)
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop procedure [srv].[GetHTMLTableShortInfoRunJobsServers]
--
DROP PROCEDURE [srv].[GetHTMLTableShortInfoRunJobsServers]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [srv].[GetHTMLTableShortInfoRunJobsServers]
--
GO

-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE   PROCEDURE [srv].[GetHTMLTableShortInfoRunJobsServers]
	@Path nvarchar(255),
	@Filename nvarchar(255),
	@second int=60
AS
BEGIN
	/*
		формирует HTML-код для таблицы выполненных заданий
	*/
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	declare @servername nvarchar(255)=cast(SERVERPROPERTY(N'MachineName') as nvarchar(255));

	DECLARE  @objFileSystem int
        ,@objTextStream int,
		@objErrorObject int,
		@strErrorMessage nvarchar(1000),
	    @Command nvarchar(1000),
	    @hr int,
		@fileAndPath varchar(80);

	select @strErrorMessage='opening the File System Object'
	EXECUTE @hr = sp_OACreate  'Scripting.FileSystemObject' , @objFileSystem OUT
	
	Select @FileAndPath=@path+'\'+@filename
	if @HR=0 Select @objErrorObject=@objFileSystem , @strErrorMessage='Creating file "'+@FileAndPath+'"'
	if @HR=0 execute @hr = sp_OAMethod   @objFileSystem   , 'CreateTextFile'
	, @objTextStream OUT, @FileAndPath,2,True

	if @HR=0 Select @objErrorObject=@objTextStream, 
	@strErrorMessage='writing to the file "'+@FileAndPath+'"'

	declare @body nvarchar(max);

	declare @tbl table (
						Job_GUID				uniqueidentifier
						,Job_Name				nvarchar(255)
						,LastFinishRunState		nvarchar(255)
						,LastDateTime			datetime
						,LastRunDurationString	nvarchar(255)
						,LastOutcomeMessage		nvarchar(max)
						,[Server]				nvarchar(255)
						,ID						int identity(1,1)
					   );

	declare
	@Job_GUID				uniqueidentifier
	,@Job_Name				nvarchar(255)
	,@LastFinishRunState	nvarchar(255)
	,@LastDateTime			datetime
	,@LastRunDurationString	nvarchar(255)
	,@LastOutcomeMessage	nvarchar(max)
	,@Server				nvarchar(255)
	,@ID					int;

	insert into @tbl(
						Job_GUID
						,Job_Name
						,LastFinishRunState
						,LastDateTime
						,LastRunDurationString
						,LastOutcomeMessage
						,[Server]
					)
			select		Job_GUID
						,Job_Name
						,LastFinishRunState
						,LastDateTime
						,LastRunDurationString
						,LastOutcomeMessage
						,[Server]
			from	srv.ShortInfoRunJobsServers
			where [InsertUTCDate]>=DateAdd(day,-1,GetUTCDate())
			order by [Server] asc, LastRunDurationInt desc;

	if(exists(select top(1) 1 from @tbl))
	begin
		set @body='В ходе анализа последних выполнений заданий, были выявлены следующие задания, которые либо с ошибочным завершением, '
				 +'либо выполнились по времени более '+cast(@second as nvarchar(255))+' секунд:<br><br>'+'<TABLE BORDER=5>';

		set @body=@body+'<TR>';

		set @body=@body+'<TD>';
		set @body=@body+'№ п/п';
		set @body=@body+'</TD>';
	
		set @body=@body+'<TD>';
		set @body=@body+'СЕРВЕР';
		set @body=@body+'</TD>';

		set @body=@body+'<TD>';
		set @body=@body+'ЗАДАНИЕ';
		set @body=@body+'</TD>';
	
		set @body=@body+'<TD>';
		set @body=@body+'СТАТУС';
		set @body=@body+'</TD>';

		set @body=@body+'<TD>';
		set @body=@body+'ДАТА И ВРЕМЯ';
		set @body=@body+'</TD>';

		set @body=@body+'<TD>';
		set @body=@body+'ДЛИТЕЛЬНОСТЬ';
		set @body=@body+'</TD>';

		set @body=@body+'<TD>';
		set @body=@body+'СООБЩЕНИЕ';
		set @body=@body+'</TD>';

		set @body=@body+'</TR>';

		if @HR=0 execute @hr = sp_OAMethod  @objTextStream, 'Write', Null, @body;

		set @body='';

		DECLARE sql_cursor CURSOR LOCAL FOR
		select Job_GUID
			  ,Job_Name
			  ,LastFinishRunState
			  ,LastDateTime
			  ,LastRunDurationString
			  ,LastOutcomeMessage
			  ,[Server]
		from @tbl;
		
		OPEN sql_cursor;
		  
		FETCH NEXT FROM sql_cursor   
		INTO @Job_GUID
			  ,@Job_Name
			  ,@LastFinishRunState
			  ,@LastDateTime
			  ,@LastRunDurationString
			  ,@LastOutcomeMessage
			  ,@Server;

		set @ID=0;

		while (@@FETCH_STATUS = 0 )
		begin
			set @ID=@ID+1;
			
			set @body=@body+'<TR>';

			--select top (1)
			--@ID						=	[ID]
			--,@Job_GUID				=	Job_GUID
			--,@Job_Name				=	Job_Name				
			--,@LastFinishRunState	=	LastFinishRunState		
			--,@LastDateTime			=	LastDateTime			
			--,@LastRunDurationString	=	LastRunDurationString	
			--,@LastOutcomeMessage	=	LastOutcomeMessage		
			--,@Server				=	[Server]				
			--from @tbl;

			set @body=@body+'<TD>';
			set @body=@body+cast(@ID as nvarchar(max));
			set @body=@body+'</TD>';
		
			set @body=@body+'<TD>';
			set @body=@body+coalesce(@Server, '');
			set @body=@body+'</TD>';
		
			set @body=@body+'<TD>';
			set @body=@body+coalesce(@Job_Name,'');
			set @body=@body+'</TD>';
		
			set @body=@body+'<TD>';
			set @body=@body+coalesce(@LastFinishRunState,'');
			set @body=@body+'</TD>';

			set @body=@body+'<TD>';
			set @body=@body+coalesce(rep.GetDateFormat(@LastDateTime, default)+' '+rep.GetTimeFormat(@LastDateTime, default), '');--cast(@InsertDate as nvarchar(max));
			set @body=@body+'</TD>';

			set @body=@body+'<TD>';
			set @body=@body+coalesce(@LastRunDurationString,'');
			set @body=@body+'</TD>';

			set @body=@body+'<TD>';
			set @body=@body+coalesce(@LastOutcomeMessage, '');
			set @body=@body+'</TD>';

			--delete from @tbl
			--where ID=@ID;

			set @body=@body+'</TR>';

			if @HR=0 execute @hr = sp_OAMethod  @objTextStream, 'Write', Null, @body;

			set @body='';

			FETCH NEXT FROM sql_cursor   
			INTO @Job_GUID
			  ,@Job_Name
			  ,@LastFinishRunState
			  ,@LastDateTime
			  ,@LastRunDurationString
			  ,@LastOutcomeMessage
			  ,@Server;
		end

		CLOSE sql_cursor;
		DEALLOCATE sql_cursor;

		set @body=@body+'</TABLE>';
	end
	else
	begin
		set @body='В ходе анализа последних выполнений заданий, задания с ошибочным завершением, а также те, что выполнились по времени более '
				 +cast(@second as nvarchar(255))
				 +' секунд, не выявлены на сервере '+@servername;
	end
	
	set @body=@body+'<br><br>Для более детальной информации обратитесь к таблице SRV.srv.ShortInfoRunJobs';

	if @HR=0 execute @hr = sp_OAMethod  @objTextStream, 'Write', Null, @body;

	if @HR=0 Select @objErrorObject=@objTextStream, @strErrorMessage='closing the file "'+@FileAndPath+'"'
	if @HR=0 execute @hr = sp_OAMethod  @objTextStream, 'Close'
	
	if @hr<>0
		begin
		Declare 
			@Source varchar(255),
			@Description Varchar(255),
			@Helpfile Varchar(255),
			@HelpID int
		
		EXECUTE sp_OAGetErrorInfo  @objErrorObject, 
			@source output,@Description output,@Helpfile output,@HelpID output
		Select @strErrorMessage='Error whilst '
				+coalesce(@strErrorMessage,'doing something')
				+', '+coalesce(@Description,'')
		raiserror (@strErrorMessage,16,1)
		end
	EXECUTE  sp_OADestroy @objTextStream
	EXECUTE sp_OADestroy @objFileSystem
END

GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [srv].[GetHTMLTableShortInfoRunJobsServers]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Возвращает HTML-код для таблицы выполненных заданий', 'SCHEMA', N'srv', 'PROCEDURE', N'GetHTMLTableShortInfoRunJobsServers'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indInsertUTCDate] from table [srv].[ShortInfoRunJobs]
--
DROP INDEX [indInsertUTCDate] ON [srv].[ShortInfoRunJobs]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop primary key [PK_ShortInfoRunJobs] on table [srv].[ShortInfoRunJobs]
--
ALTER TABLE [srv].[ShortInfoRunJobs]
  DROP CONSTRAINT [PK_ShortInfoRunJobs]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create primary key [PK_ShortInfoRunJobs] on table [srv].[ShortInfoRunJobs]
--
ALTER TABLE [srv].[ShortInfoRunJobs]
  ADD CONSTRAINT [PK_ShortInfoRunJobs] PRIMARY KEY CLUSTERED ([ID]) WITH (FILLFACTOR = 95)
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indInsertUTCDate] on table [srv].[ShortInfoRunJobs]
--
CREATE INDEX [indInsertUTCDate]
  ON [srv].[ShortInfoRunJobs] ([InsertUTCDate])
  WITH (FILLFACTOR = 95)
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on index [srv].[ShortInfoRunJobs].[indInsertUTCDate]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Индекс по InsertUTCDate', 'SCHEMA', N'srv', 'TABLE', N'ShortInfoRunJobs', 'INDEX', N'indInsertUTCDate'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [srv].[GetHTMLTableShortInfoRunJobs]
--
GO

-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER   PROCEDURE [srv].[GetHTMLTableShortInfoRunJobs]
	@body nvarchar(max) OUTPUT,
	@second int=60
AS
BEGIN
	/*
		формирует HTML-код для таблицы выполненных заданий
	*/
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	declare @servername nvarchar(255)=cast(SERVERPROPERTY(N'MachineName') as nvarchar(255));

	declare @tbl table (
						Job_GUID				uniqueidentifier
						,Job_Name				nvarchar(255)
						,LastFinishRunState		nvarchar(255)
						,LastDateTime			datetime
						,LastRunDurationString	nvarchar(255)
						,LastOutcomeMessage		nvarchar(max)
						,[Server]				nvarchar(255)
						,ID						int identity(1,1)
					   );

	declare
	@Job_GUID				uniqueidentifier
	,@Job_Name				nvarchar(255)
	,@LastFinishRunState	nvarchar(255)
	,@LastDateTime			datetime
	,@LastRunDurationString	nvarchar(255)
	,@LastOutcomeMessage	nvarchar(max)
	,@Server				nvarchar(255)
	,@ID					int;

	insert into @tbl(
						Job_GUID
						,Job_Name
						,LastFinishRunState
						,LastDateTime
						,LastRunDurationString
						,LastOutcomeMessage
						,[Server]
					)
			select		Job_GUID
						,Job_Name
						,LastFinishRunState
						,LastDateTime
						,LastRunDurationString
						,LastOutcomeMessage
						,[Server]
			from	srv.ShortInfoRunJobs
			order by LastRunDurationInt desc;

	if(exists(select top(1) 1 from @tbl))
	begin
		set @body='В ходе анализа последних выполнений заданий, были выявлены следующие задания, которые либо с ошибочным завершением, '
				 +'либо выполнились по времени более '+cast(@second as nvarchar(255))+' секунд:<br><br>'+'<TABLE BORDER=5>';

		set @body=@body+'<TR>';

		set @body=@body+'<TD>';
		set @body=@body+'№ п/п';
		set @body=@body+'</TD>';
	
		set @body=@body+'<TD>';
		set @body=@body+'ГУИД';
		set @body=@body+'</TD>';

		set @body=@body+'<TD>';
		set @body=@body+'ЗАДАНИЕ';
		set @body=@body+'</TD>';
	
		set @body=@body+'<TD>';
		set @body=@body+'СТАТУС';
		set @body=@body+'</TD>';

		set @body=@body+'<TD>';
		set @body=@body+'ДАТА И ВРЕМЯ';
		set @body=@body+'</TD>';

		set @body=@body+'<TD>';
		set @body=@body+'ДЛИТЕЛЬНОСТЬ';
		set @body=@body+'</TD>';

		set @body=@body+'<TD>';
		set @body=@body+'СООБЩЕНИЕ';
		set @body=@body+'</TD>';

		set @body=@body+'<TD>';
		set @body=@body+'СЕРВЕР';
		set @body=@body+'</TD>';

		set @body=@body+'</TR>';

		while((select top 1 1 from @tbl)>0)
		begin
			set @body=@body+'<TR>';

			select top 1
			@ID						=	[ID]
			,@Job_GUID				=	Job_GUID
			,@Job_Name				=	Job_Name				
			,@LastFinishRunState	=	LastFinishRunState		
			,@LastDateTime			=	LastDateTime			
			,@LastRunDurationString	=	LastRunDurationString	
			,@LastOutcomeMessage	=	LastOutcomeMessage		
			,@Server				=	[Server]				
			from @tbl;

			set @body=@body+'<TD>';
			set @body=@body+cast(@ID as nvarchar(max));
			set @body=@body+'</TD>';
		
			set @body=@body+'<TD>';
			set @body=@body+cast(@Job_GUID as nvarchar(255));
			set @body=@body+'</TD>';
		
			set @body=@body+'<TD>';
			set @body=@body+coalesce(@Job_Name,'');
			set @body=@body+'</TD>';
		
			set @body=@body+'<TD>';
			set @body=@body+coalesce(@LastFinishRunState,'');
			set @body=@body+'</TD>';

			set @body=@body+'<TD>';
			set @body=@body+rep.GetDateFormat(@LastDateTime, default)+' '+rep.GetTimeFormat(@LastDateTime, default);--cast(@InsertDate as nvarchar(max));
			set @body=@body+'</TD>';

			set @body=@body+'<TD>';
			set @body=@body+coalesce(@LastRunDurationString,'');
			set @body=@body+'</TD>';

			set @body=@body+'<TD>';
			set @body=@body+coalesce(@LastOutcomeMessage, '');
			set @body=@body+'</TD>';

			set @body=@body+'<TD>';
			set @body=@body+coalesce(@Server, '');
			set @body=@body+'</TD>';

			delete from @tbl
			where ID=@ID;

			set @body=@body+'</TR>';
		end

		set @body=@body+'</TABLE>';
	end
	else
	begin
		set @body='В ходе анализа последних выполнений заданий, задания с ошибочным завершением, а также те, что выполнились по времени более '
				 +cast(@second as nvarchar(255))
				 +' секунд, не выявлены на сервере '+@servername;
	end
	
	set @body=@body+'<br><br>Для более детальной информации обратитесь к таблице SRV.srv.ShortInfoRunJobs';
END

GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop procedure [srv].[AutoShortInfoRunJobs]
--
DROP PROCEDURE [srv].[AutoShortInfoRunJobs]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [srv].[AutoShortInfoRunJobs]
--
GO


-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE   PROCEDURE [srv].[AutoShortInfoRunJobs]
	@second int=60,
	@body nvarchar(max)=NULL OUTPUT
AS
BEGIN
	/*
		Returns a message about completed tasks 
		for later sending to the mail
	*/
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	declare @servername nvarchar(255)=cast(SERVERPROPERTY(N'MachineName') as nvarchar(255));

    truncate table [srv].[ShortInfoRunJobs];

	INSERT INTO [srv].[ShortInfoRunJobs]
           ([Job_GUID]
           ,[Job_Name]
           ,[LastFinishRunState]
           ,[LastDateTime]
           ,[LastRunDurationString]
           ,[LastRunDurationInt]
           ,[LastOutcomeMessage]
           ,[LastRunOutcome]
           ,[Server])
    SELECT [Job_GUID]
          ,[Job_Name]
          ,[LastFinishRunState]
          ,[LastDateTime]
          ,[LastRunDurationString]
          ,[LastRunDurationInt]
          ,[LastOutcomeMessage]
          ,LastRunOutcome
          ,@servername
      FROM [inf].[vJobRunShortInfo]
      where [Enabled]=1
      and ([LastRunOutcome]=0
      or [LastRunDurationInt]>=@second)
      and LastDateTime>=DateAdd(day,-2,getdate());

	  INSERT INTO [srv].[ShortInfoRunJobsServers]
           ([Job_GUID]
           ,[Job_Name]
           ,[LastFinishRunState]
           ,[LastDateTime]
           ,[LastRunDurationString]
           ,[LastRunDurationInt]
           ,[LastOutcomeMessage]
           ,[LastRunOutcome]
           ,[Server]
		   ,[TargetServer])
	  SELECT [Job_GUID]
           ,[Job_Name]
           ,[LastFinishRunState]
           ,[LastDateTime]
           ,[LastRunDurationString]
           ,[LastRunDurationInt]
           ,[LastOutcomeMessage]
           ,[LastRunOutcome]
           ,@servername as [Server]
		   ,[TargetServer]
	  FROM [inf].[vJobRunShortInfo];
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [srv].[AutoShortInfoRunJobs]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Returns a message about completed tasks for later sending to the mail', 'SCHEMA', N'srv', 'PROCEDURE', N'AutoShortInfoRunJobs'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop primary key [PK_RestoreSettingsDetail_1] on table [srv].[RestoreSettingsDetail]
--
ALTER TABLE [srv].[RestoreSettingsDetail]
  DROP CONSTRAINT [PK_RestoreSettingsDetail_1]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create primary key [PK_RestoreSettingsDetail_1] on table [srv].[RestoreSettingsDetail]
--
ALTER TABLE [srv].[RestoreSettingsDetail]
  ADD CONSTRAINT [PK_RestoreSettingsDetail_1] PRIMARY KEY CLUSTERED ([Row_GUID]) WITH (FILLFACTOR = 95)
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indInsertUTCDate] from table [srv].[RestoreSettings]
--
DROP INDEX [indInsertUTCDate] ON [srv].[RestoreSettings]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop primary key [PK_RestoreSettings_1] on table [srv].[RestoreSettings]
--
ALTER TABLE [srv].[RestoreSettings]
  DROP CONSTRAINT [PK_RestoreSettings_1]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create primary key [PK_RestoreSettings_1] on table [srv].[RestoreSettings]
--
ALTER TABLE [srv].[RestoreSettings]
  ADD CONSTRAINT [PK_RestoreSettings_1] PRIMARY KEY CLUSTERED ([DBName]) WITH (FILLFACTOR = 95)
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indInsertUTCDate] on table [srv].[RestoreSettings]
--
CREATE INDEX [indInsertUTCDate]
  ON [srv].[RestoreSettings] ([InsertUTCDate])
  WITH (FILLFACTOR = 95)
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on index [srv].[RestoreSettings].[indInsertUTCDate]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Индекс по InsertUTCDate', 'SCHEMA', N'srv', 'TABLE', N'RestoreSettings', 'INDEX', N'indInsertUTCDate'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indInsertUTCDate] from table [srv].[RequestStatisticsArchive]
--
DROP INDEX [indInsertUTCDate] ON [srv].[RequestStatisticsArchive]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indPlanQuery] from table [srv].[RequestStatisticsArchive]
--
DROP INDEX [indPlanQuery] ON [srv].[RequestStatisticsArchive]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indRequest] from table [srv].[RequestStatisticsArchive]
--
DROP INDEX [indRequest] ON [srv].[RequestStatisticsArchive]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indInsertUTCDate] on table [srv].[RequestStatisticsArchive]
--
CREATE INDEX [indInsertUTCDate]
  ON [srv].[RequestStatisticsArchive] ([InsertUTCDate])
  WITH (FILLFACTOR = 95)
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indPlanQuery] on table [srv].[RequestStatisticsArchive]
--
CREATE INDEX [indPlanQuery]
  ON [srv].[RequestStatisticsArchive] ([plan_handle], [sql_handle])
  WHERE ([sql_handle] IS NOT NULL AND [plan_handle] IS NOT NULL)
  WITH (FILLFACTOR = 95)
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indRequest] on table [srv].[RequestStatisticsArchive]
--
CREATE CLUSTERED INDEX [indRequest]
  ON [srv].[RequestStatisticsArchive] ([session_id], [request_id], [database_id], [user_id], [start_time], [command], [sql_handle], [plan_handle], [transaction_id], [connection_id])
  WITH (FILLFACTOR = 95)
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on index [srv].[RequestStatisticsArchive].[indInsertUTCDate]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Индекс по InsertUTCDate', 'SCHEMA', N'srv', 'TABLE', N'RequestStatisticsArchive', 'INDEX', N'indInsertUTCDate'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on index [srv].[RequestStatisticsArchive].[indPlanQuery]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Индекс по композиции полей', 'SCHEMA', N'srv', 'TABLE', N'RequestStatisticsArchive', 'INDEX', N'indPlanQuery'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on index [srv].[RequestStatisticsArchive].[indRequest]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Кластерный неуникальный индекс по композиции полей', 'SCHEMA', N'srv', 'TABLE', N'RequestStatisticsArchive', 'INDEX', N'indRequest'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indInsertUTCDate] from table [srv].[RequestStatistics]
--
DROP INDEX [indInsertUTCDate] ON [srv].[RequestStatistics]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indPlanQuery] from table [srv].[RequestStatistics]
--
DROP INDEX [indPlanQuery] ON [srv].[RequestStatistics]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indRequest] from table [srv].[RequestStatistics]
--
DROP INDEX [indRequest] ON [srv].[RequestStatistics]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indInsertUTCDate] on table [srv].[RequestStatistics]
--
CREATE INDEX [indInsertUTCDate]
  ON [srv].[RequestStatistics] ([InsertUTCDate])
  WITH (FILLFACTOR = 95)
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indPlanQuery] on table [srv].[RequestStatistics]
--
CREATE INDEX [indPlanQuery]
  ON [srv].[RequestStatistics] ([sql_handle], [plan_handle])
  WITH (FILLFACTOR = 95)
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indRequest] on table [srv].[RequestStatistics]
--
CREATE CLUSTERED INDEX [indRequest]
  ON [srv].[RequestStatistics] ([session_id], [request_id], [database_id], [user_id], [start_time], [command], [sql_handle], [plan_handle], [transaction_id], [connection_id])
  WITH (FILLFACTOR = 95)
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indInsertUTCDate] from table [srv].[Recipient]
--
DROP INDEX [indInsertUTCDate] ON [srv].[Recipient]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop primary key [PK_Recipient] on table [srv].[Recipient]
--
ALTER TABLE [srv].[Recipient]
  DROP CONSTRAINT [PK_Recipient]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop unique key [AK_Recipient_Code] on table [srv].[Recipient]
--
ALTER TABLE [srv].[Recipient]
  DROP CONSTRAINT [AK_Recipient_Code]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop unique key [AK_Recipient_Name] on table [srv].[Recipient]
--
ALTER TABLE [srv].[Recipient]
  DROP CONSTRAINT [AK_Recipient_Name]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create primary key [PK_Recipient] on table [srv].[Recipient]
--
ALTER TABLE [srv].[Recipient]
  ADD CONSTRAINT [PK_Recipient] PRIMARY KEY CLUSTERED ([Recipient_GUID]) WITH (FILLFACTOR = 95)
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create unique key [AK_Recipient_Code] on table [srv].[Recipient]
--
ALTER TABLE [srv].[Recipient]
  ADD CONSTRAINT [AK_Recipient_Code] UNIQUE ([Recipient_Code]) WITH (FILLFACTOR = 95)
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create unique key [AK_Recipient_Name] on table [srv].[Recipient]
--
ALTER TABLE [srv].[Recipient]
  ADD CONSTRAINT [AK_Recipient_Name] UNIQUE ([Recipient_Name]) WITH (FILLFACTOR = 95)
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indInsertUTCDate] on table [srv].[Recipient]
--
CREATE INDEX [indInsertUTCDate]
  ON [srv].[Recipient] ([InsertUTCDate])
  WITH (FILLFACTOR = 95)
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on index [srv].[Recipient].[indInsertUTCDate]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Индекс по InsertUTCDate', 'SCHEMA', N'srv', 'TABLE', N'Recipient', 'INDEX', N'indInsertUTCDate'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on table [srv].[ReadWriteTablesStatistics]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Статистика по IO на таблицы БД', 'SCHEMA', N'srv', 'TABLE', N'ReadWriteTablesStatistics'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop default constraint [DF_RAMSpaceStatistics_Server] on table [srv].[RAMSpaceStatistics]
--
ALTER TABLE [srv].[RAMSpaceStatistics]
  DROP CONSTRAINT [DF_RAMSpaceStatistics_Server]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add default constraint [DF_RAMSpaceStatistics_Server] on table [srv].[RAMSpaceStatistics]
--
ALTER TABLE [srv].[RAMSpaceStatistics]
  ADD CONSTRAINT [DF_RAMSpaceStatistics_Server] DEFAULT (CONVERT([nvarchar](255),serverproperty(N'MachineName'))) FOR [Server]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on table [srv].[RAMSpaceStatistics]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Статистика по использованию емкости ОЗУ', 'SCHEMA', N'srv', 'TABLE', N'RAMSpaceStatistics'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indClustQueryStatistics] from table [srv].[QueryStatistics]
--
DROP INDEX [indClustQueryStatistics] ON [srv].[QueryStatistics]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indInsertUTCDate] from table [srv].[QueryStatistics]
--
DROP INDEX [indInsertUTCDate] ON [srv].[QueryStatistics]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indPlanQuery] from table [srv].[QueryStatistics]
--
DROP INDEX [indPlanQuery] ON [srv].[QueryStatistics]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop primary key [PK_QueryStatistics] on table [srv].[QueryStatistics]
--
ALTER TABLE [srv].[QueryStatistics]
  DROP CONSTRAINT [PK_QueryStatistics]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create primary key [PK_QueryStatistics] on table [srv].[QueryStatistics]
--
ALTER TABLE [srv].[QueryStatistics]
  ADD CONSTRAINT [PK_QueryStatistics] PRIMARY KEY NONCLUSTERED ([ID]) WITH (FILLFACTOR = 95)
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indClustQueryStatistics] on table [srv].[QueryStatistics]
--
CREATE CLUSTERED INDEX [indClustQueryStatistics]
  ON [srv].[QueryStatistics] ([creation_time])
  WITH (FILLFACTOR = 95)
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indInsertUTCDate] on table [srv].[QueryStatistics]
--
CREATE INDEX [indInsertUTCDate]
  ON [srv].[QueryStatistics] ([InsertUTCDate])
  WITH (FILLFACTOR = 95)
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indPlanQuery] on table [srv].[QueryStatistics]
--
CREATE INDEX [indPlanQuery]
  ON [srv].[QueryStatistics] ([plan_handle], [sql_handle])
  WITH (FILLFACTOR = 95)
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on index [srv].[QueryStatistics].[indClustQueryStatistics]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Кластеризованный неуникальный индекс', 'SCHEMA', N'srv', 'TABLE', N'QueryStatistics', 'INDEX', N'indClustQueryStatistics'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on index [srv].[QueryStatistics].[indInsertUTCDate]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Индекс по InsertUTCDate', 'SCHEMA', N'srv', 'TABLE', N'QueryStatistics', 'INDEX', N'indInsertUTCDate'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on index [srv].[QueryStatistics].[indPlanQuery]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Индекс по паре полей (близок к естественному ключу)', 'SCHEMA', N'srv', 'TABLE', N'QueryStatistics', 'INDEX', N'indPlanQuery'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop primary key [PK_QueryRequestGroupStatistics] on table [srv].[QueryRequestGroupStatistics]
--
ALTER TABLE [srv].[QueryRequestGroupStatistics]
  DROP CONSTRAINT [PK_QueryRequestGroupStatistics]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create primary key [PK_QueryRequestGroupStatistics] on table [srv].[QueryRequestGroupStatistics]
--
ALTER TABLE [srv].[QueryRequestGroupStatistics]
  ADD CONSTRAINT [PK_QueryRequestGroupStatistics] PRIMARY KEY CLUSTERED ([sql_handle])
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indInsertUTCDate] from table [srv].[PlanQuery]
--
DROP INDEX [indInsertUTCDate] ON [srv].[PlanQuery]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop primary key [PK_PlanQuery] on table [srv].[PlanQuery]
--
ALTER TABLE [srv].[PlanQuery]
  DROP CONSTRAINT [PK_PlanQuery]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create primary key [PK_PlanQuery] on table [srv].[PlanQuery]
--
ALTER TABLE [srv].[PlanQuery]
  ADD CONSTRAINT [PK_PlanQuery] PRIMARY KEY CLUSTERED ([SQLHandle], [PlanHandle]) WITH (FILLFACTOR = 95)
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indInsertUTCDate] on table [srv].[PlanQuery]
--
CREATE INDEX [indInsertUTCDate]
  ON [srv].[PlanQuery] ([InsertUTCDate])
  WITH (FILLFACTOR = 95)
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on index [srv].[PlanQuery].[indInsertUTCDate]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Индекс по InsertUTCDate', 'SCHEMA', N'srv', 'TABLE', N'PlanQuery', 'INDEX', N'indInsertUTCDate'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on table [srv].[OldStatisticsStateStatistics]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Устаревшая статистика', 'SCHEMA', N'srv', 'TABLE', N'OldStatisticsStateStatistics'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on table [srv].[NewIndexOptimizeStatistics]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Рекомендуемые индексы согласно собранной статистики', 'SCHEMA', N'srv', 'TABLE', N'NewIndexOptimizeStatistics'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [srv].[AutoDefragIndexDB]
--
GO

ALTER PROCEDURE [srv].[AutoDefragIndexDB]
	@DB nvarchar(255)=NULL, --по конкретной БД или по всем
	@count int=NULL, --кол-во индексов для рассмотрения в каждой БД
	@IsTempdb bit=0 --включать ли БД tempdb
AS
BEGIN
	/*
		вызов оптимизации индексов для заданной БД
	*/

	SET QUERY_GOVERNOR_COST_LIMIT 0;
	SET NOCOUNT ON;

	declare @db_name nvarchar(255);
	declare @sql nvarchar(max);
	declare @ParmDefinition nvarchar(255)= N'@count int';

	truncate table [srv].[ListDefragIndex];
	
	if(@DB is null)
	begin
		select [name]
		into #tbls
		from sys.databases
		where [is_read_only]=0
		and [state]=0 --ONLINE
		and [user_access]=0--MULTI_USER
		and (((@IsTempdb=0 or @IsTempdb is null) and [name]<>N'tempdb') or (@IsTempdb=1));

		while(exists(select top(1) 1 from #tbls))
		begin
			select top(1)
			@db_name=[name]
			from #tbls;

			set @sql=N'USE ['+@db_name+']; '+
			N'IF(object_id('+N''''+N'[srv].[AutoDefragIndex]'+N''''+N') is not null) EXEC [srv].[AutoDefragIndex] @count=@count;';

			exec sp_executesql @sql, @ParmDefinition, @count=@count;

			delete from #tbls
			where [name]=@db_name;
		end

		drop table #tbls;
	end
	else
	begin
		set @sql=N'USE ['+@DB+']; '+
			N'IF(object_id('+N''''+N'[srv].[AutoDefragIndex]'+N''''+N') is not null) EXEC [srv].[AutoDefragIndex] @count=@count;';

		exec sp_executesql @sql, @ParmDefinition, @count=@count;
	end
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indInsertUTCDate] from table [srv].[KillSession]
--
DROP INDEX [indInsertUTCDate] ON [srv].[KillSession]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop primary key [PK_KillSession] on table [srv].[KillSession]
--
ALTER TABLE [srv].[KillSession]
  DROP CONSTRAINT [PK_KillSession]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create primary key [PK_KillSession] on table [srv].[KillSession]
--
ALTER TABLE [srv].[KillSession]
  ADD CONSTRAINT [PK_KillSession] PRIMARY KEY CLUSTERED ([ID]) WITH (FILLFACTOR = 95)
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indInsertUTCDate] on table [srv].[KillSession]
--
CREATE INDEX [indInsertUTCDate]
  ON [srv].[KillSession] ([InsertUTCDate])
  WITH (FILLFACTOR = 95)
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on index [srv].[KillSession].[indInsertUTCDate]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Индекс по InsertUTCDate', 'SCHEMA', N'srv', 'TABLE', N'KillSession', 'INDEX', N'indInsertUTCDate'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on table [srv].[IndexUsageStatsStatistics]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Статистика использования индексов', 'SCHEMA', N'srv', 'TABLE', N'IndexUsageStatsStatistics'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on table [srv].[IndexDefragStatistics]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Статистика степени фрагментации индексов', 'SCHEMA', N'srv', 'TABLE', N'IndexDefragStatistics'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indInsertUTCDate] from table [srv].[ErrorInfoArchive]
--
DROP INDEX [indInsertUTCDate] ON [srv].[ErrorInfoArchive]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop primary key [PK_ArchiveErrorInfo] on table [srv].[ErrorInfoArchive]
--
ALTER TABLE [srv].[ErrorInfoArchive]
  DROP CONSTRAINT [PK_ArchiveErrorInfo]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create primary key [PK_ArchiveErrorInfo] on table [srv].[ErrorInfoArchive]
--
ALTER TABLE [srv].[ErrorInfoArchive]
  ADD CONSTRAINT [PK_ArchiveErrorInfo] PRIMARY KEY CLUSTERED ([ErrorInfo_GUID]) WITH (FILLFACTOR = 95)
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indInsertUTCDate] on table [srv].[ErrorInfoArchive]
--
CREATE INDEX [indInsertUTCDate]
  ON [srv].[ErrorInfoArchive] ([InsertUTCDate])
  WITH (FILLFACTOR = 95)
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on index [srv].[ErrorInfoArchive].[indInsertUTCDate]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Индекс по InsertUTCDate', 'SCHEMA', N'srv', 'TABLE', N'ErrorInfoArchive', 'INDEX', N'indInsertUTCDate'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indInsertUTCDate] from table [srv].[ErrorInfo]
--
DROP INDEX [indInsertUTCDate] ON [srv].[ErrorInfo]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop primary key [PK_ErrorInfo] on table [srv].[ErrorInfo]
--
ALTER TABLE [srv].[ErrorInfo]
  DROP CONSTRAINT [PK_ErrorInfo]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create primary key [PK_ErrorInfo] on table [srv].[ErrorInfo]
--
ALTER TABLE [srv].[ErrorInfo]
  ADD CONSTRAINT [PK_ErrorInfo] PRIMARY KEY CLUSTERED ([ErrorInfo_GUID]) WITH (FILLFACTOR = 95)
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indInsertUTCDate] on table [srv].[ErrorInfo]
--
CREATE INDEX [indInsertUTCDate]
  ON [srv].[ErrorInfo] ([InsertUTCDate])
  WITH (FILLFACTOR = 95)
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on index [srv].[ErrorInfo].[indInsertUTCDate]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Индекс по InsertUTCDate', 'SCHEMA', N'srv', 'TABLE', N'ErrorInfo', 'INDEX', N'indInsertUTCDate'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop default constraint [DF_Drivers_Server] on table [srv].[Drivers]
--
ALTER TABLE [srv].[Drivers]
  DROP CONSTRAINT [DF_Drivers_Server]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indInsertUTCDate] from table [srv].[Drivers]
--
DROP INDEX [indInsertUTCDate] ON [srv].[Drivers]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop primary key [PK_Drivers] on table [srv].[Drivers]
--
ALTER TABLE [srv].[Drivers]
  DROP CONSTRAINT [PK_Drivers]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create primary key [PK_Drivers] on table [srv].[Drivers]
--
ALTER TABLE [srv].[Drivers]
  ADD CONSTRAINT [PK_Drivers] PRIMARY KEY CLUSTERED ([Driver_GUID])
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add default constraint [DF_Drivers_Server] on table [srv].[Drivers]
--
ALTER TABLE [srv].[Drivers]
  ADD CONSTRAINT [DF_Drivers_Server] DEFAULT (CONVERT([nvarchar](255),serverproperty(N'MachineName'))) FOR [Server]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indInsertUTCDate] on table [srv].[Drivers]
--
CREATE INDEX [indInsertUTCDate]
  ON [srv].[Drivers] ([InsertUTCDate])
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on index [srv].[Drivers].[indInsertUTCDate]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Индекс по InsertUTCDate', 'SCHEMA', N'srv', 'TABLE', N'Drivers', 'INDEX', N'indInsertUTCDate'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [srv].[MergeDriverInfo]
--
GO




ALTER PROCEDURE [srv].[MergeDriverInfo]
AS
BEGIN
	/*
		обновляет таблицу устройств-дисков
	*/
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	declare @servername nvarchar(255)=cast(SERVERPROPERTY(N'MachineName') as nvarchar(255));

	declare @Drivers table (
							[Server] nvarchar(255),
							Name nvarchar(8),
							TotalSpace float,
							FreeSpace float,
							DiffFreeSpace float NULL
						   );
	insert into @Drivers   (
							[Server],
							Name,
							TotalSpace,
							FreeSpace
						   )
	select					[Server],
							Name,
							TotalSpace,
							FreeSpace
	from				srv.Drivers
	where [Server]=@servername;

	declare @TotalSpace float;
    declare @FreeSpace float;
	declare @DrivePath nvarchar(8);

	while(exists(select top(1) 1 from @Drivers where DiffFreeSpace is null))
	begin
		select top(1)
		@DrivePath=Name
		from @Drivers
		where DiffFreeSpace is null;

		exec srv.sp_DriveSpace @DrivePath = @DrivePath
						 , @TotalSpace = @TotalSpace out
						 , @FreeSpace = @FreeSpace out;

		update @Drivers
		set TotalSpace=@TotalSpace
		   ,FreeSpace=@FreeSpace
		   ,DiffFreeSpace=case when FreeSpace>0 then round(FreeSpace-@FreeSpace,3) else 0 end
		where Name=@DrivePath;
	end

	;merge [srv].[Drivers] as d
	using @Drivers as dd
	on d.Name=dd.Name and d.[Server]=dd.[Server]
	when matched then
		update set UpdateUTcDate = getUTCDate()
				 ,[TotalSpace]	 = dd.[TotalSpace]	 
				 ,[FreeSpace]	 = dd.[FreeSpace]	 
				 ,[DiffFreeSpace]= dd.[DiffFreeSpace];
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop default constraint [DF_DiskSpaceStatistics_Server] on table [srv].[DiskSpaceStatistics]
--
ALTER TABLE [srv].[DiskSpaceStatistics]
  DROP CONSTRAINT [DF_DiskSpaceStatistics_Server]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add default constraint [DF_DiskSpaceStatistics_Server] on table [srv].[DiskSpaceStatistics]
--
ALTER TABLE [srv].[DiskSpaceStatistics]
  ADD CONSTRAINT [DF_DiskSpaceStatistics_Server] DEFAULT (CONVERT([nvarchar](255),serverproperty(N'MachineName'))) FOR [Server]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on table [srv].[DiskSpaceStatistics]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Статистика использования емкости дисков', 'SCHEMA', N'srv', 'TABLE', N'DiskSpaceStatistics'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [zabbix].[GetForecastDiskMinAvailable_Mb]
--
GO






-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER   PROCEDURE [zabbix].[GetForecastDiskMinAvailable_Mb]
AS
BEGIN
	/*
		Наиболее вероятное минимальное свободное место по всем дискам, которое будет через определенный промежуток времени
		Промежуток времени берется ровно столько, за сколько удалось собрать данные
	*/

	--SET QUERY_GOVERNOR_COST_LIMIT 0;
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	SET XACT_ABORT ON;

	declare @servername nvarchar(255)=cast(SERVERPROPERTY(N'MachineName') as nvarchar(255));

	declare @tbl table ([DATE] date, [MinAvailable_Mb] decimal(18,6), [MinAvailable_Percent] decimal(18,6), [Disk] nvarchar(255));
	declare @tbl_res table ([DiffMinAvailable_Mb] decimal(18,6), [DiffMinAvailable_Percent] decimal(18,6), [Disk] nvarchar(255));
	declare @curr table ([Disk] nvarchar (255), [MinAvailable_Mb] decimal(18,6));
	declare @diff table ([Disk] nvarchar (255), [Val] decimal(18,6));
	
	insert into @tbl ([DATE], [MinAvailable_Mb], [MinAvailable_Percent], [Disk])
	SELECT cast([InsertUTCDate] as date) as [DATE]
		  ,min([Available_Mb])			 as [MinAvailable_Mb]
	      ,min([Available_Percent])		 as [MinAvailable_Percent]
		  ,[Disk]
	  FROM [srv].[DiskSpaceStatistics]
	  where [Server]=@servername
	  group by cast([InsertUTCDate] as date), [Disk];
	
	;with tbl as (
		select [Disk], max([DATE]) as [DATE]
		from @tbl
		group by [Disk]
	)
	insert into @curr ([Disk], [MinAvailable_Mb])
	select t.[Disk], min(tt.[MinAvailable_Mb]) as [MinAvailable_Mb]
	from tbl as t
	inner join @tbl as tt on t.[Disk]=tt.[Disk] and t.[DATE]=tt.[DATE]
	group by t.[Disk];
	
	insert into @tbl_res ([DiffMinAvailable_Mb], [DiffMinAvailable_Percent], [Disk])
	select t.[MinAvailable_Mb]		-tt.[MinAvailable_Mb]				as [DiffMinAvailable_Mb]
		  ,t.[MinAvailable_Percent]	-tt.[MinAvailable_Percent]			as [DiffMinAvailable_Percent]
		  ,t.[Disk]
	from @tbl as t
	inner join @tbl as tt on t.[Disk]=tt.[Disk] and t.[DATE]=DateAdd(day,-1,tt.[DATE]);

	insert into @diff ([Disk], [Val])
	select t.[Disk],
		   (t.[MinAvailable_Mb]-(
								 select avg([DiffMinAvailable_Mb])*(
																	select count(*)
																	from @tbl_res as t0 
																	where t0.[Disk]=t.[Disk]
																   )
								 from @tbl_res as t0
								 where t0.[Disk]=t.[Disk]
								)
		   ) as [Val]
	from @curr as t;

	select coalesce(min([Val]), 8192) as [valueMB]
	from @diff;
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [srv].[AutoStatisticsDiskAndRAMSpace]
--
GO


-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER PROCEDURE [srv].[AutoStatisticsDiskAndRAMSpace]
AS
BEGIN
	/*
		Собирает информацию о емкостях логических дисков и ОЗУ
	*/
	SET QUERY_GOVERNOR_COST_LIMIT 0;
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    --По дискам сингализация
	insert into [srv].[DiskSpaceStatistics] (
		   [Disk]
		 , [Disk_Space_Mb]
		 , [Available_Mb]
		 , [Available_Percent]
		 , [State]
	)
	select [Disk]
		 , [Disk_Space_Mb]
		 , [Available_Mb]
		 , [Available_Percent]
		 , (case when [Available_Percent]<=20 and [Available_Percent]>10 then 'Warning' when [Available_Percent]<=10 then 'Danger' else 'Normal' end) as [State]
	from
	(	SELECT  volume_mount_point as [Disk]
		, cast(((MAX(s.total_bytes))/1024.0)/1024.0 as numeric(11,2)) as Disk_Space_Mb
		, cast(((MIN(s.available_bytes))/1024.0)/1024.0 as numeric(11,2)) as Available_Mb
		, cast((MIN(available_bytes)/cast(MAX(total_bytes) as float))*100 as numeric(11,2)) as [Available_Percent]
		FROM sys.master_files AS f
		CROSS APPLY sys.dm_os_volume_stats(f.database_id, f.file_id) as s
		GROUP BY volume_mount_point
	) as a;
	
	--ПО RAM сингализация
	insert into [srv].[RAMSpaceStatistics] (
		   [TotalAvailOSRam_Mb]
		 , [RAM_Avail_Percent]
		 , [Server_physical_memory_Mb]
		 , [SQL_server_committed_target_Mb]
		 , [SQL_server_physical_memory_in_use_Mb]
		 , [State]
	)
	select a0.[TotalAvailOSRam_Mb]
		 , a0.[RAM_Avail_Percent]
		 , ceiling(b.physical_memory_kb/1024.0) as [Server_physical_memory_Mb]
		 , ceiling(b.committed_target_kb/1024.0) as [SQL_server_committed_target_Mb]
		 , ceiling(a.physical_memory_in_use_kb/1024.0) as [SQL_server_physical_memory_in_use_Mb]
		 --, ceiling(v.available_physical_memory_kb/1024.0) as [available_physical_memory_Mb]
		 , (case when (ceiling(b.committed_target_kb/1024.0)-1024)<ceiling(a.physical_memory_in_use_kb/1024.0) then 'Warning' else 'Normal' end) as [State]
		 --, (case when [RAM_Avail_Percent]<=8 and [RAM_Avail_Percent]>5 then 'Warning' when [RAM_Avail_Percent]<=5 then 'Danger' else 'Normal' end) as [State]
	from
	(
		select cast(available_physical_memory_kb/1024.0 as int) as TotalAvailOSRam_Mb
			 , cast((available_physical_memory_kb/casT(total_physical_memory_kb as float))*100 as numeric(5,2)) as [RAM_Avail_Percent]
		from sys.dm_os_sys_memory
	) as a0
	cross join sys.dm_os_process_memory as a
	cross join sys.dm_os_sys_info as b
	cross join sys.dm_os_sys_memory as v;
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on table [srv].[DelIndexIncludeStatistics]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Статистика перекрывающихся индексов', 'SCHEMA', N'srv', 'TABLE', N'DelIndexIncludeStatistics'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on table [srv].[DefragServers]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'История оптимизаций индексов со всех серверов', 'SCHEMA', N'srv', 'TABLE', N'DefragServers'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop default constraint [DF_Defrag_Server] on table [srv].[Defrag]
--
ALTER TABLE [srv].[Defrag]
  DROP CONSTRAINT [DF_Defrag_Server]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add default constraint [DF_Defrag_Server] on table [srv].[Defrag]
--
ALTER TABLE [srv].[Defrag]
  ADD CONSTRAINT [DF_Defrag_Server] DEFAULT (CONVERT([nvarchar](255),serverproperty(N'MachineName'))) FOR [Server]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [srv].[AutoDataCollectionRemote]
--
GO



-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER     PROCEDURE [srv].[AutoDataCollectionRemote]
AS
BEGIN
	/*
		Сбор данных с удаленных серверов
	*/

	SET QUERY_GOVERNOR_COST_LIMIT 0;
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	declare @servername nvarchar(255)=cast(SERVERPROPERTY(N'MachineName') as nvarchar(255));

	declare @sql nvarchar(max);
	declare @server sysname;
	declare @dt0 datetime=GetUTCDate();
	declare @dt datetime=DateAdd(hour, -16, @dt0);
	declare @existsSRV table([IsExists] bit);
	declare @IsSRV bit;

	select [name]
	into #tbl
	from sys.servers
	where [is_system]=0
	  and [is_linked]=1
	  and [name]<>@servername;

	DECLARE sql_cursor CURSOR LOCAL FOR
	select [name]
	from #tbl;
	
	OPEN sql_cursor;
	  
	FETCH NEXT FROM sql_cursor   
	INTO @server;

	while (@@FETCH_STATUS = 0 )
	begin
		delete from @existsSRV;
		
		set @sql=N'
		if(exists(select top(1) 1 from ['+@server+N'].master.sys.databases where [name]=''FortisAdmin''))
		begin
			select 1;
		end
		else select 0;';

		insert into @existsSRV ([IsExists])
		exec sp_executesql @sql;

		select top(1)
		@IsSRV=[IsExists]
		from @existsSRV;
		
		if(@IsSRV=1)
		begin
			set @sql=N'
			begin
				INSERT INTO [srv].[WaitsStatistics]
					   ([Server]
					   ,[WaitType]
					   ,[Wait_S]
					   ,[Resource_S]
					   ,[Signal_S]
					   ,[WaitCount]
					   ,[Percentage]
					   ,[AvgWait_S]
					   ,[AvgRes_S]
					   ,[AvgSig_S]
					   ,[InsertUTCDate])
				SELECT  [Server]
					   ,[WaitType]
					   ,[Wait_S]
					   ,[Resource_S]
					   ,[Signal_S]
					   ,[WaitCount]
					   ,[Percentage]
					   ,[AvgWait_S]
					   ,[AvgRes_S]
					   ,[AvgSig_S]
					   ,[InsertUTCDate]
				FROM ['+@server+N'].[FortisAdmin].[srv].[WaitsStatistics]
				WHERE [InsertUTCDate]>='''+cast(@dt as nvarchar(255))+N'''
				  AND [InsertUTCDate]<='''+cast(@dt0 as nvarchar(255))+N''';

				INSERT INTO [srv].[ReadWriteTablesStatistics]
				   ([ServerName]
				   ,[DBName]
				   ,[SchemaTableName]
				   ,[TableName]
				   ,[Reads]
				   ,[Writes]
				   ,[Reads&Writes]
				   ,[SampleDays]
				   ,[SampleSeconds]
				   ,[InsertUTCDate])
				SELECT [ServerName]
				   ,[DBName]
				   ,[SchemaTableName]
				   ,[TableName]
				   ,[Reads]
				   ,[Writes]
				   ,[Reads&Writes]
				   ,[SampleDays]
				   ,[SampleSeconds]
				   ,[InsertUTCDate]
				FROM ['+@server+N'].[FortisAdmin].[srv].[ReadWriteTablesStatistics]
				WHERE [InsertUTCDate]>='''+cast(@dt as nvarchar(255))+N'''
				  AND [InsertUTCDate]<='''+cast(@dt0 as nvarchar(255))+N''';

				INSERT INTO [srv].[OldStatisticsStateStatistics]
				   ([Server]
				   ,[DataBase]
				   ,[object_id]
				   ,[SchemaName]
				   ,[ObjectName]
				   ,[stats_id]
				   ,[StatName]
				   ,[row_count]
				   ,[ProcModified]
				   ,[ObjectSizeMB]
				   ,[type_desc]
				   ,[create_date]
				   ,[last_updated]
				   ,[ModificationCounter]
				   ,[ProcSampled]
				   ,[Func]
				   ,[IsScanned]
				   ,[ColumnType]
				   ,[auto_created]
				   ,[IndexName]
				   ,[has_filter]
				   ,[InsertUTCDate])
				SELECT [Server]
				   ,[DataBase]
				   ,[object_id]
				   ,[SchemaName]
				   ,[ObjectName]
				   ,[stats_id]
				   ,[StatName]
				   ,[row_count]
				   ,[ProcModified]
				   ,[ObjectSizeMB]
				   ,[type_desc]
				   ,[create_date]
				   ,[last_updated]
				   ,[ModificationCounter]
				   ,[ProcSampled]
				   ,[Func]
				   ,[IsScanned]
				   ,[ColumnType]
				   ,[auto_created]
				   ,[IndexName]
				   ,[has_filter]
				   ,[InsertUTCDate]
				FROM ['+@server+N'].[FortisAdmin].[srv].[OldStatisticsStateStatistics]
				WHERE [InsertUTCDate]>='''+cast(@dt as nvarchar(255))+N'''
				  AND [InsertUTCDate]<='''+cast(@dt0 as nvarchar(255))+N''';
			end';

			exec sp_executesql @sql;

			set @sql=N'
			begin
				INSERT INTO [srv].[NewIndexOptimizeStatistics]
				   ([ServerName]
				   ,[DBName]
				   ,[Schema]
				   ,[Name]
				   ,[index_advantage]
				   ,[group_handle]
				   ,[unique_compiles]
				   ,[last_user_seek]
				   ,[last_user_scan]
				   ,[avg_total_user_cost]
				   ,[avg_user_impact]
				   ,[system_seeks]
				   ,[last_system_scan]
				   ,[last_system_seek]
				   ,[avg_total_system_cost]
				   ,[avg_system_impact]
				   ,[index_group_handle]
				   ,[index_handle]
				   ,[database_id]
				   ,[object_id]
				   ,[equality_columns]
				   ,[inequality_columns]
				   ,[statement]
				   ,[K]
				   ,[Keys]
				   ,[include]
				   ,[sql_statement]
				   ,[user_seeks]
				   ,[user_scans]
				   ,[est_impact]
				   ,[SecondsUptime]
				   ,[InsertUTCDate])
				SELECT [ServerName]
				   ,[DBName]
				   ,[Schema]
				   ,[Name]
				   ,[index_advantage]
				   ,[group_handle]
				   ,[unique_compiles]
				   ,[last_user_seek]
				   ,[last_user_scan]
				   ,[avg_total_user_cost]
				   ,[avg_user_impact]
				   ,[system_seeks]
				   ,[last_system_scan]
				   ,[last_system_seek]
				   ,[avg_total_system_cost]
				   ,[avg_system_impact]
				   ,[index_group_handle]
				   ,[index_handle]
				   ,[database_id]
				   ,[object_id]
				   ,[equality_columns]
				   ,[inequality_columns]
				   ,[statement]
				   ,[K]
				   ,[Keys]
				   ,[include]
				   ,[sql_statement]
				   ,[user_seeks]
				   ,[user_scans]
				   ,[est_impact]
				   ,[SecondsUptime]
				   ,[InsertUTCDate]
				FROM ['+@server+N'].[FortisAdmin].[srv].[NewIndexOptimizeStatistics]
				WHERE [InsertUTCDate]>='''+cast(@dt as nvarchar(255))+N'''
				  AND [InsertUTCDate]<='''+cast(@dt0 as nvarchar(255))+N''';

				INSERT INTO [srv].[IndicatorServerDayStatistics]
				   ([Server]
				   ,[ExecutionCount]
				   ,[AvgDur]
				   ,[AvgCPUTime]
				   ,[AvgIOLogicalReads]
				   ,[AvgIOLogicalWrites]
				   ,[AvgIOPhysicalReads]
				   ,[DATE])
				SELECT [Server]
				   ,[ExecutionCount]
				   ,[AvgDur]
				   ,[AvgCPUTime]
				   ,[AvgIOLogicalReads]
				   ,[AvgIOLogicalWrites]
				   ,[AvgIOPhysicalReads]
				   ,[DATE]
				FROM ['+@server+N'].[FortisAdmin].[srv].[IndicatorServerDayStatistics] as t_src
				WHERE [DATE]>='''+cast(cast(DateAdd(day,-1,@dt0) as date) as nvarchar(255))+N'''
				and not exists (select top(1) 1 from [srv].[IndicatorServerDayStatistics] as t_trg where t_src.[DATE]=t_trg.[DATE] and t_src.[Server]=t_trg.[Server]);
			end';

			exec sp_executesql @sql;

			set @sql=N'
			begin
				INSERT INTO [srv].[IndexUsageStatsStatistics]
				   ([SERVER]
				   ,[DataBase]
				   ,[SCHEMA_NAME]
				   ,[OBJECT NAME]
				   ,[INDEX NAME]
				   ,[index_advantage]
				   ,[USER_SEEKS]
				   ,[USER_SCANS]
				   ,[USER_LOOKUPS]
				   ,[USER_UPDATES]
				   ,[Last_User_Seek]
				   ,[Last_User_Scan]
				   ,[Last_User_Lookup]
				   ,[Last_User_Update]
				   ,[System_Seeks]
				   ,[System_Scans]
				   ,[System_Lookups]
				   ,[System_Updates]
				   ,[Last_System_Seek]
				   ,[Last_System_Scan]
				   ,[Last_System_Lookup]
				   ,[Last_System_Update]
				   ,[schema_id]
				   ,[object_id]
				   ,[index_id]
				   ,[ObjectType]
				   ,[TYPE_DESC_OBJECT]
				   ,[IndexType]
				   ,[TYPE_DESC_INDEX]
				   ,[Is_Unique]
				   ,[Data_Space_ID]
				   ,[Ignore_Dup_Key]
				   ,[Is_Primary_Key]
				   ,[Is_Unique_Constraint]
				   ,[Fill_Factor]
				   ,[Is_Padded]
				   ,[Is_Disabled]
				   ,[Is_Hypothetical]
				   ,[Allow_Row_Locks]
				   ,[Allow_Page_Locks]
				   ,[Has_Filter]
				   ,[Filter_Definition]
				   ,[Columns]
				   ,[IncludeColumns]
				   ,[InsertUTCDate])
				SELECT [SERVER]
				   ,[DataBase]
				   ,[SCHEMA_NAME]
				   ,[OBJECT NAME]
				   ,[INDEX NAME]
				   ,[index_advantage]
				   ,[USER_SEEKS]
				   ,[USER_SCANS]
				   ,[USER_LOOKUPS]
				   ,[USER_UPDATES]
				   ,[Last_User_Seek]
				   ,[Last_User_Scan]
				   ,[Last_User_Lookup]
				   ,[Last_User_Update]
				   ,[System_Seeks]
				   ,[System_Scans]
				   ,[System_Lookups]
				   ,[System_Updates]
				   ,[Last_System_Seek]
				   ,[Last_System_Scan]
				   ,[Last_System_Lookup]
				   ,[Last_System_Update]
				   ,[schema_id]
				   ,[object_id]
				   ,[index_id]
				   ,[ObjectType]
				   ,[TYPE_DESC_OBJECT]
				   ,[IndexType]
				   ,[TYPE_DESC_INDEX]
				   ,[Is_Unique]
				   ,[Data_Space_ID]
				   ,[Ignore_Dup_Key]
				   ,[Is_Primary_Key]
				   ,[Is_Unique_Constraint]
				   ,[Fill_Factor]
				   ,[Is_Padded]
				   ,[Is_Disabled]
				   ,[Is_Hypothetical]
				   ,[Allow_Row_Locks]
				   ,[Allow_Page_Locks]
				   ,[Has_Filter]
				   ,[Filter_Definition]
				   ,[Columns]
				   ,[IncludeColumns]
				   ,[InsertUTCDate]
				FROM ['+@server+N'].[FortisAdmin].[srv].[IndexUsageStatsStatistics]
				WHERE [InsertUTCDate]>='''+cast(@dt as nvarchar(255))+N'''
				  AND [InsertUTCDate]<='''+cast(@dt0 as nvarchar(255))+N''';

				INSERT INTO [srv].[IndexDefragStatistics]
				   ([Server]
				   ,[db]
				   ,[shema]
				   ,[tb]
				   ,[idx]
				   ,[database_id]
				   ,[index_name]
				   ,[index_type_desc]
				   ,[level]
				   ,[object_id]
				   ,[frag_num]
				   ,[frag]
				   ,[frag_page]
				   ,[page]
				   ,[rec]
				   ,[ghost]
				   ,[func]
				   ,[InsertUTCDate])
				SELECT [Server]
				   ,[db]
				   ,[shema]
				   ,[tb]
				   ,[idx]
				   ,[database_id]
				   ,[index_name]
				   ,[index_type_desc]
				   ,[level]
				   ,[object_id]
				   ,[frag_num]
				   ,[frag]
				   ,[frag_page]
				   ,[page]
				   ,[rec]
				   ,[ghost]
				   ,[func]
				   ,[InsertUTCDate]
				FROM ['+@server+N'].[FortisAdmin].[srv].[IndexDefragStatistics]
				WHERE [InsertUTCDate]>='''+cast(@dt as nvarchar(255))+N'''
				  AND [InsertUTCDate]<='''+cast(@dt0 as nvarchar(255))+N''';
			end';

			exec sp_executesql @sql;

			set @sql=N'
			begin
				INSERT INTO [srv].[DelIndexIncludeStatistics]
				   ([Server]
				   ,[DataBase]
				   ,[SchemaName]
				   ,[ObjectName]
				   ,[ObjectType]
				   ,[ObjectCreateDate]
				   ,[DelIndexName]
				   ,[IndexIsPrimaryKey]
				   ,[IndexType]
				   ,[IndexFragmentation]
				   ,[IndexFragmentCount]
				   ,[IndexAvgFragmentSizeInPages]
				   ,[IndexPages]
				   ,[IndexKeyColumns]
				   ,[IndexIncludedColumns]
				   ,[ActualIndexName]
				   ,[InsertUTCDate])
				SELECT [Server]
				   ,[DataBase]
				   ,[SchemaName]
				   ,[ObjectName]
				   ,[ObjectType]
				   ,[ObjectCreateDate]
				   ,[DelIndexName]
				   ,[IndexIsPrimaryKey]
				   ,[IndexType]
				   ,[IndexFragmentation]
				   ,[IndexFragmentCount]
				   ,[IndexAvgFragmentSizeInPages]
				   ,[IndexPages]
				   ,[IndexKeyColumns]
				   ,[IndexIncludedColumns]
				   ,[ActualIndexName]
				   ,[InsertUTCDate]
				FROM ['+@server+N'].[FortisAdmin].[srv].[DelIndexIncludeStatistics]
				WHERE [InsertUTCDate]>='''+cast(@dt as nvarchar(255))+N'''
				  AND [InsertUTCDate]<='''+cast(@dt0 as nvarchar(255))+N''';
			end';

			exec sp_executesql @sql;

			set @sql=N'
			begin
				INSERT INTO [srv].[BigQueryStatistics]
				   ([Server]
				   ,[creation_time]
				   ,[last_execution_time]
				   ,[execution_count]
				   ,[CPU]
				   ,[AvgCPUTime]
				   ,[TotDuration]
				   ,[AvgDur]
				   ,[AvgIOLogicalReads]
				   ,[AvgIOLogicalWrites]
				   ,[AggIO]
				   ,[AvgIO]
				   ,[AvgIOPhysicalReads]
				   ,[plan_generation_num]
				   ,[AvgRows]
				   ,[AvgDop]
				   ,[AvgGrantKb]
				   ,[AvgUsedGrantKb]
				   ,[AvgIdealGrantKb]
				   ,[AvgReservedThreads]
				   ,[AvgUsedThreads]
				   ,[query_text]
				   ,[database_name]
				   ,[object_name]
				   ,[query_plan]
				   ,[sql_handle]
				   ,[plan_handle]
				   ,[query_hash]
				   ,[query_plan_hash]
				   ,[InsertUTCDate])
				SELECT [Server]
				   ,[creation_time]
				   ,[last_execution_time]
				   ,[execution_count]
				   ,[CPU]
				   ,[AvgCPUTime]
				   ,[TotDuration]
				   ,[AvgDur]
				   ,[AvgIOLogicalReads]
				   ,[AvgIOLogicalWrites]
				   ,[AggIO]
				   ,[AvgIO]
				   ,[AvgIOPhysicalReads]
				   ,[plan_generation_num]
				   ,[AvgRows]
				   ,[AvgDop]
				   ,[AvgGrantKb]
				   ,[AvgUsedGrantKb]
				   ,[AvgIdealGrantKb]
				   ,[AvgReservedThreads]
				   ,[AvgUsedThreads]
				   ,[query_text]
				   ,[database_name]
				   ,[object_name]
				   ,cast([query_plan] as XML)
				   ,[sql_handle]
				   ,[plan_handle]
				   ,[query_hash]
				   ,[query_plan_hash]
				   ,[InsertUTCDate]
				FROM ['+@server+N'].[FortisAdmin].[srv].[vBigQueryStatisticsRemote]
				WHERE [InsertUTCDate]>='''+cast(@dt as nvarchar(255))+N'''
				  AND [InsertUTCDate]<='''+cast(@dt0 as nvarchar(255))+N''';
			end';

			exec sp_executesql @sql;

			set @sql=N'
			begin
				INSERT INTO [srv].[TableStatistics]
				   ([ServerName]
				   ,[DBName]
				   ,[SchemaName]
				   ,[TableName]
				   ,[CountRows]
				   ,[DataKB]
				   ,[IndexSizeKB]
				   ,[UnusedKB]
				   ,[ReservedKB]
				   ,[InsertUTCDate]
				   ,[CountRowsBack]
				   ,[CountRowsNext]
				   ,[DataKBBack]
				   ,[DataKBNext]
				   ,[IndexSizeKBBack]
				   ,[IndexSizeKBNext]
				   ,[UnusedKBBack]
				   ,[UnusedKBNext]
				   ,[ReservedKBBack]
				   ,[ReservedKBNext]
				   ,[TotalPageSizeKB]
				   ,[TotalPageSizeKBBack]
				   ,[TotalPageSizeKBNext]
				   ,[UsedPageSizeKB]
				   ,[UsedPageSizeKBBack]
				   ,[UsedPageSizeKBNext]
				   ,[DataPageSizeKB]
				   ,[DataPageSizeKBBack]
				   ,[DataPageSizeKBNext])
				SELECT [ServerName]
				   ,[DBName]
				   ,[SchemaName]
				   ,[TableName]
				   ,[CountRows]
				   ,[DataKB]
				   ,[IndexSizeKB]
				   ,[UnusedKB]
				   ,[ReservedKB]
				   ,[InsertUTCDate]
				   ,[CountRowsBack]
				   ,[CountRowsNext]
				   ,[DataKBBack]
				   ,[DataKBNext]
				   ,[IndexSizeKBBack]
				   ,[IndexSizeKBNext]
				   ,[UnusedKBBack]
				   ,[UnusedKBNext]
				   ,[ReservedKBBack]
				   ,[ReservedKBNext]
				   ,[TotalPageSizeKB]
				   ,[TotalPageSizeKBBack]
				   ,[TotalPageSizeKBNext]
				   ,[UsedPageSizeKB]
				   ,[UsedPageSizeKBBack]
				   ,[UsedPageSizeKBNext]
				   ,[DataPageSizeKB]
				   ,[DataPageSizeKBBack]
				   ,[DataPageSizeKBNext]
				FROM ['+@server+N'].[FortisAdmin].[srv].[TableStatistics]
				WHERE [InsertUTCDate]>='''+cast(@dt as nvarchar(255))+N'''
				  AND [InsertUTCDate]<='''+cast(@dt0 as nvarchar(255))+N''';

				INSERT INTO [srv].[TableIndexStatistics]
				   ([ServerName]
				   ,[DBName]
				   ,[SchemaName]
				   ,[TableName]
				   ,[IndexUsedForCounts]
				   ,[CountRows]
				   ,[InsertUTCDate])
				SELECT [ServerName]
				   ,[DBName]
				   ,[SchemaName]
				   ,[TableName]
				   ,[IndexUsedForCounts]
				   ,[CountRows]
				   ,[InsertUTCDate]
				FROM ['+@server+N'].[FortisAdmin].[srv].[TableIndexStatistics]
				WHERE [InsertUTCDate]>='''+cast(@dt as nvarchar(255))+N'''
				  AND [InsertUTCDate]<='''+cast(@dt0 as nvarchar(255))+N''';
			end';

			exec sp_executesql @sql;

			set @sql=N'
			begin
				INSERT INTO [srv].[ServerDBFileInfoStatistics]
				   ([ServerName]
				   ,[DBName]
				   ,[File_id]
				   ,[Type_desc]
				   ,[FileName]
				   ,[Drive]
				   ,[Ext]
				   ,[CountPage]
				   ,[SizeMb]
				   ,[SizeGb]
				   ,[InsertUTCDate])
				SELECT [ServerName]
				   ,[DBName]
				   ,[File_id]
				   ,[Type_desc]
				   ,[FileName]
				   ,[Drive]
				   ,[Ext]
				   ,[CountPage]
				   ,[SizeMb]
				   ,[SizeGb]
				   ,[InsertUTCDate]
				FROM ['+@server+N'].[FortisAdmin].[srv].[ServerDBFileInfoStatistics]
				WHERE [InsertUTCDate]>='''+cast(@dt as nvarchar(255))+N'''
				  AND [InsertUTCDate]<='''+cast(@dt0 as nvarchar(255))+N''';

				INSERT INTO [srv].[DefragServers]
				   ([Server]
				   ,[db]
				   ,[shema]
				   ,[table]
				   ,[IndexName]
				   ,[frag_num]
				   ,[frag]
				   ,[page]
				   ,[rec]
				   ,[ts]
				   ,[tf]
				   ,[frag_after]
				   ,[object_id]
				   ,[idx]
				   ,[InsertUTCDate])
				SELECT '''+@server+N''' AS [Server]
				   ,[db]
				   ,[shema]
				   ,[table]
				   ,[IndexName]
				   ,[frag_num]
				   ,[frag]
				   ,[page]
				   ,[rec]
				   ,[ts]
				   ,[tf]
				   ,[frag_after]
				   ,[object_id]
				   ,[idx]
				   ,[InsertUTCDate]
				FROM ['+@server+N'].[FortisAdmin].[srv].[Defrag]
				WHERE [InsertUTCDate]>='''+cast(@dt as nvarchar(255))+N'''
				  AND [InsertUTCDate]<='''+cast(@dt0 as nvarchar(255))+N''';
			end';

			exec sp_executesql @sql;

			set @sql=N'
			begin
				INSERT INTO [srv].[ShortInfoRunJobsServers]
				   ([Job_GUID]
				   ,[Job_Name]
				   ,[LastFinishRunState]
				   ,[LastRunDurationString]
				   ,[LastRunDurationInt]
				   ,[LastOutcomeMessage]
				   ,[LastRunOutcome]
				   ,[Server]
				   ,[InsertUTCDate]
				   ,[TargetServer]
				   ,[LastDateTime])
				SELECT [Job_GUID]
				   ,[Job_Name]
				   ,[LastFinishRunState]
				   ,[LastRunDurationString]
				   ,[LastRunDurationInt]
				   ,[LastOutcomeMessage]
				   ,[LastRunOutcome]
				   ,[Server]
				   ,[InsertUTCDate]
				   ,[TargetServer]
				   ,[LastDateTime]
				FROM ['+@server+N'].[FortisAdmin].[srv].[ShortInfoRunJobsServers]
				WHERE [InsertUTCDate]>='''+cast(@dt as nvarchar(255))+N'''
				  AND [InsertUTCDate]<='''+cast(@dt0 as nvarchar(255))+N''';

				INSERT INTO [srv].[StatisticsIOInTempDBStatistics]
				   ([Server]
				   ,[physical_name]
				   ,[name]
				   ,[num_of_writes]
				   ,[avg_write_stall_ms]
				   ,[num_of_reads]
				   ,[avg_read_stall_ms]
				   ,[InsertUTCDate])
				SELECT [Server]
				   ,[physical_name]
				   ,[name]
				   ,[num_of_writes]
				   ,[avg_write_stall_ms]
				   ,[num_of_reads]
				   ,[avg_read_stall_ms]
				   ,[InsertUTCDate]
				FROM ['+@server+N'].[FortisAdmin].[srv].[StatisticsIOInTempDBStatistics]
				WHERE [InsertUTCDate]>='''+cast(@dt as nvarchar(255))+N'''
				  AND [InsertUTCDate]<='''+cast(@dt0 as nvarchar(255))+N''';
			end';

			exec sp_executesql @sql;

			set @sql=N'
			begin
				INSERT INTO [srv].[DiskSpaceStatistics]
				   ([Server]
				   ,[Disk]
				   ,[Disk_Space_Mb]
				   ,[Available_Mb]
				   ,[Available_Percent]
				   ,[State]
				   ,[InsertUTCDate])
				SELECT [Server]
				   ,[Disk]
				   ,[Disk_Space_Mb]
				   ,[Available_Mb]
				   ,[Available_Percent]
				   ,[State]
				   ,[InsertUTCDate]
				FROM ['+@server+N'].[FortisAdmin].[srv].[DiskSpaceStatistics]
				WHERE [InsertUTCDate]>='''+cast(@dt as nvarchar(255))+N'''
				  AND [InsertUTCDate]<='''+cast(@dt0 as nvarchar(255))+N''';

				INSERT INTO [srv].[RAMSpaceStatistics]
				   ([Server]
				   ,[TotalAvailOSRam_Mb]
				   ,[RAM_Avail_Percent]
				   ,[Server_physical_memory_Mb]
				   ,[SQL_server_committed_target_Mb]
				   ,[SQL_server_physical_memory_in_use_Mb]
				   ,[State]
				   ,[InsertUTCDate])
				SELECT [Server]
				   ,[TotalAvailOSRam_Mb]
				   ,[RAM_Avail_Percent]
				   ,[Server_physical_memory_Mb]
				   ,[SQL_server_committed_target_Mb]
				   ,[SQL_server_physical_memory_in_use_Mb]
				   ,[State]
				   ,[InsertUTCDate]
				FROM ['+@server+N'].[FortisAdmin].[srv].[RAMSpaceStatistics]
				WHERE [InsertUTCDate]>='''+cast(@dt as nvarchar(255))+N'''
				  AND [InsertUTCDate]<='''+cast(@dt0 as nvarchar(255))+N''';
			end';

			exec sp_executesql @sql;

			set @sql=N'
			begin
				INSERT INTO [srv].[BigQueryGroupStatistics]
				   ([Server]
				   ,[creation_time]
				   ,[last_execution_time]
				   ,[execution_count]
				   ,[CPU]
				   ,[AvgCPUTime]
				   ,[TotDuration]
				   ,[AvgDur]
				   ,[AvgIOLogicalReads]
				   ,[AvgIOLogicalWrites]
				   ,[AggIO]
				   ,[AvgIO]
				   ,[AvgIOPhysicalReads]
				   ,[plan_generation_num]
				   ,[AvgRows]
				   ,[AvgDop]
				   ,[AvgGrantKb]
				   ,[AvgUsedGrantKb]
				   ,[AvgIdealGrantKb]
				   ,[AvgReservedThreads]
				   ,[AvgUsedThreads]
				   ,[query_text]
				   ,[database_name]
				   ,[object_name]
				   ,[query_plan]
				   ,[sql_handle]
				   ,[plan_handle]
				   ,[query_hash]
				   ,[query_plan_hash]
				   ,[InsertUTCDate])
				SELECT [Server]
				   ,[creation_time]
				   ,[last_execution_time]
				   ,[execution_count]
				   ,[CPU]
				   ,[AvgCPUTime]
				   ,[TotDuration]
				   ,[AvgDur]
				   ,[AvgIOLogicalReads]
				   ,[AvgIOLogicalWrites]
				   ,[AggIO]
				   ,[AvgIO]
				   ,[AvgIOPhysicalReads]
				   ,[plan_generation_num]
				   ,[AvgRows]
				   ,[AvgDop]
				   ,[AvgGrantKb]
				   ,[AvgUsedGrantKb]
				   ,[AvgIdealGrantKb]
				   ,[AvgReservedThreads]
				   ,[AvgUsedThreads]
				   ,[query_text]
				   ,[database_name]
				   ,[object_name]
				   ,cast([query_plan] as XML)
				   ,[sql_handle]
				   ,[plan_handle]
				   ,[query_hash]
				   ,[query_plan_hash]
				   ,[InsertUTCDate]
				FROM ['+@server+N'].[FortisAdmin].[srv].[vBigQueryGroupStatisticsRemote];
			end';

			exec sp_executesql @sql;

			set @sql=N'
			begin
				INSERT INTO [srv].[DBFileStatistics]
				   ([Server]
				   ,[DBName]
				   ,[FileId]
				   ,[NumberReads]
				   ,[BytesRead]
				   ,[IoStallReadMS]
				   ,[NumberWrites]
				   ,[BytesWritten]
				   ,[IoStallWriteMS]
				   ,[IoStallMS]
				   ,[BytesOnDisk]
				   ,[TimeStamp]
				   ,[FileHandle]
				   ,[Type_desc]
				   ,[FileName]
				   ,[Drive]
				   ,[Physical_Name]
				   ,[Ext]
				   ,[CountPage]
				   ,[SizeMb]
				   ,[SizeGb]
				   ,[Growth]
				   ,[GrowthMb]
				   ,[GrowthGb]
				   ,[GrowthPercent]
				   ,[is_percent_growth]
				   ,[database_id]
				   ,[State]
				   ,[StateDesc]
				   ,[IsMediaReadOnly]
				   ,[IsReadOnly]
				   ,[IsSpace]
				   ,[IsNameReserved]
				   ,[CreateLsn]
				   ,[DropLsn]
				   ,[ReadOnlyLsn]
				   ,[ReadWriteLsn]
				   ,[DifferentialBaseLsn]
				   ,[DifferentialBaseGuid]
				   ,[DifferentialBaseTime]
				   ,[RedoStartLsn]
				   ,[RedoStartForkGuid]
				   ,[RedoTargetLsn]
				   ,[RedoTargetForkGuid]
				   ,[BackupLsn]
				   ,[InsertUTCDate])
				SELECT [Server]
				   ,[DBName]
				   ,[FileId]
				   ,[NumberReads]
				   ,[BytesRead]
				   ,[IoStallReadMS]
				   ,[NumberWrites]
				   ,[BytesWritten]
				   ,[IoStallWriteMS]
				   ,[IoStallMS]
				   ,[BytesOnDisk]
				   ,[TimeStamp]
				   ,[FileHandle]
				   ,[Type_desc]
				   ,[FileName]
				   ,[Drive]
				   ,[Physical_Name]
				   ,[Ext]
				   ,[CountPage]
				   ,[SizeMb]
				   ,[SizeGb]
				   ,[Growth]
				   ,[GrowthMb]
				   ,[GrowthGb]
				   ,[GrowthPercent]
				   ,[is_percent_growth]
				   ,[database_id]
				   ,[State]
				   ,[StateDesc]
				   ,[IsMediaReadOnly]
				   ,[IsReadOnly]
				   ,[IsSpace]
				   ,[IsNameReserved]
				   ,[CreateLsn]
				   ,[DropLsn]
				   ,[ReadOnlyLsn]
				   ,[ReadWriteLsn]
				   ,[DifferentialBaseLsn]
				   ,[DifferentialBaseGuid]
				   ,[DifferentialBaseTime]
				   ,[RedoStartLsn]
				   ,[RedoStartForkGuid]
				   ,[RedoTargetLsn]
				   ,[RedoTargetForkGuid]
				   ,[BackupLsn]
				   ,[InsertUTCDate]
				FROM ['+@server+N'].[FortisAdmin].[srv].[DBFileStatistics];
			end';

			exec sp_executesql @sql;--,
					  --N'@IsSRV bit',  
					  --@IsSRV = @IsSRV;
		end

		FETCH NEXT FROM sql_cursor
		INTO @server;
	end

	CLOSE sql_cursor;
	DEALLOCATE sql_cursor;

	drop table #tbl;

	INSERT INTO [srv].[DefragServers]
			   ([Server]
			   ,[db]
			   ,[shema]
			   ,[table]
			   ,[IndexName]
			   ,[frag_num]
			   ,[frag]
			   ,[page]
			   ,[rec]
			   ,[ts]
			   ,[tf]
			   ,[frag_after]
			   ,[object_id]
			   ,[idx]
			   ,[InsertUTCDate])
		SELECT @servername AS [Server]
			   ,[db]
			   ,[shema]
			   ,[table]
			   ,[IndexName]
			   ,[frag_num]
			   ,[frag]
			   ,[page]
			   ,[rec]
			   ,[ts]
			   ,[tf]
			   ,[frag_after]
			   ,[object_id]
			   ,[idx]
			   ,[InsertUTCDate]
			FROM [srv].[Defrag]
			WHERE [InsertUTCDate]>=@dt
			  AND [InsertUTCDate]<=@dt0;
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indInsertDate] from table [srv].[Deadlocks]
--
DROP INDEX [indInsertDate] ON [srv].[Deadlocks]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop primary key [PK_Deadlocks] on table [srv].[Deadlocks]
--
ALTER TABLE [srv].[Deadlocks]
  DROP CONSTRAINT [PK_Deadlocks]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create primary key [PK_Deadlocks] on table [srv].[Deadlocks]
--
ALTER TABLE [srv].[Deadlocks]
  ADD CONSTRAINT [PK_Deadlocks] PRIMARY KEY CLUSTERED ([Id])
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indInsertDate] on table [srv].[Deadlocks]
--
CREATE INDEX [indInsertDate]
  ON [srv].[Deadlocks] ([InsertDate])
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on index [srv].[Deadlocks].[indInsertDate]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Индекс по InsertDate', 'SCHEMA', N'srv', 'TABLE', N'Deadlocks', 'INDEX', N'indInsertDate'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indInsertUTCDate] from table [srv].[ddl_log_all]
--
DROP INDEX [indInsertUTCDate] ON [srv].[ddl_log_all]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop primary key [PK_ddl_log_all] on table [srv].[ddl_log_all]
--
ALTER TABLE [srv].[ddl_log_all]
  DROP CONSTRAINT [PK_ddl_log_all]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create primary key [PK_ddl_log_all] on table [srv].[ddl_log_all]
--
ALTER TABLE [srv].[ddl_log_all]
  ADD CONSTRAINT [PK_ddl_log_all] PRIMARY KEY CLUSTERED ([DDL_Log_GUID]) WITH (FILLFACTOR = 95)
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indInsertUTCDate] on table [srv].[ddl_log_all]
--
CREATE INDEX [indInsertUTCDate]
  ON [srv].[ddl_log_all] ([InsertUTCDate])
  WITH (FILLFACTOR = 95)
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on index [srv].[ddl_log_all].[indInsertUTCDate]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Индекс по InsertUTCDate', 'SCHEMA', N'srv', 'TABLE', N'ddl_log_all', 'INDEX', N'indInsertUTCDate'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop primary key [PK_ddl_log] on table [srv].[ddl_log]
--
ALTER TABLE [srv].[ddl_log]
  DROP CONSTRAINT [PK_ddl_log]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create primary key [PK_ddl_log] on table [srv].[ddl_log]
--
ALTER TABLE [srv].[ddl_log]
  ADD CONSTRAINT [PK_ddl_log] PRIMARY KEY CLUSTERED ([DDL_Log_GUID]) WITH (FILLFACTOR = 95)
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on table [srv].[DBListNotDelete]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Белый список БД, которых нельзя удалять', 'SCHEMA', N'srv', 'TABLE', N'DBListNotDelete'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [srv].[AddDBListNotDelete]
--
GO


-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE   PROCEDURE [srv].[AddDBListNotDelete]
	@DB_Name NVARCHAR(255),
	@IsAdd BIT=1 --Признак добавления (1-добавление, 0-удаление)
AS
BEGIN
	/*
		Добавляет БД в белый список или удаляет ее из этого списка
	*/

	SET QUERY_GOVERNOR_COST_LIMIT 0;
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	if(exists(select top(1) 1 from [srv].[DBListNotDelete]))
	BEGIN
		IF(@IsAdd=1)
		BEGIN
			INSERT INTO [srv].[DBListNotDelete]
			           ([Name]
			           ,[IsWhiteListAll])
			     select @DB_Name, 1;
		END
		ELSE IF(@IsAdd=0)
		BEGIN
			DELETE FROM [srv].[DBListNotDelete]
			WHERE [Name]=@DB_Name;
		END
	END
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [srv].[AddDBListNotDelete]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Добавляет БД в белый список или удаляет ее из этого списка', 'SCHEMA', N'srv', 'PROCEDURE', N'AddDBListNotDelete'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop default constraint [DF_DBFileStatistics_Server] on table [srv].[DBFileStatistics]
--
ALTER TABLE [srv].[DBFileStatistics]
  DROP CONSTRAINT [DF_DBFileStatistics_Server]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add default constraint [DF_DBFileStatistics_Server] on table [srv].[DBFileStatistics]
--
ALTER TABLE [srv].[DBFileStatistics]
  ADD CONSTRAINT [DF_DBFileStatistics_Server] DEFAULT (CONVERT([nvarchar](255),serverproperty(N'MachineName'))) FOR [Server]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on table [srv].[DBFileStatistics]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Статистика по файлам БД', 'SCHEMA', N'srv', 'TABLE', N'DBFileStatistics'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create view [inf].[vDBSizeDrive]
--
GO
CREATE view [inf].[vDBSizeDrive] as
SELECT [Server], [DBName], [Drive]
      ,SUM([SizeMb]) as [SizeMb]
      ,SUM([GrowthMb]) as [GrowthMb]
      ,cast([InsertUTCDate] as date) as [DATE]
  FROM [srv].[DBFileStatistics]
  where [Server] not like 'HLT%'
  and [Server] not like 'STG%'
  group by [Server], [DBName], [Drive], cast([InsertUTCDate] as date)
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on view [inf].[vDBSizeDrive]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Информация по размерам БД в разрезе логических дисков по собранным заранее статистикам', 'SCHEMA', N'inf', 'VIEW', N'vDBSizeDrive'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop primary key [PK_DBFile] on table [srv].[DBFile]
--
ALTER TABLE [srv].[DBFile]
  DROP CONSTRAINT [PK_DBFile]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [IX_DBFile] from table [srv].[DBFile]
--
DROP INDEX [IX_DBFile] ON [srv].[DBFile]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create primary key [PK_DBFile] on table [srv].[DBFile]
--
ALTER TABLE [srv].[DBFile]
  ADD CONSTRAINT [PK_DBFile] PRIMARY KEY CLUSTERED ([DBFile_GUID]) WITH (FILLFACTOR = 95)
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [IX_DBFile] on table [srv].[DBFile]
--
CREATE UNIQUE INDEX [IX_DBFile]
  ON [srv].[DBFile] ([DB_ID], [File_ID], [Server])
  WITH (FILLFACTOR = 95)
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on index [srv].[DBFile].[IX_DBFile]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Уникальный индекс (естественный ключ)', 'SCHEMA', N'srv', 'TABLE', N'DBFile', 'INDEX', N'IX_DBFile'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [srv].[MergeDBFileInfo]
--
GO




ALTER PROCEDURE [srv].[MergeDBFileInfo]
AS
BEGIN
	/*
		обновляет таблицу файлов БД
	*/
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	declare @servername nvarchar(255)=cast(SERVERPROPERTY(N'MachineName') as nvarchar(255));

	;merge [srv].[DBFile] as f
	using [inf].[ServerDBFileInfo] as ff
	on f.File_ID=ff.File_ID and f.DB_ID=ff.[database_id] and f.[Server]=ff.[Server]
	when matched then
		update set UpdateUTCDate	= getUTCDate()
				 ,[Name]			= ff.[FileName]			
				 ,[Drive]			= ff.[Drive]			
				 ,[Physical_Name]	= ff.[Physical_Name]	
				 ,[Ext]				= ff.[Ext]				
				 ,[Growth]			= ff.[Growth]			
				 ,[IsPercentGrowth]	= ff.[is_percent_growth]	
				 ,[SizeMb]			= ff.[SizeMb]			
				 ,[DiffSizeMb]		= round(ff.[SizeMb]-f.[SizeMb],3)	
	when not matched by target then
		insert (
				[Server]
				,[Name]
				,[Drive]
				,[Physical_Name]
				,[Ext]
				,[Growth]
				,[IsPercentGrowth]
				,[DB_ID]
				,[DB_Name]
				,[SizeMb]
				,[File_ID]
				,[DiffSizeMb]
			   )
		values (
				ff.[Server]
				,ff.[FileName]
				,ff.[Drive]
				,ff.[Physical_Name]
				,ff.[Ext]
				,ff.[Growth]
				,ff.[is_percent_growth]
				,ff.[database_id]
				,ff.[DB_Name]
				,ff.[SizeMb]
				,ff.[File_id]
				,0
			   )
	when not matched by source and f.[Server]=@servername then delete;
END


GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on table [srv].[BigQueryStatistics]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Статистика тяжелых запросов', 'SCHEMA', N'srv', 'TABLE', N'BigQueryStatistics'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on view [srv].[vBigQueryStatisticsRemote]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Тяжелые запросы для удаленного сбора', 'SCHEMA', N'srv', 'VIEW', N'vBigQueryStatisticsRemote'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on table [srv].[BigQueryGroupStatistics]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Группировка по тяжелым запросам', 'SCHEMA', N'srv', 'TABLE', N'BigQueryGroupStatistics'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [srv].[AutoBigQueryStatistics]
--
GO


-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER   PROCEDURE [srv].[AutoBigQueryStatistics]
AS
BEGIN
	/*
		Сбор данных по самым длительным запросам MS SQL Server
	*/
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	declare @servername nvarchar(255)=cast(SERVERPROPERTY(N'MachineName') as nvarchar(255));

	SELECT @servername AS [Server]
            ,[creation_time]
			,[last_execution_time]
			,[execution_count]
			,[CPU]
			,[AvgCPUTime]
			,[TotDuration]
			,[AvgDur]
			,[AvgIOLogicalReads]
			,[AvgIOLogicalWrites]
			,[AggIO]
			,[AvgIO]
			,[AvgIOPhysicalReads]
			,[plan_generation_num]
			,[AvgRows]
			,[AvgDop]
			,[AvgGrantKb]
			,[AvgUsedGrantKb]
			,[AvgIdealGrantKb]
			,[AvgReservedThreads]
			,[AvgUsedThreads]
			,[query_text]
			,[database_name]
			,[object_name]
			,[query_plan]
			,[sql_handle]
			,[plan_handle]
			,[query_hash]
			,[query_plan_hash]
			into #tbl
	 FROM [inf].[vBigQuery];

	INSERT INTO [srv].[BigQueryStatistics]
           ([Server]
           ,[creation_time]
           ,[last_execution_time]
           ,[execution_count]
           ,[CPU]
           ,[AvgCPUTime]
           ,[TotDuration]
           ,[AvgDur]
           ,[AvgIOLogicalReads]
           ,[AvgIOLogicalWrites]
           ,[AggIO]
           ,[AvgIO]
           ,[AvgIOPhysicalReads]
           ,[plan_generation_num]
           ,[AvgRows]
           ,[AvgDop]
           ,[AvgGrantKb]
           ,[AvgUsedGrantKb]
           ,[AvgIdealGrantKb]
           ,[AvgReservedThreads]
           ,[AvgUsedThreads]
           ,[query_text]
           ,[database_name]
           ,[object_name]
           ,[query_plan]
           ,[sql_handle]
           ,[plan_handle]
           ,[query_hash]
           ,[query_plan_hash])
	 SELECT [Server]
           ,[creation_time]
           ,[last_execution_time]
           ,[execution_count]
           ,[CPU]
           ,[AvgCPUTime]
           ,[TotDuration]
           ,[AvgDur]
           ,[AvgIOLogicalReads]
           ,[AvgIOLogicalWrites]
           ,[AggIO]
           ,[AvgIO]
           ,[AvgIOPhysicalReads]
           ,[plan_generation_num]
           ,[AvgRows]
           ,[AvgDop]
           ,[AvgGrantKb]
           ,[AvgUsedGrantKb]
           ,[AvgIdealGrantKb]
           ,[AvgReservedThreads]
           ,[AvgUsedThreads]
           ,[query_text]
           ,[database_name]
           ,[object_name]
           ,[query_plan]
           ,[sql_handle]
           ,[plan_handle]
           ,[query_hash]
           ,[query_plan_hash]
	 FROM #tbl;

	 --подсчет общего индикатора производительности по всему экземпляру MS SQL SERVER
	 INSERT INTO [srv].[IndicatorServerDayStatistics]
           ([Server]
           ,[ExecutionCount]
           ,[AvgDur]
           ,[AvgCPUTime]
           ,[AvgIOLogicalReads]
           ,[AvgIOLogicalWrites]
           ,[AvgIOPhysicalReads]
           ,[DATE])
	SELECT	@servername AS [Server],
			SUM([execution_count]),
			AVG([AvgDur]),
			AVG([AvgCPUTime]),
            AVG([AvgIOLogicalReads]),
            AVG([AvgIOLogicalWrites]),
            AVG([AvgIOPhysicalReads]),
			CAST(GETUTCDATE() AS DATE)
	FROM #tbl;

	--группируем по запросам за все время сбора
	truncate table [srv].[BigQueryGroupStatistics];

	INSERT INTO [srv].[BigQueryGroupStatistics]
           ([Server]
           ,[creation_time]
           ,[last_execution_time]
           ,[execution_count]
           ,[CPU]
           ,[AvgCPUTime]
           ,[TotDuration]
           ,[AvgDur]
           ,[AvgIOLogicalReads]
           ,[AvgIOLogicalWrites]
           ,[AggIO]
           ,[AvgIO]
           ,[AvgIOPhysicalReads]
           ,[plan_generation_num]
           ,[AvgRows]
           ,[AvgDop]
           ,[AvgGrantKb]
           ,[AvgUsedGrantKb]
           ,[AvgIdealGrantKb]
           ,[AvgReservedThreads]
           ,[AvgUsedThreads]
           ,[query_text]
           ,[database_name]
           ,[object_name]
           ,[query_plan]
           ,[sql_handle]
           ,[plan_handle]
           ,[query_hash]
           ,[query_plan_hash]
           ,[InsertUTCDate])
	select [Server]
      ,max([creation_time])			as [creation_time]
      ,max([last_execution_time])	as [last_execution_time]
      ,sum([execution_count])		as [execution_count]
      ,max([CPU])					as [CPU]
      ,max([AvgCPUTime])			as [AvgCPUTime]
      ,max([TotDuration])			as [TotDuration]
      ,max([AvgDur])				as [AvgDur]
      ,max([AvgIOLogicalReads])		as [AvgIOLogicalReads]
      ,max([AvgIOLogicalWrites])	as [AvgIOLogicalWrites]
      ,max([AggIO])					as [AggIO]
      ,max([AvgIO])					as [AvgIO]
      ,max([AvgIOPhysicalReads])	as [AvgIOPhysicalReads]
      ,max([plan_generation_num])	as [plan_generation_num]
      ,max([AvgRows])				as [AvgRows]
      ,max([AvgDop])				as [AvgDop]
      ,max([AvgGrantKb])			as [AvgGrantKb]
      ,max([AvgUsedGrantKb])		as [AvgUsedGrantKb]
      ,max([AvgIdealGrantKb])		as [AvgIdealGrantKb]
      ,max([AvgReservedThreads])	as [AvgReservedThreads]
      ,max([AvgUsedThreads])		as [AvgUsedThreads]
      ,[query_text]
      ,max([database_name])			as [database_name]
      ,max([object_name])			as [object_name]
      ,cast(max(cast([query_plan] as nvarchar(max))) as XML) as [query_plan]
      ,max([sql_handle])			as [sql_handle]
      ,max([plan_handle])			as [plan_handle]
      ,max([query_hash])			as [query_hash]
      ,max([query_plan_hash])		as [query_plan_hash]
	  ,max([InsertUTCDate])			as [InsertUTCDate]
	from [srv].[BigQueryStatistics]
	group by [Server], [query_text];

	DROP TABLE #tbl;
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [srv].[AutoDataCollection]
--
GO


-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER   PROCEDURE [srv].[AutoDataCollection]
AS
BEGIN
	/*
		Сбор данных
	*/

	SET QUERY_GOVERNOR_COST_LIMIT 0;
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	declare @servername nvarchar(255)=cast(SERVERPROPERTY(N'MachineName') as nvarchar(255));

	EXEC [srv].[AutoStatisticsDiskAndRAMSpace];
	EXEC [srv].[AutoStatisticsFileDB];
    EXEC [srv].[AutoBigQueryStatistics];

	if(@servername<>N'PRD-1CSQL-01') EXEC [srv].[AutoIndexStatistics];

	EXEC [srv].[AutoShortInfoRunJobs];
	EXEC [srv].[AutoStatisticsIOInTempDBStatistics];
	EXEC [srv].[AutoNewIndexOptimizeStatistics];
	EXEC [srv].[AutoWaitStatistics];
	EXEC [srv].[AutoReadWriteTablesStatistics];
	EXEC [srv].[InsertTableStatistics];
	EXEC [srv].[AutoDBFile];
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on view [srv].[vBigQueryGroupStatisticsRemote]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Группировка по тяжелым запросам для удаленного сбора', 'SCHEMA', N'srv', 'VIEW', N'vBigQueryGroupStatisticsRemote'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indInsertUTCDate] from table [srv].[BackupSettings]
--
DROP INDEX [indInsertUTCDate] ON [srv].[BackupSettings]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop primary key [PK_BackupSettings_1] on table [srv].[BackupSettings]
--
ALTER TABLE [srv].[BackupSettings]
  DROP CONSTRAINT [PK_BackupSettings_1]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create primary key [PK_BackupSettings_1] on table [srv].[BackupSettings]
--
ALTER TABLE [srv].[BackupSettings]
  ADD CONSTRAINT [PK_BackupSettings_1] PRIMARY KEY CLUSTERED ([DBID]) WITH (FILLFACTOR = 95)
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indInsertUTCDate] on table [srv].[BackupSettings]
--
CREATE INDEX [indInsertUTCDate]
  ON [srv].[BackupSettings] ([InsertUTCDate])
  WITH (FILLFACTOR = 95)
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on index [srv].[BackupSettings].[indInsertUTCDate]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Индекс по InsertUTCDate', 'SCHEMA', N'srv', 'TABLE', N'BackupSettings', 'INDEX', N'indInsertUTCDate'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [srv].[RunFullBackupDB]
--
GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER   PROCEDURE [srv].[RunFullBackupDB]
	@ClearLog   bit=1 --усекать ли журнал транзакций
	,@IsExtName bit=1 --добавлять ли к имени дату
	,@IsCHECKDB bit=0 --проверять ли резервную копию
	,@IsAllDB	bit=0 --брать ли в обработку все БД
	,@FullPathBackup nvarchar(4000)='\\backup-srv01\SQL_Backups\1C\CHECKDB\'--полный путь к каталогу для создания резервных копий (работает при @IsAllDB=1)
AS
BEGIN
	/*
		Создание полной резервной копии БД с предварительной проверкой на целостность самой БД
	*/
	SET NOCOUNT ON;

    declare @dt datetime=getdate();
	declare @year int=YEAR(@dt);
	declare @month int=MONTH(@dt);
	declare @day int=DAY(@dt);
	declare @hour int=DatePart(hour, @dt);
	declare @minute int=DatePart(minute, @dt);
	declare @second int=DatePart(second, @dt);
	declare @pathBackup nvarchar(255);
	declare @pathstr nvarchar(255);
	declare @DBName nvarchar(255);
	declare @backupName nvarchar(255);
	declare @sql nvarchar(max);
	declare @backupSetId as int;
	declare @FileNameLog nvarchar(255);

	declare @tbllog table(
		[DBName] [nvarchar](255) NOT NULL,
		[FileNameLog] [nvarchar](255) NOT NULL
	);
	
	declare @tbl table (
		[DBName] [nvarchar](255) NOT NULL,
		[FullPathBackup] [nvarchar](255) NOT NULL
	);
	
	if(@IsAllDB=1)
	begin
		insert into @tbl (
		           [DBName]
		           ,[FullPathBackup]
		)
		select		[name] as [DBName]
		           ,@FullPathBackup
		from sys.databases
		where [database_id]>4
		and [name]<>N'FortisAdmin'
		and [state]=0
		and [user_access]=0;
	end
	else
	begin
		insert into @tbl (
		           [DBName]
		           ,[FullPathBackup]
		)
		select		DB_NAME([DBID])
		           ,[FullPathBackup]
		from [srv].[BackupSettings];
	end

	insert into @tbllog([DBName], [FileNameLog])
	select t.[DBName], tt.[FileName] as [FileNameLog]
	from @tbl as t
	inner join [inf].[ServerDBFileInfo] as tt on t.[DBName]=DB_NAME(tt.[database_id])
	where tt.[Type_desc]='LOG';
	
	while(exists(select top(1) 1 from @tbl))
	begin
		set @backupSetId=NULL;

		select top(1)
		@DBName=[DBName],
		@pathBackup=[FullPathBackup]
		from @tbl;
		
		if(@IsExtName=1)
		begin
			set @backupName=@DBName+N'_Full_backup_'+cast(@year as nvarchar(255))+N'_'+cast(@month as nvarchar(255))+N'_'+cast(@day as nvarchar(255))--+N'_'
							--+cast(@hour as nvarchar(255))+N'_'+cast(@minute as nvarchar(255))+N'_'+cast(@second as nvarchar(255));
		end
		else
		begin
			set @backupName=@DBName;
		end

		set @pathstr=@pathBackup+@backupName+N'.bak';

		if(@IsCHECKDB=1)
		begin
			set @sql=N'DBCC CHECKDB(N'+N''''+@DBName+N''''+N')  WITH NO_INFOMSGS';

			exec(@sql);
		end
	
		set @sql=N'BACKUP DATABASE ['+@DBName+N'] TO DISK = N'+N''''+@pathstr+N''''+
				 N' WITH NOFORMAT, NOINIT, NAME = N'+N''''+@backupName+N''''+
				 N', CHECKSUM, STOP_ON_ERROR, SKIP, REWIND, COMPRESSION, STATS = 10;';
	
		exec(@sql);

		select @backupSetId = position
		from msdb..backupset where database_name=@DBName
		and backup_set_id=(select max(backup_set_id) from msdb..backupset where database_name=@DBName);

		set @sql=N'Ошибка верификации. Сведения о резервном копировании для базы данных "'+@DBName+'" не найдены.';

		if (@backupSetId is null)
		begin
			raiserror(@sql, 16, 1);
		end
		else
		begin
			set @sql=N'RESTORE VERIFYONLY FROM DISK = N'+''''+@pathstr+N''''+N' WITH FILE = '+cast(@backupSetId as nvarchar(255));

			exec(@sql);
		end

		if(@ClearLog=1)
		begin
			while(exists(select top(1) 1 from @tbllog where [DBName]=@DBName))
			begin
				select top(1)
				@FileNameLog=FileNameLog
				from @tbllog
				where DBName=@DBName;
			
				set @sql=N'USE ['+@DBName+N'];'+N' DBCC SHRINKFILE (N'+N''''+@FileNameLog+N''''+N' , 0, TRUNCATEONLY)';

				exec(@sql);

				delete from @tbllog
				where FileNameLog=@FileNameLog
				and DBName=@DBName;
			end
		end
		
		delete from @tbl
		where [DBName]=@DBName;
	end
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop primary key [PK_Address] on table [srv].[Address]
--
ALTER TABLE [srv].[Address]
  DROP CONSTRAINT [PK_Address]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop unique key [AK_Address] on table [srv].[Address]
--
ALTER TABLE [srv].[Address]
  DROP CONSTRAINT [AK_Address]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create primary key [PK_Address] on table [srv].[Address]
--
ALTER TABLE [srv].[Address]
  ADD CONSTRAINT [PK_Address] PRIMARY KEY CLUSTERED ([Address_GUID]) WITH (FILLFACTOR = 95)
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create unique key [AK_Address] on table [srv].[Address]
--
ALTER TABLE [srv].[Address]
  ADD CONSTRAINT [AK_Address] UNIQUE ([Recipient_GUID], [Address]) WITH (FILLFACTOR = 95)
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indInsertUTCDate] from table [srv].[ActiveConnectionStatistics]
--
DROP INDEX [indInsertUTCDate] ON [srv].[ActiveConnectionStatistics]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop primary key [PK_ActiveConnectionStatistics] on table [srv].[ActiveConnectionStatistics]
--
ALTER TABLE [srv].[ActiveConnectionStatistics]
  DROP CONSTRAINT [PK_ActiveConnectionStatistics]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indSession] from table [srv].[ActiveConnectionStatistics]
--
DROP INDEX [indSession] ON [srv].[ActiveConnectionStatistics]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create primary key [PK_ActiveConnectionStatistics] on table [srv].[ActiveConnectionStatistics]
--
ALTER TABLE [srv].[ActiveConnectionStatistics]
  ADD CONSTRAINT [PK_ActiveConnectionStatistics] PRIMARY KEY CLUSTERED ([Row_GUID]) WITH (FILLFACTOR = 95)
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indSession] on table [srv].[ActiveConnectionStatistics]
--
CREATE UNIQUE INDEX [indSession]
  ON [srv].[ActiveConnectionStatistics] ([ServerName], [SessionID], [LoginName], [DBName], [LoginTime])
  WITH (FILLFACTOR = 95)
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indInsertUTCDate] on table [srv].[ActiveConnectionStatistics]
--
CREATE INDEX [indInsertUTCDate]
  ON [srv].[ActiveConnectionStatistics] ([InsertUTCDate])
  WITH (FILLFACTOR = 95)
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [srv].[DeleteArchive]
--
GO




ALTER PROCEDURE [srv].[DeleteArchive]
	@day int=14 -- кол-во дней, по которым определяется старость записи
AS
BEGIN
	/*
		удаление старых архивных записей из архивов
	*/

	SET QUERY_GOVERNOR_COST_LIMIT 0;
	SET NOCOUNT ON;

	while(exists(select top(1) 1 from [srv].[ErrorInfoArchive] where InsertUTCDate<=dateadd(day,-@day,getUTCDate())))
	begin
		delete
		from [srv].[ErrorInfoArchive]
		where InsertUTCDate<=dateadd(day,-@day,getUTCDate());
	end

	while(exists(select top(1) 1 from [srv].[ddl_log_all] where InsertUTCDate<=dateadd(day,-@day,getUTCDate())))
	begin
		delete
		from [srv].[ddl_log_all]
		where InsertUTCDate<=dateadd(day,-@day,getUTCDate());
	end

	while(exists(select top(1) 1 from [srv].[Defrag] where InsertUTCDate<=dateadd(day,-@day,getUTCDate())))
	begin
		delete
		from [srv].[Defrag]
		where InsertUTCDate<=dateadd(day,-@day,getUTCDate());
	end

	while(exists(select top(1) 1 from [srv].[TableIndexStatistics] where InsertUTCDate<=dateadd(day,-@day,getUTCDate())))
	begin
		delete
		from [srv].[TableIndexStatistics]
		where InsertUTCDate<=dateadd(day,-@day,getUTCDate());
	end

	while(exists(select top(1) 1 from [srv].[TableStatistics] where InsertUTCDate<=dateadd(day,-@day,getUTCDate())))
	begin
		delete
		from [srv].[TableStatistics]
		where InsertUTCDate<=dateadd(day,-@day,getUTCDate());
	end

	while(exists(select top(1) 1 from [srv].[RequestStatisticsArchive] where InsertUTCDate<=dateadd(day,-@day,getUTCDate())))
	begin
		delete
		from [srv].[RequestStatisticsArchive]
		where InsertUTCDate<=dateadd(day,-@day,getUTCDate());
	end

	while(exists(select top(1) 1 from [srv].[ActiveConnectionStatistics] where InsertUTCDate<=dateadd(day,-@day,getUTCDate())))
	begin
		delete
		from [srv].[ActiveConnectionStatistics]
		where InsertUTCDate<=dateadd(day,-@day,getUTCDate());
	end

	while(exists(select top(1) 1 from [srv].[ServerDBFileInfoStatistics] where InsertUTCDate<=dateadd(day,-@day,getUTCDate())))
	begin
		delete
		from [srv].[ServerDBFileInfoStatistics]
		where InsertUTCDate<=dateadd(day,-@day,getUTCDate());
	end

	while(exists(select top(1) 1 from [srv].[KillSession] where InsertUTCDate<=dateadd(day,-@day,getUTCDate())))
	begin
		delete
		from [srv].[KillSession]
		where InsertUTCDate<=dateadd(day,-@day,getUTCDate());
	end

	while(exists(select top(1) 1 from [srv].[WaitsStatistics] where InsertUTCDate<=dateadd(day,-@day,getUTCDate())))
	begin
		delete
		from [srv].[WaitsStatistics]
		where InsertUTCDate<=dateadd(day,-@day,getUTCDate());
	end

	while(exists(select top(1) 1 from [srv].[BigQueryStatistics] where InsertUTCDate<=dateadd(day,-@day,getUTCDate())))
	begin
		delete
		from [srv].[BigQueryStatistics]
		where InsertUTCDate<=dateadd(day,-@day,getUTCDate());
	end

	while(exists(select top(1) 1 from [srv].[IndexDefragStatistics]	where InsertUTCDate<=dateadd(day,-@day,getUTCDate())))
	begin
		delete
		from [srv].[IndexDefragStatistics]
		where InsertUTCDate<=dateadd(day,-@day,getUTCDate());
	end

	while(exists(select top(1) 1 from [srv].[DefragServers]	where InsertUTCDate<=dateadd(day,-@day,getUTCDate())))
	begin
		delete
		from [srv].[DefragServers]
		where InsertUTCDate<=dateadd(day,-@day,getUTCDate());
	end

	while(exists(select top(1) 1 from [srv].[ServerDBFileInfoStatistics] where InsertUTCDate<=dateadd(day,-@day,getUTCDate())))
	begin
		delete
		from [srv].[ServerDBFileInfoStatistics]
		where InsertUTCDate<=dateadd(day,-@day,getUTCDate());
	end

	while(exists(select top(1) 1 from [srv].[IndexUsageStatsStatistics]	where InsertUTCDate<=dateadd(day,-@day,getUTCDate())))
	begin
		delete
		from [srv].[IndexUsageStatsStatistics]
		where InsertUTCDate<=dateadd(day,-@day,getUTCDate());
	end

	while(exists(select top(1) 1 from [srv].[OldStatisticsStateStatistics] where InsertUTCDate<=dateadd(day,-@day,getUTCDate())))
	begin
		delete
		from [srv].[OldStatisticsStateStatistics]
		where InsertUTCDate<=dateadd(day,-@day,getUTCDate());
	end

	while(exists(select top(1) 1 from [srv].[NewIndexOptimizeStatistics] where InsertUTCDate<=dateadd(day,-@day,getUTCDate())))
	begin
		delete
		from [srv].[NewIndexOptimizeStatistics]
		where InsertUTCDate<=dateadd(day,-@day,getUTCDate());
	end

	while(exists(select top(1) 1 from [srv].[StatisticsIOInTempDBStatistics] where InsertUTCDate<=dateadd(day,-@day,getUTCDate())))
	begin
		delete
		from [srv].[StatisticsIOInTempDBStatistics]
		where InsertUTCDate<=dateadd(day,-@day,getUTCDate());
	end

	while(exists(select top(1) 1 from [srv].[DelIndexIncludeStatistics] where InsertUTCDate<=dateadd(day,-@day,getUTCDate())))
	begin
		delete
		from [srv].[DelIndexIncludeStatistics]
		where InsertUTCDate<=dateadd(day,-@day,getUTCDate());
	end

	while(exists(select top(1) 1 from [srv].[ShortInfoRunJobsServers] where InsertUTCDate<=dateadd(day,-@day,getUTCDate())))
	begin
		delete
		from [srv].[ShortInfoRunJobsServers]
		where InsertUTCDate<=dateadd(day,-@day,getUTCDate());
	end

	while(exists(select top(1) 1 from [srv].[ReadWriteTablesStatistics] where InsertUTCDate<=dateadd(day,-@day,getUTCDate())))
	begin
		delete
		from [srv].[ReadWriteTablesStatistics]
		where InsertUTCDate<=dateadd(day,-@day,getUTCDate());
	end

	while(exists(select top(1) 1 from [srv].[DiskSpaceStatistics] where InsertUTCDate<=dateadd(day,-@day,getUTCDate())))
	begin
		delete
		from [srv].[DiskSpaceStatistics]
		where InsertUTCDate<=dateadd(day,-@day,getUTCDate());
	end

	while(exists(select top(1) 1 from [srv].[RAMSpaceStatistics] where InsertUTCDate<=dateadd(day,-@day,getUTCDate())))
	begin
		delete
		from [srv].[RAMSpaceStatistics]
		where InsertUTCDate<=dateadd(day,-@day,getUTCDate());
	end

	while(exists(select top(1) 1 from [srv].[DBFileStatistics] where InsertUTCDate<=dateadd(day,-@day,getUTCDate())))
	begin
		delete
		from [srv].[DBFileStatistics]
		where InsertUTCDate<=dateadd(day,-@day,getUTCDate());
	END

	while(exists(select top(1) 1 from [srv].[KillSessionArchive] where InsertUTCDate<=dateadd(day,-@day,getUTCDate())))
	begin
		delete
		from [srv].[KillSessionArchive]
		where InsertUTCDate<=dateadd(day,-@day,getUTCDate());
	end
END



GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [srv].[ClearFullInfo]
--
GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER     PROCEDURE [srv].[ClearFullInfo]
AS
BEGIN
	/*
		очищает все собранные данные
	*/
	SET NOCOUNT ON;

	--truncate table [srv].[BlockRequest];
	truncate table [srv].[DBFile];
	truncate table [srv].[ddl_log];
	truncate table [srv].[ddl_log_all];
	truncate table [srv].[Deadlocks];
	truncate table [srv].[Defrag];

	update [srv].[DefragRun]
	set [Run]=0;

    truncate table [srv].[ErrorInfo];
	truncate table [srv].[ErrorInfoArchive];
	truncate table [srv].[ListDefragIndex];

	truncate table [srv].[TableIndexStatistics];
	truncate table [srv].[TableStatistics];
	truncate table [srv].[RequestStatistics];
	truncate table [srv].[RequestStatisticsArchive];
	truncate table [srv].[QueryStatistics];
	truncate table [srv].[PlanQuery];
	truncate table [srv].[SQLQuery];
	truncate table [srv].[QueryRequestGroupStatistics];
	truncate table [srv].[ActiveConnectionStatistics];
	truncate table [srv].[ServerDBFileInfoStatistics];
	truncate table [srv].[ShortInfoRunJobs];

	truncate table [srv].[TSQL_DAY_Statistics];
	truncate table [srv].[IndicatorStatistics];
	truncate table [srv].[KillSession];
	truncate table [srv].[SessionTran];

	truncate table [srv].[WaitsStatistics];
	truncate table [srv].[BigQueryStatistics];
	truncate table [srv].[IndexDefragStatistics];
	truncate table [srv].[DefragServers];
	truncate table [srv].[ServerDBFileInfoStatistics];
	truncate table [srv].[IndexUsageStatsStatistics];
	truncate table [srv].[OldStatisticsStateStatistics];
	truncate table [srv].[NewIndexOptimizeStatistics];
	truncate table [srv].[StatisticsIOInTempDBStatistics];
	truncate table [srv].[DelIndexIncludeStatistics];
	truncate table [srv].[ShortInfoRunJobsServers];
	truncate table [srv].[ReadWriteTablesStatistics];
	truncate table [srv].[DiskSpaceStatistics];
	truncate table [srv].[RAMSpaceStatistics];

	truncate table [srv].[IndicatorServerDayStatistics];
	truncate table [srv].[DBFileStatistics];
	truncate table [srv].[KillSessionArchive];
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Alter procedure [srv].[AutoStatisticsActiveConnections]
--
GO

-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER   PROCEDURE [srv].[AutoStatisticsActiveConnections]
AS
BEGIN
	/*
		Автосбор данных об активных подключениях
	*/
	SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	declare @servername nvarchar(255)=cast(SERVERPROPERTY(N'MachineName') as nvarchar(255));

	;with conn as (
		select @servername as [ServerName]
		   ,[SessionID]
           ,[LoginName]
		   ,[DBName]           
		   ,[ProgramName]
           ,[Status]
		   ,[LoginTime]
		from [SRV].[inf].[vActiveConnect] with(readuncommitted)
	)
	merge [srv].[ActiveConnectionStatistics] as trg
	using conn as src on (
								trg.[ServerName] collate DATABASE_DEFAULT=src.[ServerName] collate DATABASE_DEFAULT
							and trg.[SessionID]=src.[SessionID]
							and trg.[LoginName] collate DATABASE_DEFAULT=src.[LoginName] collate DATABASE_DEFAULT
							and ((trg.[DBName] collate DATABASE_DEFAULT=src.[DBName] collate DATABASE_DEFAULT) or (src.[DBName] IS NULL))
							and trg.[LoginTime]=src.[LoginTime]
						 )
	WHEN NOT MATCHED BY TARGET THEN
	INSERT (
			[ServerName]
			,[SessionID]
			,[LoginName]
			,[DBName]
			,[ProgramName]
			,[Status]
			,[LoginTime]
		   )
	VALUES (
			src.[ServerName]
			,src.[SessionID]
			,src.[LoginName]
			,src.[DBName]
			,src.[ProgramName]
			,src.[Status]
			,src.[LoginTime]
		   )
	WHEN MATCHED THEN
	UPDATE SET
	trg.[ProgramName]=coalesce(src.[ProgramName] collate DATABASE_DEFAULT, trg.[ProgramName] collate DATABASE_DEFAULT) 
	,trg.[Status]=coalesce(src.[Status] collate DATABASE_DEFAULT, trg.[Status] collate DATABASE_DEFAULT)
	WHEN NOT MATCHED BY SOURCE AND (trg.[EndRegUTCDate] IS NULL) THEN
	UPDATE SET trg.[EndRegUTCDate]=GetUTCDate();
END
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop index [indInsertUTCDate] from table [dbo].[TEST]
--
DROP INDEX [indInsertUTCDate] ON [dbo].[TEST]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop primary key [PK_TEST] on table [dbo].[TEST]
--
ALTER TABLE [dbo].[TEST]
  DROP CONSTRAINT [PK_TEST]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create primary key [PK_TEST] on table [dbo].[TEST]
--
ALTER TABLE [dbo].[TEST]
  ADD CONSTRAINT [PK_TEST] PRIMARY KEY CLUSTERED ([TEST_GUID])
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create index [indInsertUTCDate] on table [dbo].[TEST]
--
CREATE INDEX [indInsertUTCDate]
  ON [dbo].[TEST] ([InsertUTCDate])
  ON [PRIMARY]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Drop primary key [PK_AuditQuery] on table [dbo].[AuditQuery]
--
ALTER TABLE [dbo].[AuditQuery]
  DROP CONSTRAINT [PK_AuditQuery]
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create primary key [PK_AuditQuery] on table [dbo].[AuditQuery]
--
ALTER TABLE [dbo].[AuditQuery]
  ADD CONSTRAINT [PK_AuditQuery] PRIMARY KEY CLUSTERED ([ID])
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [dbo].[sp_hexadecimal]
--
GO


CREATE PROCEDURE [dbo].[sp_hexadecimal]
    @binvalue varbinary(256),
    @hexvalue varchar (514) OUTPUT
AS
DECLARE @charvalue varchar (514)
DECLARE @i int
DECLARE @length int
DECLARE @hexstring char(16)
SELECT @charvalue = '0x'
SELECT @i = 1
SELECT @length = DATALENGTH (@binvalue)
SELECT @hexstring = '0123456789ABCDEF'
WHILE (@i <= @length)
BEGIN
  DECLARE @tempint int
  DECLARE @firstint int
  DECLARE @secondint int
  SELECT @tempint = CONVERT(int, SUBSTRING(@binvalue,@i,1))
  SELECT @firstint = FLOOR(@tempint/16)
  SELECT @secondint = @tempint - (@firstint*16)
  SELECT @charvalue = @charvalue +
    SUBSTRING(@hexstring, @firstint+1, 1) +
    SUBSTRING(@hexstring, @secondint+1, 1)
  SELECT @i = @i + 1
END

SELECT @hexvalue = @charvalue


GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [dbo].[sp_help_revlogin]
--
GO



CREATE PROCEDURE [dbo].[sp_help_revlogin] @login_name sysname = NULL AS
DECLARE @name sysname
DECLARE @type varchar (1)
DECLARE @hasaccess int
DECLARE @denylogin int
DECLARE @is_disabled int
DECLARE @PWD_varbinary  varbinary (256)
DECLARE @PWD_string  varchar (514)
DECLARE @SID_varbinary varbinary (85)
DECLARE @SID_string varchar (514)
DECLARE @tmpstr  varchar (1024)
DECLARE @is_policy_checked varchar (3)
DECLARE @is_expiration_checked varchar (3)

DECLARE @defaultdb sysname
--Перенос SQL логинов сервера (генерация сздание логина с его default базой и хэш паролем) 
IF (@login_name IS NULL)
  DECLARE login_curs CURSOR FOR

      SELECT p.sid, p.name, p.type, p.is_disabled, p.default_database_name, l.hasaccess, l.denylogin FROM 
sys.server_principals p LEFT JOIN sys.syslogins l
      ON ( l.name = p.name ) WHERE p.type IN ( 'S', 'G', 'U' ) AND p.name <> 'sa'
ELSE
  DECLARE login_curs CURSOR FOR


      SELECT p.sid, p.name, p.type, p.is_disabled, p.default_database_name, l.hasaccess, l.denylogin FROM 
sys.server_principals p LEFT JOIN sys.syslogins l
      ON ( l.name = p.name ) WHERE p.type IN ( 'S', 'G', 'U' ) AND p.name = @login_name
OPEN login_curs

FETCH NEXT FROM login_curs INTO @SID_varbinary, @name, @type, @is_disabled, @defaultdb, @hasaccess, @denylogin
IF (@@fetch_status = -1)
BEGIN
  PRINT 'Имена не найдены.'
  CLOSE login_curs
  DEALLOCATE login_curs
  RETURN -1
END
SET @tmpstr = '/* sp_help_revlogin script '
PRINT @tmpstr
SET @tmpstr = '** Generated ' + CONVERT (varchar, GETDATE()) + ' on ' + cast(SERVERPROPERTY(N'MachineName') as nvarchar(255)) + ' */'
PRINT @tmpstr
PRINT ''
WHILE (@@fetch_status <> -1)
BEGIN
  IF (@@fetch_status <> -2)
  BEGIN
    PRINT ''
    SET @tmpstr = '-- Login: ' + @name
    PRINT @tmpstr
    IF (@type IN ( 'G', 'U'))
    BEGIN -- NT authenticated account/group

      SET @tmpstr = 'CREATE LOGIN ' + QUOTENAME( @name ) + ' FROM WINDOWS WITH DEFAULT_DATABASE = [' + @defaultdb + ']'
    END
    ELSE BEGIN -- SQL Server authentication
        -- obtain password and sid
            SET @PWD_varbinary = CAST( LOGINPROPERTY( @name, 'PasswordHash' ) AS varbinary (256) )
        EXEC sp_hexadecimal @PWD_varbinary, @PWD_string OUT
        EXEC sp_hexadecimal @SID_varbinary,@SID_string OUT
 
        -- obtain password policy state
        SELECT @is_policy_checked = CASE is_policy_checked WHEN 1 THEN 'ON' WHEN 0 THEN 'OFF' ELSE NULL END FROM sys.sql_logins WHERE name = @name
        SELECT @is_expiration_checked = CASE is_expiration_checked WHEN 1 THEN 'ON' WHEN 0 THEN 'OFF' ELSE NULL END FROM sys.sql_logins WHERE name = @name
 
            SET @tmpstr = 'CREATE LOGIN ' + QUOTENAME( @name ) + ' WITH PASSWORD = ' + @PWD_string + ' HASHED, SID = ' + @SID_string + ', DEFAULT_DATABASE = [' + @defaultdb + ']'

        IF ( @is_policy_checked IS NOT NULL )
        BEGIN
          SET @tmpstr = @tmpstr + ', CHECK_POLICY = ' + @is_policy_checked
        END
        IF ( @is_expiration_checked IS NOT NULL )
        BEGIN
          SET @tmpstr = @tmpstr + ', CHECK_EXPIRATION = ' + @is_expiration_checked
        END
    END
    IF (@denylogin = 1)
    BEGIN -- login is denied access
      SET @tmpstr = @tmpstr + '; DENY CONNECT SQL TO ' + QUOTENAME( @name )
    END
    ELSE IF (@hasaccess = 0)
    BEGIN -- login exists but does not have access
      SET @tmpstr = @tmpstr + '; REVOKE CONNECT SQL TO ' + QUOTENAME( @name )
    END
    IF (@is_disabled = 1)
    BEGIN -- login is disabled
      SET @tmpstr = @tmpstr + '; ALTER LOGIN ' + QUOTENAME( @name ) + ' DISABLE'
    END
    PRINT @tmpstr
  END

  FETCH NEXT FROM login_curs INTO @SID_varbinary, @name, @type, @is_disabled, @defaultdb, @hasaccess, @denylogin
   END
CLOSE login_curs
DEALLOCATE login_curs
RETURN 0


GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [dbo].[sp_help_revlogin]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Перенос SQL логинов сервера (генерация сздание логина с его default базой и хэш паролем) ', 'SCHEMA', N'dbo', 'PROCEDURE', N'sp_help_revlogin'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [dbo].[sp_WhoIsActive_Admin]
--
GO



/*********************************************************************************************
Who Is Active? v11.00 (2011-04-27)
(C) 2007-2011, Adam Machanic

Feedback: mailto:amachanic@gmail.com
Updates: http://sqlblog.com/blogs/adam_machanic/archive/tags/who+is+active/default.aspx
"Beta" Builds: http://sqlblog.com/files/folders/beta/tags/who+is+active/default.aspx

Donate! Support this project: http://tinyurl.com/WhoIsActiveDonate

License: 
	Who is Active? is free to download and use for personal, educational, and internal 
	corporate purposes, provided that this header is preserved. Redistribution or sale 
	of Who is Active?, in whole or in part, is prohibited without the author's express 
	written consent.
*********************************************************************************************/
CREATE   PROC [dbo].[sp_WhoIsActive_Admin]
(
--~
	--Filters--Both inclusive and exclusive
	--Set either filter to '' to disable
	--Valid filter types are: session, program, database, login, and host
	--Session is a session ID, and either 0 or '' can be used to indicate "all" sessions
	--All other filter types support % or _ as wildcards
	@filter sysname = '',
	@filter_type VARCHAR(10) = 'session',
	@not_filter sysname = '',
	@not_filter_type VARCHAR(10) = 'session',

	--Retrieve data about the calling session?
	@show_own_spid BIT = 0,

	--Retrieve data about system sessions?
	@show_system_spids BIT = 0,

	--Controls how sleeping SPIDs are handled, based on the idea of levels of interest
	--0 does not pull any sleeping SPIDs
	--1 pulls only those sleeping SPIDs that also have an open transaction
	--2 pulls all sleeping SPIDs
	@show_sleeping_spids TINYINT = 1,

	--If 1, gets the full stored procedure or running batch, when available
	--If 0, gets only the actual statement that is currently running in the batch or procedure
	@get_full_inner_text BIT = 0,

	--Get associated query plans for running tasks, if available
	--If @get_plans = 1, gets the plan based on the request's statement offset
	--If @get_plans = 2, gets the entire plan based on the request's plan_handle
	@get_plans TINYINT = 0,

	--Get the associated outer ad hoc query or stored procedure call, if available
	@get_outer_command BIT = 0,

	--Enables pulling transaction log write info and transaction duration
	@get_transaction_info BIT = 0,

	--Get information on active tasks, based on three interest levels
	--Level 0 does not pull any task-related information
	--Level 1 is a lightweight mode that pulls the top non-CXPACKET wait, giving preference to blockers
	--Level 2 pulls all available task-based metrics, including: 
	--number of active tasks, current wait stats, physical I/O, context switches, and blocker information
	@get_task_info TINYINT = 1,

	--Gets associated locks for each request, aggregated in an XML format
	@get_locks BIT = 0,

	--Get average time for past runs of an active query
	--(based on the combination of plan handle, sql handle, and offset)
	@get_avg_time BIT = 0,

	--Get additional non-performance-related information about the session or request
	--text_size, language, date_format, date_first, quoted_identifier, arithabort, ansi_null_dflt_on, 
	--ansi_defaults, ansi_warnings, ansi_padding, ansi_nulls, concat_null_yields_null, 
	--transaction_isolation_level, lock_timeout, deadlock_priority, row_count, command_type
	--
	--If a SQL Agent job is running, an subnode called agent_info will be populated with some or all of
	--the following: job_id, job_name, step_id, step_name, msdb_query_error (in the event of an error)
	--
	--If @get_task_info is set to 2 and a lock wait is detected, a subnode called block_info will be
	--populated with some or all of the following: lock_type, database_name, object_id, file_id, hobt_id, 
	--applock_hash, metadata_resource, metadata_class_id, object_name, schema_name
	@get_additional_info BIT = 0,

	--Walk the blocking chain and count the number of 
	--total SPIDs blocked all the way down by a given session
	--Also enables task_info Level 1, if @get_task_info is set to 0
	@find_block_leaders BIT = 0,

	--Pull deltas on various metrics
	--Interval in seconds to wait before doing the second data pull
	@delta_interval TINYINT = 0,

	--List of desired output columns, in desired order
	--Note that the final output will be the intersection of all enabled features and all 
	--columns in the list. Therefore, only columns associated with enabled features will 
	--actually appear in the output. Likewise, removing columns from this list may effectively
	--disable features, even if they are turned on
	--
	--Each element in this list must be one of the valid output column names. Names must be
	--delimited by square brackets. White space, formatting, and additional characters are
	--allowed, as long as the list contains exact matches of delimited valid column names.
	@output_column_list VARCHAR(8000) = '[dd%][session_id][sql_text][sql_command][login_name][wait_info][tasks][tran_log%][cpu%][temp%][block%][reads%][writes%][context%][physical%][query_plan][locks][%]',

	--Column(s) by which to sort output, optionally with sort directions. 
		--Valid column choices:
		--session_id, physical_io, reads, physical_reads, writes, tempdb_allocations,
		--tempdb_current, CPU, context_switches, used_memory, physical_io_delta, 
		--reads_delta, physical_reads_delta, writes_delta, tempdb_allocations_delta, 
		--tempdb_current_delta, CPU_delta, context_switches_delta, used_memory_delta, 
		--tasks, tran_start_time, open_tran_count, blocking_session_id, blocked_session_count,
		--percent_complete, host_name, login_name, database_name, start_time, login_time
		--
		--Note that column names in the list must be bracket-delimited. Commas and/or white
		--space are not required. 
	@sort_order VARCHAR(500) = '[start_time] ASC',

	--Formats some of the output columns in a more "human readable" form
	--0 disables outfput format
	--1 formats the output for variable-width fonts
	--2 formats the output for fixed-width fonts
	@format_output TINYINT = 1,

	--If set to a non-blank value, the script will attempt to insert into the specified 
	--destination table. Please note that the script will not verify that the table exists, 
	--or that it has the correct schema, before doing the insert.
	--Table can be specified in one, two, or three-part format
	@destination_table VARCHAR(4000) = '',

	--If set to 1, no data collection will happen and no result set will be returned; instead,
	--a CREATE TABLE statement will be returned via the @schema parameter, which will match 
	--the schema of the result set that would be returned by using the same collection of the
	--rest of the parameters. The CREATE TABLE statement will have a placeholder token of 
	--<table_name> in place of an actual table name.
	@return_schema BIT = 0,
	@schema VARCHAR(MAX) = NULL OUTPUT,

	--Help! What do I do?
	@help BIT = 0
--~
)
/*
OUTPUT COLUMNS
--------------
Formatted/Non:	[session_id] [smallint] NOT NULL
	Session ID (a.k.a. SPID)

Formatted:		[dd hh:mm:ss.mss] [varchar](15) NULL
Non-Formatted:	<not returned>
	For an active request, time the query has been running
	For a sleeping session, time since the last batch completed

Formatted:		[dd hh:mm:ss.mss (avg)] [varchar](15) NULL
Non-Formatted:	[avg_elapsed_time] [int] NULL
	(Requires @get_avg_time option)
	How much time has the active portion of the query taken in the past, on average?

Formatted:		[physical_io] [varchar](30) NULL
Non-Formatted:	[physical_io] [bigint] NULL
	Shows the number of physical I/Os, for active requests

Formatted:		[reads] [varchar](30) NULL
Non-Formatted:	[reads] [bigint] NULL
	For an active request, number of reads done for the current query
	For a sleeping session, total number of reads done over the lifetime of the session

Formatted:		[physical_reads] [varchar](30) NULL
Non-Formatted:	[physical_reads] [bigint] NULL
	For an active request, number of physical reads done for the current query
	For a sleeping session, total number of physical reads done over the lifetime of the session

Formatted:		[writes] [varchar](30) NULL
Non-Formatted:	[writes] [bigint] NULL
	For an active request, number of writes done for the current query
	For a sleeping session, total number of writes done over the lifetime of the session

Formatted:		[tempdb_allocations] [varchar](30) NULL
Non-Formatted:	[tempdb_allocations] [bigint] NULL
	For an active request, number of TempDB writes done for the current query
	For a sleeping session, total number of TempDB writes done over the lifetime of the session

Formatted:		[tempdb_current] [varchar](30) NULL
Non-Formatted:	[tempdb_current] [bigint] NULL
	For an active request, number of TempDB pages currently allocated for the query
	For a sleeping session, number of TempDB pages currently allocated for the session

Formatted:		[CPU] [varchar](30) NULL
Non-Formatted:	[CPU] [int] NULL
	For an active request, total CPU time consumed by the current query
	For a sleeping session, total CPU time consumed over the lifetime of the session

Formatted:		[context_switches] [varchar](30) NULL
Non-Formatted:	[context_switches] [bigint] NULL
	Shows the number of context switches, for active requests

Formatted:		[used_memory] [varchar](30) NOT NULL
Non-Formatted:	[used_memory] [bigint] NOT NULL
	For an active request, total memory consumption for the current query
	For a sleeping session, total current memory consumption

Formatted:		[physical_io_delta] [varchar](30) NULL
Non-Formatted:	[physical_io_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the number of physical I/Os reported on the first and second collections. 
	If the request started after the first collection, the value will be NULL

Formatted:		[reads_delta] [varchar](30) NULL
Non-Formatted:	[reads_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the number of reads reported on the first and second collections. 
	If the request started after the first collection, the value will be NULL

Formatted:		[physical_reads_delta] [varchar](30) NULL
Non-Formatted:	[physical_reads_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the number of physical reads reported on the first and second collections. 
	If the request started after the first collection, the value will be NULL

Formatted:		[writes_delta] [varchar](30) NULL
Non-Formatted:	[writes_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the number of writes reported on the first and second collections. 
	If the request started after the first collection, the value will be NULL

Formatted:		[tempdb_allocations_delta] [varchar](30) NULL
Non-Formatted:	[tempdb_allocations_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the number of TempDB writes reported on the first and second collections. 
	If the request started after the first collection, the value will be NULL

Formatted:		[tempdb_current_delta] [varchar](30) NULL
Non-Formatted:	[tempdb_current_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the number of allocated TempDB pages reported on the first and second 
	collections. If the request started after the first collection, the value will be NULL

Formatted:		[CPU_delta] [varchar](30) NULL
Non-Formatted:	[CPU_delta] [int] NULL
	(Requires @delta_interval option)
	Difference between the CPU time reported on the first and second collections. 
	If the request started after the first collection, the value will be NULL

Formatted:		[context_switches_delta] [varchar](30) NULL
Non-Formatted:	[context_switches_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the context switches count reported on the first and second collections
	If the request started after the first collection, the value will be NULL

Formatted:		[used_memory_delta] [varchar](30) NULL
Non-Formatted:	[used_memory_delta] [bigint] NULL
	Difference between the memory usage reported on the first and second collections
	If the request started after the first collection, the value will be NULL

Formatted:		[tasks] [varchar](30) NULL
Non-Formatted:	[tasks] [smallint] NULL
	Number of worker tasks currently allocated, for active requests

Formatted/Non:	[status] [varchar](30) NOT NULL
	Activity status for the session (running, sleeping, etc)

Formatted/Non:	[wait_info] [nvarchar](4000) NULL
	Aggregates wait information, in the following format:
		(Ax: Bms/Cms/Dms)E
	A is the number of waiting tasks currently waiting on resource type E. B/C/D are wait
	times, in milliseconds. If only one thread is waiting, its wait time will be shown as B.
	If two tasks are waiting, each of their wait times will be shown (B/C). If three or more 
	tasks are waiting, the minimum, average, and maximum wait times will be shown (B/C/D).
	If wait type E is a page latch wait and the page is of a "special" type (e.g. PFS, GAM, SGAM), 
	the page type will be identified.
	If wait type E is CXPACKET, the nodeId from the query plan will be identified

Formatted/Non:	[locks] [xml] NULL
	(Requires @get_locks option)
	Aggregates lock information, in XML format.
	The lock XML includes the lock mode, locked object, and aggregates the number of requests. 
	Attempts are made to identify locked objects by name

Formatted/Non:	[tran_start_time] [datetime] NULL
	(Requires @get_transaction_info option)
	Date and time that the first transaction opened by a session caused a transaction log 
	write to occur.

Formatted/Non:	[tran_log_writes] [nvarchar](4000) NULL
	(Requires @get_transaction_info option)
	Aggregates transaction log write information, in the following format:
	A:wB (C kB)
	A is a database that has been touched by an active transaction
	B is the number of log writes that have been made in the database as a result of the transaction
	C is the number of log kilobytes consumed by the log records

Formatted:		[open_tran_count] [varchar](30) NULL
Non-Formatted:	[open_tran_count] [smallint] NULL
	Shows the number of open transactions the session has open

Formatted:		[sql_command] [xml] NULL
Non-Formatted:	[sql_command] [nvarchar](max) NULL
	(Requires @get_outer_command option)
	Shows the "outer" SQL command, i.e. the text of the batch or RPC sent to the server, 
	if available

Formatted:		[sql_text] [xml] NULL
Non-Formatted:	[sql_text] [nvarchar](max) NULL
	Shows the SQL text for active requests or the last statement executed
	for sleeping sessions, if available in either case.
	If @get_full_inner_text option is set, shows the full text of the batch.
	Otherwise, shows only the active statement within the batch.
	If the query text is locked, a special timeout message will be sent, in the following format:
		<timeout_exceeded />
	If an error occurs, an error message will be sent, in the following format:
		<error message="message" />

Formatted/Non:	[query_plan] [xml] NULL
	(Requires @get_plans option)
	Shows the query plan for the request, if available.
	If the plan is locked, a special timeout message will be sent, in the following format:
		<timeout_exceeded />
	If an error occurs, an error message will be sent, in the following format:
		<error message="message" />

Formatted/Non:	[blocking_session_id] [smallint] NULL
	When applicable, shows the blocking SPID

Formatted:		[blocked_session_count] [varchar](30) NULL
Non-Formatted:	[blocked_session_count] [smallint] NULL
	(Requires @find_block_leaders option)
	The total number of SPIDs blocked by this session,
	all the way down the blocking chain.

Formatted:		[percent_complete] [varchar](30) NULL
Non-Formatted:	[percent_complete] [real] NULL
	When applicable, shows the percent complete (e.g. for backups, restores, and some rollbacks)

Formatted/Non:	[host_name] [sysname] NOT NULL
	Shows the host name for the connection

Formatted/Non:	[login_name] [sysname] NOT NULL
	Shows the login name for the connection

Formatted/Non:	[database_name] [sysname] NULL
	Shows the connected database

Formatted/Non:	[program_name] [sysname] NULL
	Shows the reported program/application name

Formatted/Non:	[additional_info] [xml] NULL
	(Requires @get_additional_info option)
	Returns additional non-performance-related session/request information
	If the script finds a SQL Agent job running, the name of the job and job step will be reported
	If @get_task_info = 2 and the script finds a lock wait, the locked object will be reported

Formatted/Non:	[start_time] [datetime] NOT NULL
	For active requests, shows the time the request started
	For sleeping sessions, shows the time the last batch completed

Formatted/Non:	[login_time] [datetime] NOT NULL
	Shows the time that the session connected

Formatted/Non:	[request_id] [int] NULL
	For active requests, shows the request_id
	Should be 0 unless MARS is being used

Formatted/Non:	[collection_time] [datetime] NOT NULL
	Time that this script's final SELECT ran
*/
AS
BEGIN;
	SET NOCOUNT ON; 
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	SET QUOTED_IDENTIFIER ON;
	SET ANSI_PADDING ON;
	SET CONCAT_NULL_YIELDS_NULL ON;
	SET ANSI_WARNINGS ON;
	SET NUMERIC_ROUNDABORT OFF;
	SET ARITHABORT ON;

	IF
		@filter IS NULL
		OR @filter_type IS NULL
		OR @not_filter IS NULL
		OR @not_filter_type IS NULL
		OR @show_own_spid IS NULL
		OR @show_system_spids IS NULL
		OR @show_sleeping_spids IS NULL
		OR @get_full_inner_text IS NULL
		OR @get_plans IS NULL
		OR @get_outer_command IS NULL
		OR @get_transaction_info IS NULL
		OR @get_task_info IS NULL
		OR @get_locks IS NULL
		OR @get_avg_time IS NULL
		OR @get_additional_info IS NULL
		OR @find_block_leaders IS NULL
		OR @delta_interval IS NULL
		OR @format_output IS NULL
		OR @output_column_list IS NULL
		OR @sort_order IS NULL
		OR @return_schema IS NULL
		OR @destination_table IS NULL
		OR @help IS NULL
	BEGIN;
		RAISERROR('Input parameters cannot be NULL', 16, 1);
		RETURN;
	END;
	
	IF @filter_type NOT IN ('session', 'program', 'database', 'login', 'host')
	BEGIN;
		RAISERROR('Valid filter types are: session, program, database, login, host', 16, 1);
		RETURN;
	END;
	
	IF @filter_type = 'session' AND @filter LIKE '%[^0123456789]%'
	BEGIN;
		RAISERROR('Session filters must be valid integers', 16, 1);
		RETURN;
	END;
	
	IF @not_filter_type NOT IN ('session', 'program', 'database', 'login', 'host')
	BEGIN;
		RAISERROR('Valid filter types are: session, program, database, login, host', 16, 1);
		RETURN;
	END;
	
	IF @not_filter_type = 'session' AND @not_filter LIKE '%[^0123456789]%'
	BEGIN;
		RAISERROR('Session filters must be valid integers', 16, 1);
		RETURN;
	END;
	
	IF @show_sleeping_spids NOT IN (0, 1, 2)
	BEGIN;
		RAISERROR('Valid values for @show_sleeping_spids are: 0, 1, or 2', 16, 1);
		RETURN;
	END;
	
	IF @get_plans NOT IN (0, 1, 2)
	BEGIN;
		RAISERROR('Valid values for @get_plans are: 0, 1, or 2', 16, 1);
		RETURN;
	END;

	IF @get_task_info NOT IN (0, 1, 2)
	BEGIN;
		RAISERROR('Valid values for @get_task_info are: 0, 1, or 2', 16, 1);
		RETURN;
	END;

	IF @format_output NOT IN (0, 1, 2)
	BEGIN;
		RAISERROR('Valid values for @format_output are: 0, 1, or 2', 16, 1);
		RETURN;
	END;
	
	IF @help = 1
	BEGIN;
		DECLARE 
			@header VARCHAR(MAX),
			@params VARCHAR(MAX),
			@outputs VARCHAR(MAX);

		SELECT 
			@header =
				REPLACE
				(
					REPLACE
					(
						CONVERT
						(
							VARCHAR(MAX),
							SUBSTRING
							(
								t.text, 
								CHARINDEX('/' + REPLICATE('*', 93), t.text) + 94,
								CHARINDEX(REPLICATE('*', 93) + '/', t.text) - (CHARINDEX('/' + REPLICATE('*', 93), t.text) + 94)
							)
						),
						CHAR(13)+CHAR(10),
						CHAR(13)
					),
					'	',
					''
				),
			@params =
				CHAR(13) +
					REPLACE
					(
						REPLACE
						(
							CONVERT
							(
								VARCHAR(MAX),
								SUBSTRING
								(
									t.text, 
									CHARINDEX('--~', t.text) + 5, 
									CHARINDEX('--~', t.text, CHARINDEX('--~', t.text) + 5) - (CHARINDEX('--~', t.text) + 5)
								)
							),
							CHAR(13)+CHAR(10),
							CHAR(13)
						),
						'	',
						''
					),
				@outputs = 
					CHAR(13) +
						REPLACE
						(
							REPLACE
							(
								REPLACE
								(
									CONVERT
									(
										VARCHAR(MAX),
										SUBSTRING
										(
											t.text, 
											CHARINDEX('OUTPUT COLUMNS'+CHAR(13)+CHAR(10)+'--------------', t.text) + 32,
											CHARINDEX('*/', t.text, CHARINDEX('OUTPUT COLUMNS'+CHAR(13)+CHAR(10)+'--------------', t.text) + 32) - (CHARINDEX('OUTPUT COLUMNS'+CHAR(13)+CHAR(10)+'--------------', t.text) + 32)
										)
									),
									CHAR(9),
									CHAR(255)
								),
								CHAR(13)+CHAR(10),
								CHAR(13)
							),
							'	',
							''
						) +
						CHAR(13)
			FROM sys.dm_exec_requests AS r
			CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) AS t
			WHERE
				r.session_id = @@SPID;

		WITH
		a0 AS
		(SELECT 1 AS n UNION ALL SELECT 1),
		a1 AS
		(SELECT 1 AS n FROM a0 AS a, a0 AS b),
		a2 AS
		(SELECT 1 AS n FROM a1 AS a, a1 AS b),
		a3 AS
		(SELECT 1 AS n FROM a2 AS a, a2 AS b),
		a4 AS
		(SELECT 1 AS n FROM a3 AS a, a3 AS b),
		numbers AS
		(
			SELECT TOP(LEN(@header) - 1)
				ROW_NUMBER() OVER
				(
					ORDER BY (SELECT NULL)
				) AS number
			FROM a4
			ORDER BY
				number
		)
		SELECT
			RTRIM(LTRIM(
				SUBSTRING
				(
					@header,
					number + 1,
					CHARINDEX(CHAR(13), @header, number + 1) - number - 1
				)
			)) AS [------header---------------------------------------------------------------------------------------------------------------]
		FROM numbers
		WHERE
			SUBSTRING(@header, number, 1) = CHAR(13);

		WITH
		a0 AS
		(SELECT 1 AS n UNION ALL SELECT 1),
		a1 AS
		(SELECT 1 AS n FROM a0 AS a, a0 AS b),
		a2 AS
		(SELECT 1 AS n FROM a1 AS a, a1 AS b),
		a3 AS
		(SELECT 1 AS n FROM a2 AS a, a2 AS b),
		a4 AS
		(SELECT 1 AS n FROM a3 AS a, a3 AS b),
		numbers AS
		(
			SELECT TOP(LEN(@params) - 1)
				ROW_NUMBER() OVER
				(
					ORDER BY (SELECT NULL)
				) AS number
			FROM a4
			ORDER BY
				number
		),
		tokens AS
		(
			SELECT 
				RTRIM(LTRIM(
					SUBSTRING
					(
						@params,
						number + 1,
						CHARINDEX(CHAR(13), @params, number + 1) - number - 1
					)
				)) AS token,
				number,
				CASE
					WHEN SUBSTRING(@params, number + 1, 1) = CHAR(13) THEN number
					ELSE COALESCE(NULLIF(CHARINDEX(',' + CHAR(13) + CHAR(13), @params, number), 0), LEN(@params)) 
				END AS param_group,
				ROW_NUMBER() OVER
				(
					PARTITION BY
						CHARINDEX(',' + CHAR(13) + CHAR(13), @params, number),
						SUBSTRING(@params, number+1, 1)
					ORDER BY 
						number
				) AS group_order
			FROM numbers
			WHERE
				SUBSTRING(@params, number, 1) = CHAR(13)
		),
		parsed_tokens AS
		(
			SELECT
				MIN
				(
					CASE
						WHEN token LIKE '@%' THEN token
						ELSE NULL
					END
				) AS parameter,
				MIN
				(
					CASE
						WHEN token LIKE '--%' THEN RIGHT(token, LEN(token) - 2)
						ELSE NULL
					END
				) AS description,
				param_group,
				group_order
			FROM tokens
			WHERE
				NOT 
				(
					token = '' 
					AND group_order > 1
				)
			GROUP BY
				param_group,
				group_order
		)
		SELECT
			CASE
				WHEN description IS NULL AND parameter IS NULL THEN '-------------------------------------------------------------------------'
				WHEN param_group = MAX(param_group) OVER() THEN parameter
				ELSE COALESCE(LEFT(parameter, LEN(parameter) - 1), '')
			END AS [------parameter----------------------------------------------------------],
			CASE
				WHEN description IS NULL AND parameter IS NULL THEN '----------------------------------------------------------------------------------------------------------------------'
				ELSE COALESCE(description, '')
			END AS [------description-----------------------------------------------------------------------------------------------------]
		FROM parsed_tokens
		ORDER BY
			param_group, 
			group_order;
		
		WITH
		a0 AS
		(SELECT 1 AS n UNION ALL SELECT 1),
		a1 AS
		(SELECT 1 AS n FROM a0 AS a, a0 AS b),
		a2 AS
		(SELECT 1 AS n FROM a1 AS a, a1 AS b),
		a3 AS
		(SELECT 1 AS n FROM a2 AS a, a2 AS b),
		a4 AS
		(SELECT 1 AS n FROM a3 AS a, a3 AS b),
		numbers AS
		(
			SELECT TOP(LEN(@outputs) - 1)
				ROW_NUMBER() OVER
				(
					ORDER BY (SELECT NULL)
				) AS number
			FROM a4
			ORDER BY
				number
		),
		tokens AS
		(
			SELECT 
				RTRIM(LTRIM(
					SUBSTRING
					(
						@outputs,
						number + 1,
						CASE
							WHEN 
								COALESCE(NULLIF(CHARINDEX(CHAR(13) + 'Formatted', @outputs, number + 1), 0), LEN(@outputs)) < 
								COALESCE(NULLIF(CHARINDEX(CHAR(13) + CHAR(255) COLLATE Latin1_General_Bin2, @outputs, number + 1), 0), LEN(@outputs))
								THEN COALESCE(NULLIF(CHARINDEX(CHAR(13) + 'Formatted', @outputs, number + 1), 0), LEN(@outputs)) - number - 1
							ELSE
								COALESCE(NULLIF(CHARINDEX(CHAR(13) + CHAR(255) COLLATE Latin1_General_Bin2, @outputs, number + 1), 0), LEN(@outputs)) - number - 1
						END
					)
				)) AS token,
				number,
				COALESCE(NULLIF(CHARINDEX(CHAR(13) + 'Formatted', @outputs, number + 1), 0), LEN(@outputs)) AS output_group,
				ROW_NUMBER() OVER
				(
					PARTITION BY 
						COALESCE(NULLIF(CHARINDEX(CHAR(13) + 'Formatted', @outputs, number + 1), 0), LEN(@outputs))
					ORDER BY
						number
				) AS output_group_order
			FROM numbers
			WHERE
				SUBSTRING(@outputs, number, 10) = CHAR(13) + 'Formatted'
				OR SUBSTRING(@outputs, number, 2) = CHAR(13) + CHAR(255) COLLATE Latin1_General_Bin2
		),
		output_tokens AS
		(
			SELECT 
				*,
				CASE output_group_order
					WHEN 2 THEN MAX(CASE output_group_order WHEN 1 THEN token ELSE NULL END) OVER (PARTITION BY output_group)
					ELSE ''
				END COLLATE Latin1_General_Bin2 AS column_info
			FROM tokens
		)
		SELECT
			CASE output_group_order
				WHEN 1 THEN '-----------------------------------'
				WHEN 2 THEN 
					CASE
						WHEN CHARINDEX('Formatted/Non:', column_info) = 1 THEN
							SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info)+1, CHARINDEX(']', column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info)+2) - CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info))
						ELSE
							SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info)+2, CHARINDEX(']', column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info)+2) - CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info)-1)
					END
				ELSE ''
			END AS formatted_column_name,
			CASE output_group_order
				WHEN 1 THEN '-----------------------------------'
				WHEN 2 THEN 
					CASE
						WHEN CHARINDEX('Formatted/Non:', column_info) = 1 THEN
							SUBSTRING(column_info, CHARINDEX(']', column_info)+2, LEN(column_info))
						ELSE
							SUBSTRING(column_info, CHARINDEX(']', column_info)+2, CHARINDEX('Non-Formatted:', column_info, CHARINDEX(']', column_info)+2) - CHARINDEX(']', column_info)-3)
					END
				ELSE ''
			END AS formatted_column_type,
			CASE output_group_order
				WHEN 1 THEN '---------------------------------------'
				WHEN 2 THEN 
					CASE
						WHEN CHARINDEX('Formatted/Non:', column_info) = 1 THEN ''
						ELSE
							CASE
								WHEN SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info))+1, 1) = '<' THEN
									SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info))+1, CHARINDEX('>', column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info))+1) - CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info)))
								ELSE
									SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info))+1, CHARINDEX(']', column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info))+1) - CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info)))
							END
					END
				ELSE ''
			END AS unformatted_column_name,
			CASE output_group_order
				WHEN 1 THEN '---------------------------------------'
				WHEN 2 THEN 
					CASE
						WHEN CHARINDEX('Formatted/Non:', column_info) = 1 THEN ''
						ELSE
							CASE
								WHEN SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info))+1, 1) = '<' THEN ''
								ELSE
									SUBSTRING(column_info, CHARINDEX(']', column_info, CHARINDEX('Non-Formatted:', column_info))+2, CHARINDEX('Non-Formatted:', column_info, CHARINDEX(']', column_info)+2) - CHARINDEX(']', column_info)-3)
							END
					END
				ELSE ''
			END AS unformatted_column_type,
			CASE output_group_order
				WHEN 1 THEN '----------------------------------------------------------------------------------------------------------------------'
				ELSE REPLACE(token, CHAR(255) COLLATE Latin1_General_Bin2, '')
			END AS [------description-----------------------------------------------------------------------------------------------------]
		FROM output_tokens
		WHERE
			NOT 
			(
				output_group_order = 1 
				AND output_group = LEN(@outputs)
			)
		ORDER BY
			output_group,
			CASE output_group_order
				WHEN 1 THEN 99
				ELSE output_group_order
			END;

		RETURN;
	END;

	WITH
	a0 AS
	(SELECT 1 AS n UNION ALL SELECT 1),
	a1 AS
	(SELECT 1 AS n FROM a0 AS a, a0 AS b),
	a2 AS
	(SELECT 1 AS n FROM a1 AS a, a1 AS b),
	a3 AS
	(SELECT 1 AS n FROM a2 AS a, a2 AS b),
	a4 AS
	(SELECT 1 AS n FROM a3 AS a, a3 AS b),
	numbers AS
	(
		SELECT TOP(LEN(@output_column_list))
			ROW_NUMBER() OVER
			(
				ORDER BY (SELECT NULL)
			) AS number
		FROM a4
		ORDER BY
			number
	),
	tokens AS
	(
		SELECT 
			'|[' +
				SUBSTRING
				(
					@output_column_list,
					number + 1,
					CHARINDEX(']', @output_column_list, number) - number - 1
				) + '|]' AS token,
			number
		FROM numbers
		WHERE
			SUBSTRING(@output_column_list, number, 1) = '['
	),
	ordered_columns AS
	(
		SELECT
			x.column_name,
			ROW_NUMBER() OVER
			(
				PARTITION BY
					x.column_name
				ORDER BY
					tokens.number,
					x.default_order
			) AS r,
			ROW_NUMBER() OVER
			(
				ORDER BY
					tokens.number,
					x.default_order
			) AS s
		FROM tokens
		JOIN
		(
			SELECT '[session_id]' AS column_name, 1 AS default_order
			UNION ALL
			SELECT '[dd hh:mm:ss.mss]', 2
			WHERE
				@format_output = 1
			UNION ALL
			SELECT '[dd hh:mm:ss.mss (avg)]', 3
			WHERE
				@format_output = 1
				AND @get_avg_time = 1
			UNION ALL
			SELECT '[avg_elapsed_time]', 4
			WHERE
				@format_output = 0
				AND @get_avg_time = 1
			UNION ALL
			SELECT '[physical_io]', 5
			WHERE
				@get_task_info = 2
			UNION ALL
			SELECT '[reads]', 6
			UNION ALL
			SELECT '[physical_reads]', 7
			UNION ALL
			SELECT '[writes]', 8
			UNION ALL
			SELECT '[tempdb_allocations]', 9
			UNION ALL
			SELECT '[tempdb_current]', 10
			UNION ALL
			SELECT '[CPU]', 11
			UNION ALL
			SELECT '[context_switches]', 12
			WHERE
				@get_task_info = 2
			UNION ALL
			SELECT '[used_memory]', 13
			UNION ALL
			SELECT '[physical_io_delta]', 14
			WHERE
				@delta_interval > 0	
				AND @get_task_info = 2
			UNION ALL
			SELECT '[reads_delta]', 15
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[physical_reads_delta]', 16
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[writes_delta]', 17
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[tempdb_allocations_delta]', 18
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[tempdb_current_delta]', 19
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[CPU_delta]', 20
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[context_switches_delta]', 21
			WHERE
				@delta_interval > 0
				AND @get_task_info = 2
			UNION ALL
			SELECT '[used_memory_delta]', 22
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[tasks]', 23
			WHERE
				@get_task_info = 2
			UNION ALL
			SELECT '[status]', 24
			UNION ALL
			SELECT '[wait_info]', 25
			WHERE
				@get_task_info > 0
				OR @find_block_leaders = 1
			UNION ALL
			SELECT '[locks]', 26
			WHERE
				@get_locks = 1
			UNION ALL
			SELECT '[tran_start_time]', 27
			WHERE
				@get_transaction_info = 1
			UNION ALL
			SELECT '[tran_log_writes]', 28
			WHERE
				@get_transaction_info = 1
			UNION ALL
			SELECT '[open_tran_count]', 29
			UNION ALL
			SELECT '[sql_command]', 30
			WHERE
				@get_outer_command = 1
			UNION ALL
			SELECT '[sql_text]', 31
			UNION ALL
			SELECT '[query_plan]', 32
			WHERE
				@get_plans >= 1
			UNION ALL
			SELECT '[blocking_session_id]', 33
			WHERE
				@get_task_info > 0
				OR @find_block_leaders = 1
			UNION ALL
			SELECT '[blocked_session_count]', 34
			WHERE
				@find_block_leaders = 1
			UNION ALL
			SELECT '[percent_complete]', 35
			UNION ALL
			SELECT '[host_name]', 36
			UNION ALL
			SELECT '[login_name]', 37
			UNION ALL
			SELECT '[database_name]', 38
			UNION ALL
			SELECT '[program_name]', 39
			UNION ALL
			SELECT '[additional_info]', 40
			WHERE
				@get_additional_info = 1
			UNION ALL
			SELECT '[start_time]', 41
			UNION ALL
			SELECT '[login_time]', 42
			UNION ALL
			SELECT '[request_id]', 43
			UNION ALL
			SELECT '[collection_time]', 44
		) AS x ON 
			x.column_name LIKE token ESCAPE '|'
	)
	SELECT
		@output_column_list =
			STUFF
			(
				(
					SELECT
						',' + column_name as [text()]
					FROM ordered_columns
					WHERE
						r = 1
					ORDER BY
						s
					FOR XML
						PATH('')
				),
				1,
				1,
				''
			);
	
	IF COALESCE(RTRIM(@output_column_list), '') = ''
	BEGIN;
		RAISERROR('No valid column matches found in @output_column_list or no columns remain due to selected options.', 16, 1);
		RETURN;
	END;
	
	IF @destination_table <> ''
	BEGIN;
		SET @destination_table = 
			--database
			COALESCE(QUOTENAME(PARSENAME(@destination_table, 3)) + '.', '') +
			--schema
			COALESCE(QUOTENAME(PARSENAME(@destination_table, 2)) + '.', '') +
			--table
			COALESCE(QUOTENAME(PARSENAME(@destination_table, 1)), '');
			
		IF COALESCE(RTRIM(@destination_table), '') = ''
		BEGIN;
			RAISERROR('Destination table not properly formatted.', 16, 1);
			RETURN;
		END;
	END;

	WITH
	a0 AS
	(SELECT 1 AS n UNION ALL SELECT 1),
	a1 AS
	(SELECT 1 AS n FROM a0 AS a, a0 AS b),
	a2 AS
	(SELECT 1 AS n FROM a1 AS a, a1 AS b),
	a3 AS
	(SELECT 1 AS n FROM a2 AS a, a2 AS b),
	a4 AS
	(SELECT 1 AS n FROM a3 AS a, a3 AS b),
	numbers AS
	(
		SELECT TOP(LEN(@sort_order))
			ROW_NUMBER() OVER
			(
				ORDER BY (SELECT NULL)
			) AS number
		FROM a4
		ORDER BY
			number
	),
	tokens AS
	(
		SELECT 
			'|[' +
				SUBSTRING
				(
					@sort_order,
					number + 1,
					CHARINDEX(']', @sort_order, number) - number - 1
				) + '|]' AS token,
			SUBSTRING
			(
				@sort_order,
				CHARINDEX(']', @sort_order, number) + 1,
				COALESCE(NULLIF(CHARINDEX('[', @sort_order, CHARINDEX(']', @sort_order, number)), 0), LEN(@sort_order)) - CHARINDEX(']', @sort_order, number)
			) AS next_chunk,
			number
		FROM numbers
		WHERE
			SUBSTRING(@sort_order, number, 1) = '['
	),
	ordered_columns AS
	(
		SELECT
			x.column_name +
				CASE
					WHEN tokens.next_chunk LIKE '%asc%' THEN ' ASC'
					WHEN tokens.next_chunk LIKE '%desc%' THEN ' DESC'
					ELSE ''
				END AS column_name,
			ROW_NUMBER() OVER
			(
				PARTITION BY
					x.column_name
				ORDER BY
					tokens.number
			) AS r,
			tokens.number
		FROM tokens
		JOIN
		(
			SELECT '[session_id]' AS column_name
			UNION ALL
			SELECT '[physical_io]'
			UNION ALL
			SELECT '[reads]'
			UNION ALL
			SELECT '[physical_reads]'
			UNION ALL
			SELECT '[writes]'
			UNION ALL
			SELECT '[tempdb_allocations]'
			UNION ALL
			SELECT '[tempdb_current]'
			UNION ALL
			SELECT '[CPU]'
			UNION ALL
			SELECT '[context_switches]'
			UNION ALL
			SELECT '[used_memory]'
			UNION ALL
			SELECT '[physical_io_delta]'
			UNION ALL
			SELECT '[reads_delta]'
			UNION ALL
			SELECT '[physical_reads_delta]'
			UNION ALL
			SELECT '[writes_delta]'
			UNION ALL
			SELECT '[tempdb_allocations_delta]'
			UNION ALL
			SELECT '[tempdb_current_delta]'
			UNION ALL
			SELECT '[CPU_delta]'
			UNION ALL
			SELECT '[context_switches_delta]'
			UNION ALL
			SELECT '[used_memory_delta]'
			UNION ALL
			SELECT '[tasks]'
			UNION ALL
			SELECT '[tran_start_time]'
			UNION ALL
			SELECT '[open_tran_count]'
			UNION ALL
			SELECT '[blocking_session_id]'
			UNION ALL
			SELECT '[blocked_session_count]'
			UNION ALL
			SELECT '[percent_complete]'
			UNION ALL
			SELECT '[host_name]'
			UNION ALL
			SELECT '[login_name]'
			UNION ALL
			SELECT '[database_name]'
			UNION ALL
			SELECT '[start_time]'
			UNION ALL
			SELECT '[login_time]'
		) AS x ON 
			x.column_name LIKE token ESCAPE '|'
	)
	SELECT
		@sort_order = COALESCE(z.sort_order, '')
	FROM
	(
		SELECT
			STUFF
			(
				(
					SELECT
						',' + column_name as [text()]
					FROM ordered_columns
					WHERE
						r = 1
					ORDER BY
						number
					FOR XML
						PATH('')
				),
				1,
				1,
				''
			) AS sort_order
	) AS z;

	CREATE TABLE #sessions
	(
		recursion SMALLINT NOT NULL,
		session_id SMALLINT NOT NULL,
		request_id INT NOT NULL,
		session_number INT NOT NULL,
		elapsed_time INT NOT NULL,
		avg_elapsed_time INT NULL,
		physical_io BIGINT NULL,
		reads BIGINT NULL,
		physical_reads BIGINT NULL,
		writes BIGINT NULL,
		tempdb_allocations BIGINT NULL,
		tempdb_current BIGINT NULL,
		CPU INT NULL,
		thread_CPU_snapshot BIGINT NULL,
		context_switches BIGINT NULL,
		used_memory BIGINT NOT NULL, 
		tasks SMALLINT NULL,
		status VARCHAR(30) NOT NULL,
		wait_info NVARCHAR(4000) NULL,
		locks XML NULL,
		transaction_id BIGINT NULL,
		tran_start_time DATETIME NULL,
		tran_log_writes NVARCHAR(4000) NULL,
		open_tran_count SMALLINT NULL,
		sql_command XML NULL,
		sql_handle VARBINARY(64) NULL,
		statement_start_offset INT NULL,
		statement_end_offset INT NULL,
		sql_text XML NULL,
		plan_handle VARBINARY(64) NULL,
		query_plan XML NULL,
		blocking_session_id SMALLINT NULL,
		blocked_session_count SMALLINT NULL,
		percent_complete REAL NULL,
		host_name sysname NULL,
		login_name sysname NOT NULL,
		database_name sysname NULL,
		program_name sysname NULL,
		additional_info XML NULL,
		start_time DATETIME NOT NULL,
		login_time DATETIME NULL,
		last_request_start_time DATETIME NULL,
		PRIMARY KEY CLUSTERED (session_id, request_id, recursion) WITH (IGNORE_DUP_KEY = ON),
		UNIQUE NONCLUSTERED (transaction_id, session_id, request_id, recursion) WITH (IGNORE_DUP_KEY = ON)
	);

	IF @return_schema = 0
	BEGIN;
		--Disable unnecessary autostats on the table
		CREATE STATISTICS s_session_id ON #sessions (session_id)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_request_id ON #sessions (request_id)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_transaction_id ON #sessions (transaction_id)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_session_number ON #sessions (session_number)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_status ON #sessions (status)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_start_time ON #sessions (start_time)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_last_request_start_time ON #sessions (last_request_start_time)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_recursion ON #sessions (recursion)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;

		DECLARE @recursion SMALLINT;
		SET @recursion = 
			CASE @delta_interval
				WHEN 0 THEN 1
				ELSE -1
			END;

		DECLARE @first_collection_ms_ticks BIGINT;
		DECLARE @last_collection_start DATETIME;

		--Used for the delta pull
		REDO:;
		
		IF 
			@get_locks = 1 
			AND @recursion = 1
			AND @output_column_list LIKE '%|[locks|]%' ESCAPE '|'
		BEGIN;
			SELECT
				y.resource_type,
				y.database_name,
				y.object_id,
				y.file_id,
				y.page_type,
				y.hobt_id,
				y.allocation_unit_id,
				y.index_id,
				y.schema_id,
				y.principal_id,
				y.request_mode,
				y.request_status,
				y.session_id,
				y.resource_description,
				y.request_count,
				s.request_id,
				s.start_time,
				CONVERT(sysname, NULL) AS object_name,
				CONVERT(sysname, NULL) AS index_name,
				CONVERT(sysname, NULL) AS schema_name,
				CONVERT(sysname, NULL) AS principal_name,
				CONVERT(NVARCHAR(2048), NULL) AS query_error
			INTO #locks
			FROM
			(
				SELECT
					sp.spid AS session_id,
					CASE sp.status
						WHEN 'sleeping' THEN CONVERT(INT, 0)
						ELSE sp.request_id
					END AS request_id,
					CASE sp.status
						WHEN 'sleeping' THEN sp.last_batch
						ELSE COALESCE(req.start_time, sp.last_batch)
					END AS start_time,
					sp.dbid
				FROM sys.sysprocesses AS sp
				OUTER APPLY
				(
					SELECT TOP(1)
						CASE
							WHEN 
							(
								sp.hostprocess > ''
								OR r.total_elapsed_time < 0
							) THEN
								r.start_time
							ELSE
								DATEADD
								(
									ms, 
									1000 * (DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())) / 500) - DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())), 
									DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())
								)
						END AS start_time
					FROM sys.dm_exec_requests AS r
					WHERE
						r.session_id = sp.spid
						AND r.request_id = sp.request_id
				) AS req
				WHERE
					--Process inclusive filter
					1 =
						CASE
							WHEN @filter <> '' THEN
								CASE @filter_type
									WHEN 'session' THEN
										CASE
											WHEN
												CONVERT(SMALLINT, @filter) = 0
												OR sp.spid = CONVERT(SMALLINT, @filter)
													THEN 1
											ELSE 0
										END
									WHEN 'program' THEN
										CASE
											WHEN sp.program_name LIKE @filter THEN 1
											ELSE 0
										END
									WHEN 'login' THEN
										CASE
											WHEN sp.loginame LIKE @filter THEN 1
											ELSE 0
										END
									WHEN 'host' THEN
										CASE
											WHEN sp.hostname LIKE @filter THEN 1
											ELSE 0
										END
									WHEN 'database' THEN
										CASE
											WHEN DB_NAME(sp.dbid) LIKE @filter THEN 1
											ELSE 0
										END
									ELSE 0
								END
							ELSE 1
						END
					--Process exclusive filter
					AND 0 =
						CASE
							WHEN @not_filter <> '' THEN
								CASE @not_filter_type
									WHEN 'session' THEN
										CASE
											WHEN sp.spid = CONVERT(SMALLINT, @not_filter) THEN 1
											ELSE 0
										END
									WHEN 'program' THEN
										CASE
											WHEN sp.program_name LIKE @not_filter THEN 1
											ELSE 0
										END
									WHEN 'login' THEN
										CASE
											WHEN sp.loginame LIKE @not_filter THEN 1
											ELSE 0
										END
									WHEN 'host' THEN
										CASE
											WHEN sp.hostname LIKE @not_filter THEN 1
											ELSE 0
										END
									WHEN 'database' THEN
										CASE
											WHEN DB_NAME(sp.dbid) LIKE @not_filter THEN 1
											ELSE 0
										END
									ELSE 0
								END
							ELSE 0
						END
					AND 
					(
						@show_own_spid = 1
						OR sp.spid <> @@SPID
					)
					AND 
					(
						@show_system_spids = 1
						OR sp.hostprocess > ''
					)
					AND sp.ecid = 0
			) AS s
			INNER HASH JOIN
			(
				SELECT
					x.resource_type,
					x.database_name,
					x.object_id,
					x.file_id,
					CASE
						WHEN x.page_no = 1 OR x.page_no % 8088 = 0 THEN 'PFS'
						WHEN x.page_no = 2 OR x.page_no % 511232 = 0 THEN 'GAM'
						WHEN x.page_no = 3 OR x.page_no % 511233 = 0 THEN 'SGAM'
						WHEN x.page_no = 6 OR x.page_no % 511238 = 0 THEN 'DCM'
						WHEN x.page_no = 7 OR x.page_no % 511239 = 0 THEN 'BCM'
						WHEN x.page_no IS NOT NULL THEN '*'
						ELSE NULL
					END AS page_type,
					x.hobt_id,
					x.allocation_unit_id,
					x.index_id,
					x.schema_id,
					x.principal_id,
					x.request_mode,
					x.request_status,
					x.session_id,
					x.request_id,
					CASE
						WHEN COALESCE(x.object_id, x.file_id, x.hobt_id, x.allocation_unit_id, x.index_id, x.schema_id, x.principal_id) IS NULL THEN NULLIF(resource_description, '')
						ELSE NULL
					END AS resource_description,
					COUNT(*) AS request_count
				FROM
				(
					SELECT
						tl.resource_type +
							CASE
								WHEN tl.resource_subtype = '' THEN ''
								ELSE '.' + tl.resource_subtype
							END AS resource_type,
						COALESCE(DB_NAME(tl.resource_database_id), N'(null)') AS database_name,
						CONVERT
						(
							INT,
							CASE
								WHEN tl.resource_type = 'OBJECT' THEN tl.resource_associated_entity_id
								WHEN tl.resource_description LIKE '%object_id = %' THEN
									(
										SUBSTRING
										(
											tl.resource_description, 
											(CHARINDEX('object_id = ', tl.resource_description) + 12), 
											COALESCE
											(
												NULLIF
												(
													CHARINDEX(',', tl.resource_description, CHARINDEX('object_id = ', tl.resource_description) + 12),
													0
												), 
												DATALENGTH(tl.resource_description)+1
											) - (CHARINDEX('object_id = ', tl.resource_description) + 12)
										)
									)
								ELSE NULL
							END
						) AS object_id,
						CONVERT
						(
							INT,
							CASE 
								WHEN tl.resource_type = 'FILE' THEN CONVERT(INT, tl.resource_description)
								WHEN tl.resource_type IN ('PAGE', 'EXTENT', 'RID') THEN LEFT(tl.resource_description, CHARINDEX(':', tl.resource_description)-1)
								ELSE NULL
							END
						) AS file_id,
						CONVERT
						(
							INT,
							CASE
								WHEN tl.resource_type IN ('PAGE', 'EXTENT', 'RID') THEN 
									SUBSTRING
									(
										tl.resource_description, 
										CHARINDEX(':', tl.resource_description) + 1, 
										COALESCE
										(
											NULLIF
											(
												CHARINDEX(':', tl.resource_description, CHARINDEX(':', tl.resource_description) + 1), 
												0
											), 
											DATALENGTH(tl.resource_description)+1
										) - (CHARINDEX(':', tl.resource_description) + 1)
									)
								ELSE NULL
							END
						) AS page_no,
						CASE
							WHEN tl.resource_type IN ('PAGE', 'KEY', 'RID', 'HOBT') THEN tl.resource_associated_entity_id
							ELSE NULL
						END AS hobt_id,
						CASE
							WHEN tl.resource_type = 'ALLOCATION_UNIT' THEN tl.resource_associated_entity_id
							ELSE NULL
						END AS allocation_unit_id,
						CONVERT
						(
							INT,
							CASE
								WHEN
									/*TODO: Deal with server principals*/ 
									tl.resource_subtype <> 'SERVER_PRINCIPAL' 
									AND tl.resource_description LIKE '%index_id or stats_id = %' THEN
									(
										SUBSTRING
										(
											tl.resource_description, 
											(CHARINDEX('index_id or stats_id = ', tl.resource_description) + 23), 
											COALESCE
											(
												NULLIF
												(
													CHARINDEX(',', tl.resource_description, CHARINDEX('index_id or stats_id = ', tl.resource_description) + 23), 
													0
												), 
												DATALENGTH(tl.resource_description)+1
											) - (CHARINDEX('index_id or stats_id = ', tl.resource_description) + 23)
										)
									)
								ELSE NULL
							END 
						) AS index_id,
						CONVERT
						(
							INT,
							CASE
								WHEN tl.resource_description LIKE '%schema_id = %' THEN
									(
										SUBSTRING
										(
											tl.resource_description, 
											(CHARINDEX('schema_id = ', tl.resource_description) + 12), 
											COALESCE
											(
												NULLIF
												(
													CHARINDEX(',', tl.resource_description, CHARINDEX('schema_id = ', tl.resource_description) + 12), 
													0
												), 
												DATALENGTH(tl.resource_description)+1
											) - (CHARINDEX('schema_id = ', tl.resource_description) + 12)
										)
									)
								ELSE NULL
							END 
						) AS schema_id,
						CONVERT
						(
							INT,
							CASE
								WHEN tl.resource_description LIKE '%principal_id = %' THEN
									(
										SUBSTRING
										(
											tl.resource_description, 
											(CHARINDEX('principal_id = ', tl.resource_description) + 15), 
											COALESCE
											(
												NULLIF
												(
													CHARINDEX(',', tl.resource_description, CHARINDEX('principal_id = ', tl.resource_description) + 15), 
													0
												), 
												DATALENGTH(tl.resource_description)+1
											) - (CHARINDEX('principal_id = ', tl.resource_description) + 15)
										)
									)
								ELSE NULL
							END
						) AS principal_id,
						tl.request_mode,
						tl.request_status,
						tl.request_session_id AS session_id,
						tl.request_request_id AS request_id,

						/*TODO: Applocks, other resource_descriptions*/
						RTRIM(tl.resource_description) AS resource_description,
						tl.resource_associated_entity_id
						/*********************************************/
					FROM 
					(
						SELECT 
							request_session_id,
							CONVERT(VARCHAR(120), resource_type) COLLATE Latin1_General_Bin2 AS resource_type,
							CONVERT(VARCHAR(120), resource_subtype) COLLATE Latin1_General_Bin2 AS resource_subtype,
							resource_database_id,
							CONVERT(VARCHAR(512), resource_description) COLLATE Latin1_General_Bin2 AS resource_description,
							resource_associated_entity_id,
							CONVERT(VARCHAR(120), request_mode) COLLATE Latin1_General_Bin2 AS request_mode,
							CONVERT(VARCHAR(120), request_status) COLLATE Latin1_General_Bin2 AS request_status,
							request_request_id
						FROM sys.dm_tran_locks
					) AS tl
				) AS x
				GROUP BY
					x.resource_type,
					x.database_name,
					x.object_id,
					x.file_id,
					CASE
						WHEN x.page_no = 1 OR x.page_no % 8088 = 0 THEN 'PFS'
						WHEN x.page_no = 2 OR x.page_no % 511232 = 0 THEN 'GAM'
						WHEN x.page_no = 3 OR x.page_no % 511233 = 0 THEN 'SGAM'
						WHEN x.page_no = 6 OR x.page_no % 511238 = 0 THEN 'DCM'
						WHEN x.page_no = 7 OR x.page_no % 511239 = 0 THEN 'BCM'
						WHEN x.page_no IS NOT NULL THEN '*'
						ELSE NULL
					END,
					x.hobt_id,
					x.allocation_unit_id,
					x.index_id,
					x.schema_id,
					x.principal_id,
					x.request_mode,
					x.request_status,
					x.session_id,
					x.request_id,
					CASE
						WHEN COALESCE(x.object_id, x.file_id, x.hobt_id, x.allocation_unit_id, x.index_id, x.schema_id, x.principal_id) IS NULL THEN NULLIF(resource_description, '')
						ELSE NULL
					END
			) AS y ON
				y.session_id = s.session_id
				AND y.request_id = s.request_id
			OPTION (HASH GROUP);

			--Disable unnecessary autostats on the table
			CREATE STATISTICS s_database_name ON #locks (database_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_object_id ON #locks (object_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_hobt_id ON #locks (hobt_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_allocation_unit_id ON #locks (allocation_unit_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_index_id ON #locks (index_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_schema_id ON #locks (schema_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_principal_id ON #locks (principal_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_request_id ON #locks (request_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_start_time ON #locks (start_time)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_resource_type ON #locks (resource_type)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_object_name ON #locks (object_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_schema_name ON #locks (schema_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_page_type ON #locks (page_type)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_request_mode ON #locks (request_mode)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_request_status ON #locks (request_status)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_resource_description ON #locks (resource_description)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_index_name ON #locks (index_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_principal_name ON #locks (principal_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
		END;
		
		DECLARE 
			@sql VARCHAR(MAX), 
			@sql_n NVARCHAR(MAX);

		SET @sql = 
			CONVERT(VARCHAR(MAX), '') +
			'DECLARE @blocker BIT; ' +
			'SET @blocker = 0; ' +
			'DECLARE @i INT; ' +
			'SET @i = 2147483647; ' +
			'' +
			'DECLARE @sessions TABLE ' +
			'( ' +
				'session_id SMALLINT NOT NULL, ' +
				'request_id INT NOT NULL, ' +
				'login_time DATETIME, ' +
				'last_request_end_time DATETIME, ' +
				'status VARCHAR(30), ' +
				'statement_start_offset INT, ' +
				'statement_end_offset INT, ' +
				'sql_handle BINARY(20), ' +
				'host_name NVARCHAR(128), ' +
				'login_name NVARCHAR(128), ' +
				'program_name NVARCHAR(128), ' +
				'database_id SMALLINT, ' +
				'memory_usage INT, ' +
				'open_tran_count SMALLINT, ' +
				CASE
					WHEN 
					(
						@get_task_info <> 0 
						OR @find_block_leaders = 1 
					) THEN
						'wait_type NVARCHAR(32), ' +
						'wait_resource NVARCHAR(256), ' +
						'wait_time BIGINT, '
					ELSE ''
				END +
				'blocked SMALLINT, ' +
				'is_user_process BIT, ' +
				'cmd VARCHAR(32), ' +
				'PRIMARY KEY CLUSTERED (session_id, request_id) WITH (IGNORE_DUP_KEY = ON) ' +
			'); ' +
			'' +
			'DECLARE @blockers TABLE ' +
			'( ' +
				'session_id INT NOT NULL PRIMARY KEY ' +
			'); ' +
			'' +
			'BLOCKERS:; ' +
			'' +
			'INSERT @sessions ' +
			'( ' +
				'session_id, ' +
				'request_id, ' +
				'login_time, ' +
				'last_request_end_time, ' +
				'status, ' +
				'statement_start_offset, ' +
				'statement_end_offset, ' +
				'sql_handle, ' +
				'host_name, ' +
				'login_name, ' +
				'program_name, ' +
				'database_id, ' +
				'memory_usage, ' +
				'open_tran_count, ' +
				CASE
					WHEN 
					(
						@get_task_info <> 0
						OR @find_block_leaders = 1 
					) THEN
						'wait_type, ' +
						'wait_resource, ' +
						'wait_time, '
					ELSE
						''
				END +
				'blocked, ' +
				'is_user_process, ' +
				'cmd ' +
			') ' +
			'SELECT TOP(@i) ' +
				'spy.session_id, ' +
				'spy.request_id, ' +
				'spy.login_time, ' +
				'spy.last_request_end_time, ' +
				'spy.status, ' +
				'spy.statement_start_offset, ' +
				'spy.statement_end_offset, ' +
				'spy.sql_handle, ' +
				'spy.host_name, ' +
				'spy.login_name, ' +
				'spy.program_name, ' +
				'spy.database_id, ' +
				'spy.memory_usage, ' +
				'spy.open_tran_count, ' +
				CASE
					WHEN 
					(
						@get_task_info <> 0  
						OR @find_block_leaders = 1 
					) THEN
						'spy.wait_type, ' +
						'CASE ' +
							'WHEN ' +
								'spy.wait_type LIKE N''PAGE%LATCH_%'' ' +
								'OR spy.wait_type = N''CXPACKET'' ' +
								'OR spy.wait_type LIKE N''LATCH[_]%'' ' +
								'OR spy.wait_type = N''OLEDB'' THEN ' +
									'spy.wait_resource ' +
							'ELSE ' +
								'NULL ' +
						'END AS wait_resource, ' +
						'spy.wait_time, '
					ELSE ''
				END +
				'spy.blocked, ' +
				'spy.is_user_process, ' +
				'spy.cmd ' +
			'FROM ' +
			'( ' +
				'SELECT TOP(@i) ' +
					'spx.*, ' +
					CASE
						WHEN 
						(
							@get_task_info <> 0 
							OR @find_block_leaders = 1 
						) THEN
							'ROW_NUMBER() OVER ' +
							'( ' +
								'PARTITION BY ' +
									'spx.session_id, ' +
									'spx.request_id ' +
								'ORDER BY ' +
									'CASE ' +
										'WHEN spx.wait_type LIKE N''LCK[_]%'' THEN 1 ' +
										'ELSE 99 ' +
									'END, ' +
									'spx.wait_time DESC, ' +
									'spx.blocked DESC ' +
							') AS r '
						ELSE '1 AS r '
					END +
				'FROM ' +
				'( ' +
					'SELECT TOP(@i) ' +
						'sp0.session_id, ' +
						'sp0.request_id, ' +
						'sp0.login_time, ' +
						'sp0.last_request_end_time, ' +
						'LOWER(sp0.status) AS status, ' +
						'CASE ' +
							'WHEN sp0.cmd = ''CREATE INDEX'' THEN 0 ' +
							'ELSE sp0.stmt_start ' +
						'END AS statement_start_offset, ' +
						'CASE ' +
							'WHEN sp0.cmd = N''CREATE INDEX'' THEN -1 ' +
							'ELSE COALESCE(NULLIF(sp0.stmt_end, 0), -1) ' +
						'END AS statement_end_offset, ' +
						'sp0.sql_handle, ' +
						'sp0.host_name, ' +
						'sp0.login_name, ' +
						'sp0.program_name, ' +
						'sp0.database_id, ' +
						'sp0.memory_usage, ' +
						'sp0.open_tran_count, ' +
						CASE
							WHEN 
							(
								@get_task_info <> 0 
								OR @find_block_leaders = 1 
							) THEN
								'CASE ' +
									'WHEN sp0.wait_time > 0 AND sp0.wait_type <> N''CXPACKET'' THEN sp0.wait_type ' +
									'ELSE NULL ' +
								'END AS wait_type, ' +
								'CASE ' +
									'WHEN sp0.wait_time > 0 AND sp0.wait_type <> N''CXPACKET'' THEN sp0.wait_resource ' +
									'ELSE NULL ' +
								'END AS wait_resource, ' +
								'CASE ' +
									'WHEN sp0.wait_type <> N''CXPACKET'' THEN sp0.wait_time ' +
									'ELSE 0 ' +
								'END AS wait_time, '
							ELSE ''
						END +
						'sp0.blocked, ' +
						'sp0.is_user_process, ' +
						'sp0.cmd ' +
					'FROM ' +
					'( ' +
						'SELECT TOP(@i) ' +
							'sp1.session_id, ' +
							'sp1.request_id, ' +
							'sp1.login_time, ' +
							'sp1.last_request_end_time, ' +
							'sp1.status, ' +
							'sp1.cmd, ' +
							'sp1.stmt_start, ' +
							'sp1.stmt_end, ' +
							'MAX(NULLIF(sp1.sql_handle, 0x00)) OVER (PARTITION BY sp1.session_id, sp1.request_id) AS sql_handle, ' +
							'sp1.host_name, ' +
							'MAX(sp1.login_name) OVER (PARTITION BY sp1.session_id, sp1.request_id) AS login_name, ' +
							'sp1.program_name, ' +
							'sp1.database_id, ' +
							'MAX(sp1.memory_usage)  OVER (PARTITION BY sp1.session_id, sp1.request_id) AS memory_usage, ' +
							'MAX(sp1.open_tran_count)  OVER (PARTITION BY sp1.session_id, sp1.request_id) AS open_tran_count, ' +
							'sp1.wait_type, ' +
							'sp1.wait_resource, ' +
							'sp1.wait_time, ' +
							'sp1.blocked, ' +
							'sp1.hostprocess, ' +
							'sp1.is_user_process ' +
						'FROM ' +
						'( ' +
							'SELECT TOP(@i) ' +
								'sp2.spid AS session_id, ' +
								'CASE sp2.status ' +
									'WHEN ''sleeping'' THEN CONVERT(INT, 0) ' +
									'ELSE sp2.request_id ' +
								'END AS request_id, ' +
								'MAX(sp2.login_time) AS login_time, ' +
								'MAX(sp2.last_batch) AS last_request_end_time, ' +
								'MAX(CONVERT(VARCHAR(30), RTRIM(sp2.status)) COLLATE Latin1_General_Bin2) AS status, ' +
								'MAX(CONVERT(VARCHAR(32), RTRIM(sp2.cmd)) COLLATE Latin1_General_Bin2) AS cmd, ' +
								'MAX(sp2.stmt_start) AS stmt_start, ' +
								'MAX(sp2.stmt_end) AS stmt_end, ' +
								'MAX(sp2.sql_handle) AS sql_handle, ' +
								'MAX(CONVERT(sysname, RTRIM(sp2.hostname)) COLLATE SQL_Latin1_General_CP1_CI_AS) AS host_name, ' +
								'MAX(CONVERT(sysname, RTRIM(sp2.loginame)) COLLATE SQL_Latin1_General_CP1_CI_AS) AS login_name, ' +
								'MAX ' +
								'( ' +
									'CASE ' +
										'WHEN blk.queue_id IS NOT NULL THEN ' + 
											'N''Service Broker ' +
												'database_id: '' + CONVERT(NVARCHAR, blk.database_id) + ' +
												'N'' queue_id: '' + CONVERT(NVARCHAR, blk.queue_id)' +
										'ELSE ' +
											'CONVERT ' +
											'( ' +
												'sysname, ' +
												'RTRIM(sp2.program_name) ' +
											') ' +
									'END COLLATE SQL_Latin1_General_CP1_CI_AS ' +
								') AS program_name, ' +
								'MAX(sp2.dbid) AS database_id, ' +
								'MAX(sp2.memusage) AS memory_usage, ' +
								'MAX(sp2.open_tran) AS open_tran_count, ' +
								'RTRIM(sp2.lastwaittype) AS wait_type, ' +
								'RTRIM(sp2.waitresource) AS wait_resource, ' +
								'MAX(sp2.waittime) AS wait_time, ' +
								'COALESCE(NULLIF(sp2.blocked, sp2.spid), 0) AS blocked, ' +
								'MAX ' +
								'( ' +
									'CASE ' +
										'WHEN blk.session_id = sp2.spid THEN ' +
											'''blocker'' ' +
										'ELSE ' +
											'RTRIM(sp2.hostprocess) ' +
									'END ' +
								') AS hostprocess, ' +
								'CONVERT ' +
								'( ' +
									'BIT, ' +
									'MAX ' +
									'( ' +
										'CASE ' +
											'WHEN sp2.hostprocess > '''' THEN ' +
												'1 ' +
											'ELSE ' +
												'0 ' +
										'END ' +
									') ' +
								') AS is_user_process ' +
							'FROM ' +
							'( ' +
								'SELECT TOP(@i) ' +
									'session_id, ' +
									'CONVERT(INT, NULL) AS queue_id, ' +
									'CONVERT(INT, NULL) AS database_id ' +
								'FROM @blockers ' +
								'' +
								'UNION ALL ' +
								'' +
								'SELECT TOP(@i) ' +
									'CONVERT(SMALLINT, 0), ' +
									'CONVERT(INT, NULL) AS queue_id, ' +
									'CONVERT(INT, NULL) AS database_id ' +
								'WHERE ' +
									'@blocker = 0 ' +
								'' +
								'UNION ALL ' +
								'' +
								'SELECT TOP(@i) ' +
									'CONVERT(SMALLINT, spid), ' +
									'queue_id, ' +
									'database_id ' +
								'FROM sys.dm_broker_activated_tasks ' +
								'WHERE ' +
									'@blocker = 0 ' +
							') AS blk ' +
							'INNER JOIN sys.sysprocesses AS sp2 ON ' +
								'sp2.spid = blk.session_id ' +
								'OR ' +
								'( ' +
									'blk.session_id = 0 ' +
									'AND @blocker = 0 ' +
								') ' +
							CASE 
								WHEN 
								(
									@get_task_info = 0 
									AND @find_block_leaders = 0
								) THEN
									'WHERE ' +
										'sp2.ecid = 0 ' 
								ELSE ''
							END +
							'GROUP BY ' +
								'sp2.spid, ' +
								'CASE sp2.status ' +
									'WHEN ''sleeping'' THEN CONVERT(INT, 0) ' +
									'ELSE sp2.request_id ' +
								'END, ' +
								'RTRIM(sp2.lastwaittype), ' +
								'RTRIM(sp2.waitresource), ' +
								'COALESCE(NULLIF(sp2.blocked, sp2.spid), 0) ' +
						') AS sp1 ' +
					') AS sp0 ' +
					'WHERE ' +
						'@blocker = 1 ' +
						'OR ' +
						'(1=1 ' +
							--inclusive filter
							CASE
								WHEN @filter <> '' THEN
									CASE @filter_type
										WHEN 'session' THEN
											CASE
												WHEN CONVERT(SMALLINT, @filter) <> 0 THEN
													'AND sp0.session_id = CONVERT(SMALLINT, @filter) '
												ELSE ''
											END
										WHEN 'program' THEN
											'AND sp0.program_name LIKE @filter '
										WHEN 'login' THEN
											'AND sp0.login_name LIKE @filter '
										WHEN 'host' THEN
											'AND sp0.host_name LIKE @filter '
										WHEN 'database' THEN
											'AND DB_NAME(sp0.database_id) LIKE @filter '
										ELSE ''
									END
								ELSE ''
							END +
							--exclusive filter
							CASE
								WHEN @not_filter <> '' THEN
									CASE @not_filter_type
										WHEN 'session' THEN
											CASE
												WHEN CONVERT(SMALLINT, @not_filter) <> 0 THEN
													'AND sp0.session_id <> CONVERT(SMALLINT, @not_filter) '
												ELSE ''
											END
										WHEN 'program' THEN
											'AND sp0.program_name NOT LIKE @not_filter '
										WHEN 'login' THEN
											'AND sp0.login_name NOT LIKE @not_filter '
										WHEN 'host' THEN
											'AND sp0.host_name NOT LIKE @not_filter '
										WHEN 'database' THEN
											'AND DB_NAME(sp0.database_id) NOT LIKE @not_filter '
										ELSE ''
									END
								ELSE ''
							END +
							CASE @show_own_spid
								WHEN 1 THEN ''
								ELSE
									'AND sp0.session_id <> @@spid '
							END +
							CASE 
								WHEN @show_system_spids = 0 THEN
									'AND sp0.hostprocess > '''' ' 
								ELSE ''
							END +
							CASE @show_sleeping_spids
								WHEN 0 THEN
									'AND sp0.status <> ''sleeping'' '
								WHEN 1 THEN
									'AND ' +
									'( ' +
										'sp0.status <> ''sleeping'' ' +
										'OR sp0.open_tran_count > 0 ' +
									') '
								ELSE ''
							END +
						') ' +
				') AS spx ' +
			') AS spy ' +
			'WHERE ' +
				'spy.r = 1; ' + 
			CASE @recursion
				WHEN 1 THEN 
					'IF @@ROWCOUNT > 0 ' +
					'BEGIN; ' +
						'INSERT @blockers ' +
						'( ' +
							'session_id ' +
						') ' +
						'SELECT TOP(@i) ' +
							'blocked ' +
						'FROM @sessions ' +
						'WHERE ' +
							'NULLIF(blocked, 0) IS NOT NULL ' +
						'' +
						'EXCEPT ' +
						'' +
						'SELECT TOP(@i) ' +
							'session_id ' +
						'FROM @sessions; ' +
						'' +
						CASE
							WHEN
							(
								@get_task_info > 0
								OR @find_block_leaders = 1
							) THEN
								'IF @@ROWCOUNT > 0 ' +
								'BEGIN; ' +
									'SET @blocker = 1; ' +
									'GOTO BLOCKERS; ' +
								'END; '
							ELSE ''
						END +
					'END; '
				ELSE ''
			END +
			'SELECT TOP(@i) ' +
				'@recursion AS recursion, ' +
				'x.session_id, ' +
				'x.request_id, ' +
				'DENSE_RANK() OVER  ' +
				'( ' +
					'ORDER BY ' +
						'x.session_id ' +
				') AS session_number, ' +
				CASE
					WHEN @output_column_list LIKE '%|[dd hh:mm:ss.mss|]%' ESCAPE '|' THEN 'x.elapsed_time '
					ELSE '0 '
				END + 'AS elapsed_time, ' +
				CASE
					WHEN
						(
							@output_column_list LIKE '%|[dd hh:mm:ss.mss (avg)|]%' ESCAPE '|' OR 
							@output_column_list LIKE '%|[avg_elapsed_time|]%' ESCAPE '|'
						)
						AND @recursion = 1
							THEN 'x.avg_elapsed_time / 1000 '
					ELSE 'NULL '
				END + 'AS avg_elapsed_time, ' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[physical_io|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[physical_io_delta|]%' ESCAPE '|'
							THEN 'x.physical_io '
					ELSE 'NULL '
				END + 'AS physical_io, ' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[reads|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[reads_delta|]%' ESCAPE '|'
							THEN 'x.reads '
					ELSE '0 '
				END + 'AS reads, ' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[physical_reads|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[physical_reads_delta|]%' ESCAPE '|'
							THEN 'x.physical_reads '
					ELSE '0 '
				END + 'AS physical_reads, ' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[writes|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[writes_delta|]%' ESCAPE '|'
							THEN 'x.writes '
					ELSE '0 '
				END + 'AS writes, ' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[tempdb_allocations|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[tempdb_allocations_delta|]%' ESCAPE '|'
							THEN 'x.tempdb_allocations '
					ELSE '0 '
				END + 'AS tempdb_allocations, ' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[tempdb_current|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[tempdb_current_delta|]%' ESCAPE '|'
							THEN 'x.tempdb_current '
					ELSE '0 '
				END + 'AS tempdb_current, ' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[CPU|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[CPU_delta|]%' ESCAPE '|'
							THEN 'x.CPU '
					ELSE '0 '
				END + 'AS CPU, ' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[CPU_delta|]%' ESCAPE '|'
						AND @get_task_info = 2
							THEN 'x.thread_CPU_snapshot '
					ELSE '0 '
				END + 'AS thread_CPU_snapshot, ' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[context_switches|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[context_switches_delta|]%' ESCAPE '|'
							THEN 'x.context_switches '
					ELSE 'NULL '
				END + 'AS context_switches, ' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[used_memory|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[used_memory_delta|]%' ESCAPE '|'
							THEN 'x.used_memory '
					ELSE '0 '
				END + 'AS used_memory, ' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[tasks|]%' ESCAPE '|'
						AND @recursion = 1
							THEN 'x.tasks '
					ELSE 'NULL '
				END + 'AS tasks, ' +
				CASE
					WHEN 
						(
							@output_column_list LIKE '%|[status|]%' ESCAPE '|' 
							OR @output_column_list LIKE '%|[sql_command|]%' ESCAPE '|'
						)
						AND @recursion = 1
							THEN 'x.status '
					ELSE ''''' '
				END + 'AS status, ' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[wait_info|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								CASE @get_task_info
									WHEN 2 THEN 'COALESCE(x.task_wait_info, x.sys_wait_info) '
									ELSE 'x.sys_wait_info '
								END
					ELSE 'NULL '
				END + 'AS wait_info, ' +
				CASE
					WHEN 
						(
							@output_column_list LIKE '%|[tran_start_time|]%' ESCAPE '|' 
							OR @output_column_list LIKE '%|[tran_log_writes|]%' ESCAPE '|' 
						)
						AND @recursion = 1
							THEN 
							'x.transaction_id '
					ELSE 'NULL '
				END + 'AS transaction_id, ' +					
				CASE
					WHEN 
						@output_column_list LIKE '%|[open_tran_count|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 'x.open_tran_count '
					ELSE 'NULL '
				END + 'AS open_tran_count, ' + 
				CASE
					WHEN 
						@output_column_list LIKE '%|[sql_text|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 'x.sql_handle '
					ELSE 'NULL '
				END + 'AS sql_handle, ' +
				CASE
					WHEN 
						(
							@output_column_list LIKE '%|[sql_text|]%' ESCAPE '|' 
							OR @output_column_list LIKE '%|[query_plan|]%' ESCAPE '|' 
						)
						AND @recursion = 1
							THEN 'x.statement_start_offset '
					ELSE 'NULL '
				END + 'AS statement_start_offset, ' +
				CASE
					WHEN 
						(
							@output_column_list LIKE '%|[sql_text|]%' ESCAPE '|' 
							OR @output_column_list LIKE '%|[query_plan|]%' ESCAPE '|' 
						)
						AND @recursion = 1
							THEN 'x.statement_end_offset '
					ELSE 'NULL '
				END + 'AS statement_end_offset, ' +
				'NULL AS sql_text, ' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[query_plan|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 'x.plan_handle '
					ELSE 'NULL '
				END + 'AS plan_handle, ' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[blocking_session_id|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 'NULLIF(x.blocking_session_id, 0) '
					ELSE 'NULL '
				END + 'AS blocking_session_id, ' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[percent_complete|]%' ESCAPE '|'
						AND @recursion = 1
							THEN 'x.percent_complete '
					ELSE 'NULL '
				END + 'AS percent_complete, ' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[host_name|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 'x.host_name '
					ELSE ''''' '
				END + 'AS host_name, ' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[login_name|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 'x.login_name '
					ELSE ''''' '
				END + 'AS login_name, ' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[database_name|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 'DB_NAME(x.database_id) '
					ELSE 'NULL '
				END + 'AS database_name, ' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[program_name|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 'x.program_name '
					ELSE ''''' '
				END + 'AS program_name, ' +
				CASE
					WHEN
						@output_column_list LIKE '%|[additional_info|]%' ESCAPE '|'
						AND @recursion = 1
							THEN
								'( ' +
									'SELECT TOP(@i) ' +
										'text_size, ' +
										'language, ' +
										'date_format, ' +
										'date_first, ' +
										'CASE quoted_identifier ' +
											'WHEN 0 THEN ''OFF'' ' +
											'WHEN 1 THEN ''ON'' ' +
										'END AS quoted_identifier, ' +
										'CASE arithabort ' +
											'WHEN 0 THEN ''OFF'' ' +
											'WHEN 1 THEN ''ON'' ' +
										'END AS arithabort, ' +
										'CASE ansi_null_dflt_on ' +
											'WHEN 0 THEN ''OFF'' ' +
											'WHEN 1 THEN ''ON'' ' +
										'END AS ansi_null_dflt_on, ' +
										'CASE ansi_defaults ' +
											'WHEN 0 THEN ''OFF'' ' +
											'WHEN 1 THEN ''ON'' ' +
										'END AS ansi_defaults, ' +
										'CASE ansi_warnings ' +
											'WHEN 0 THEN ''OFF'' ' +
											'WHEN 1 THEN ''ON'' ' +
										'END AS ansi_warnings, ' +
										'CASE ansi_padding ' +
											'WHEN 0 THEN ''OFF'' ' +
											'WHEN 1 THEN ''ON'' ' +
										'END AS ansi_padding, ' +
										'CASE ansi_nulls ' +
											'WHEN 0 THEN ''OFF'' ' +
											'WHEN 1 THEN ''ON'' ' +
										'END AS ansi_nulls, ' +
										'CASE concat_null_yields_null ' +
											'WHEN 0 THEN ''OFF'' ' +
											'WHEN 1 THEN ''ON'' ' +
										'END AS concat_null_yields_null, ' +
										'CASE transaction_isolation_level ' +
											'WHEN 0 THEN ''Unspecified'' ' +
											'WHEN 1 THEN ''ReadUncomitted'' ' +
											'WHEN 2 THEN ''ReadCommitted'' ' +
											'WHEN 3 THEN ''Repeatable'' ' +
											'WHEN 4 THEN ''Serializable'' ' +
											'WHEN 5 THEN ''Snapshot'' ' +
										'END AS transaction_isolation_level, ' +
										'lock_timeout, ' +
										'deadlock_priority, ' +
										'row_count, ' +
										'command_type, ' +
										CASE
											WHEN @output_column_list LIKE '%|[program_name|]%' ESCAPE '|' THEN
												'( ' +
													'SELECT TOP(1) ' +
														'CONVERT(uniqueidentifier, CONVERT(XML, '''').value(''xs:hexBinary( substring(sql:column("agent_info.job_id_string"), 0) )'', ''binary(16)'')) AS job_id, ' +
														'agent_info.step_id, ' +
														'( ' +
															'SELECT TOP(1) ' +
																'NULL ' +
															'FOR XML ' +
																'PATH(''job_name''), ' +
																'TYPE ' +
														'), ' +
														'( ' +
															'SELECT TOP(1) ' +
																'NULL ' +
															'FOR XML ' +
																'PATH(''step_name''), ' +
																'TYPE ' +
														') ' +
													'FROM ' +
													'( ' +
														'SELECT TOP(1) ' +
															'SUBSTRING(x.program_name, CHARINDEX(''0x'', x.program_name) + 2, 32) AS job_id_string, ' +
															'SUBSTRING(x.program_name, CHARINDEX('': Step '', x.program_name) + 7, CHARINDEX('')'', x.program_name, CHARINDEX('': Step '', x.program_name)) - (CHARINDEX('': Step '', x.program_name) + 7)) AS step_id ' +
														'WHERE '+
															'x.program_name LIKE N''SQLAgent - TSQL JobStep (Job 0x%'' ' +
													') AS agent_info ' +
													'FOR XML ' +
														'PATH(''agent_job_info''), ' +
														'TYPE ' +
												') '
											ELSE ''
										END +
										CASE
											WHEN @get_task_info = 2 THEN
												', CONVERT(XML, x.block_info) AS block_info '
											ELSE
												''
										END +
									'FOR XML ' +
										'PATH(''additional_info''), ' +
										'TYPE ' +
								') '
					ELSE 'NULL '
				END + 'AS additional_info, ' +
				'x.start_time, ' +
				CASE
					WHEN
						@output_column_list LIKE '%|[login_time|]%' ESCAPE '|'
						AND @recursion = 1
							THEN
								'x.login_time '
					ELSE 'NULL '
				END + 'AS login_time, ' +
				'x.last_request_start_time ' +
			'FROM ' +
			'( ' +
				'SELECT TOP(@i) ' +
					'y.*, ' +
					'CASE ' +
						--if there are more than 24 days, return a negative number of seconds rather than
						--positive milliseconds, in order to avoid overflow errors
						'WHEN DATEDIFF(day, y.start_time, GETDATE()) > 24 THEN ' +
							'DATEDIFF(second, GETDATE(), y.start_time) ' +
						'ELSE DATEDIFF(ms, y.start_time, GETDATE()) ' +
					'END AS elapsed_time, ' +
					'COALESCE(tempdb_info.tempdb_allocations, 0) AS tempdb_allocations, ' +
					'COALESCE ' +
					'( ' +
						'CASE ' +
							'WHEN tempdb_info.tempdb_current < 0 THEN 0 ' +
							'ELSE tempdb_info.tempdb_current ' + 
						'END, ' +
						'0 ' +
					') AS tempdb_current, ' +
					CASE
						WHEN 
							(
								@get_task_info <> 0
								OR @find_block_leaders = 1
							) THEN
								'N''('' + CONVERT(NVARCHAR, y.wait_duration_ms) + N''ms)'' + ' +
									'y.wait_type + ' +
										--TODO: What else can be pulled from the resource_description?
										'CASE ' +
											'WHEN y.wait_type LIKE N''PAGE%LATCH_%'' THEN ' +
												'N'':'' + ' +
												--database name
												'COALESCE(DB_NAME(CONVERT(INT, LEFT(y.resource_description, CHARINDEX(N'':'', y.resource_description) - 1))), N''(null)'') + ' +
												'N'':'' + ' +
												--file id
												'SUBSTRING(y.resource_description, CHARINDEX(N'':'', y.resource_description) + 1, LEN(y.resource_description) - CHARINDEX(N'':'', REVERSE(y.resource_description)) - CHARINDEX(N'':'', y.resource_description)) + ' +
												--page # for special pages
												'N''('' + ' +
													'CASE ' +
														'WHEN ' +
															'CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) = 1 OR ' +
															'CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) % 8088 = 0 THEN N''PFS'' ' +
														'WHEN ' +
															'CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) = 2 OR ' +
															'CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) % 511232 = 0 THEN N''GAM'' ' +
														'WHEN ' +
															'CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) = 3 OR ' +
															'CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) % 511233 = 0 THEN N''SGAM'' ' +
														'WHEN ' +
															'CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) = 6 OR ' +
															'CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) % 511238 = 0 THEN N''DCM'' ' +
														'WHEN ' +
															'CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) = 7 OR ' +
															'CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) % 511239 = 0 THEN N''BCM'' ' +
														'ELSE N''*'' ' +
													'END + ' +
												'N'')'' ' +
											'WHEN y.wait_type = N''CXPACKET'' THEN ' +
												'N'':'' + SUBSTRING(y.resource_description, CHARINDEX(N''nodeId'', y.resource_description) + 7, 4)' +
											'WHEN y.wait_type LIKE N''LATCH[_]%'' THEN ' +
												'N'' ['' + LEFT(y.resource_description, COALESCE(NULLIF(CHARINDEX(N'' '', y.resource_description), 0), LEN(y.resource_description) + 1) - 1) + N'']'' ' +
											'WHEN ' +
												'y.wait_type = N''OLEDB'' ' +
												'AND y.resource_description LIKE N''%(SPID=%)'' THEN ' +
													'N''['' + LEFT(y.resource_description, CHARINDEX(N''(SPID='', y.resource_description) - 2) + ' +
														'N'':'' + SUBSTRING(y.resource_description, CHARINDEX(N''(SPID='', y.resource_description) + 6, CHARINDEX(N'')'', y.resource_description, (CHARINDEX(N''(SPID='', y.resource_description) + 6)) - (CHARINDEX(N''(SPID='', y.resource_description) + 6)) + '']'' ' +
											'ELSE N'''' ' +
										'END COLLATE Latin1_General_Bin2 AS sys_wait_info, '
						ELSE
							''
						END +
						CASE
							WHEN @get_task_info = 2 THEN
								'tasks.physical_io, ' +
								'tasks.context_switches, ' + 
								'tasks.tasks, ' +
								'tasks.block_info, ' +
								'tasks.wait_info AS task_wait_info, ' +
								'tasks.thread_CPU_snapshot, '
						ELSE
							'' 
					END +
					CASE 
						WHEN NOT (@get_avg_time = 1 AND @recursion = 1) THEN 'CONVERT(INT, NULL) '
						ELSE 'qs.total_elapsed_time / qs.execution_count '
					END + 'AS avg_elapsed_time ' +
				'FROM ' +
				'( ' +
					'SELECT TOP(@i) ' +
						'sp.session_id, ' +
						'sp.request_id, ' +
						'COALESCE(r.logical_reads, s.logical_reads) AS reads, ' +
						'COALESCE(r.reads, s.reads) AS physical_reads, ' +
						'COALESCE(r.writes, s.writes) AS writes, ' +
						'COALESCE(r.CPU_time, s.CPU_time) AS CPU, ' +
						'sp.memory_usage + COALESCE(r.granted_query_memory, 0) AS used_memory, ' +
						'LOWER(sp.status) AS status, ' +
						'COALESCE(r.sql_handle, sp.sql_handle) AS sql_handle, ' +
						'COALESCE(r.statement_start_offset, sp.statement_start_offset) AS statement_start_offset, ' +
						'COALESCE(r.statement_end_offset, sp.statement_end_offset) AS statement_end_offset, ' +
						CASE
							WHEN 
							(
								@get_task_info <> 0
								OR @find_block_leaders = 1 
							) THEN
								'sp.wait_type COLLATE Latin1_General_Bin2 AS wait_type, ' +
								'sp.wait_resource COLLATE Latin1_General_Bin2 AS resource_description, ' +
								'sp.wait_time AS wait_duration_ms, '
							ELSE ''
						END +
						'NULLIF(sp.blocked, 0) AS blocking_session_id, ' +
						'r.plan_handle, ' +
						'NULLIF(r.percent_complete, 0) AS percent_complete, ' +
						'sp.host_name, ' +
						'sp.login_name, ' +
						'sp.program_name, ' +
						'COALESCE(r.text_size, s.text_size) AS text_size, ' +
						'COALESCE(r.language, s.language) AS language, ' +
						'COALESCE(r.date_format, s.date_format) AS date_format, ' +
						'COALESCE(r.date_first, s.date_first) AS date_first, ' +
						'COALESCE(r.quoted_identifier, s.quoted_identifier) AS quoted_identifier, ' +
						'COALESCE(r.arithabort, s.arithabort) AS arithabort, ' +
						'COALESCE(r.ansi_null_dflt_on, s.ansi_null_dflt_on) AS ansi_null_dflt_on, ' +
						'COALESCE(r.ansi_defaults, s.ansi_defaults) AS ansi_defaults, ' +
						'COALESCE(r.ansi_warnings, s.ansi_warnings) AS ansi_warnings, ' +
						'COALESCE(r.ansi_padding, s.ansi_padding) AS ansi_padding, ' +
						'COALESCE(r.ansi_nulls, s.ansi_nulls) AS ansi_nulls, ' +
						'COALESCE(r.concat_null_yields_null, s.concat_null_yields_null) AS concat_null_yields_null, ' +
						'COALESCE(r.transaction_isolation_level, s.transaction_isolation_level) AS transaction_isolation_level, ' +
						'COALESCE(r.lock_timeout, s.lock_timeout) AS lock_timeout, ' +
						'COALESCE(r.deadlock_priority, s.deadlock_priority) AS deadlock_priority, ' +
						'COALESCE(r.row_count, s.row_count) AS row_count, ' +
						'COALESCE(r.command, sp.cmd) AS command_type, ' +
						'COALESCE ' +
						'( ' +
							'CASE ' +
								'WHEN ' +
								'( ' +
									's.is_user_process = 0 ' +
									'AND r.total_elapsed_time >= 0 ' +
								') THEN ' +
									'DATEADD ' +
									'( ' +
										'ms, ' +
										'1000 * (DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())) / 500) - DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())), ' +
										'DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE()) ' +
									') ' +
							'END, ' +
							'NULLIF(COALESCE(r.start_time, sp.last_request_end_time), CONVERT(DATETIME, ''19000101'', 112)), ' +
							'( ' +
								'SELECT TOP(1) ' +
									'DATEADD(second, -(ms_ticks / 1000), GETDATE()) ' +
								'FROM sys.dm_os_sys_info ' +
							') ' +
						') AS start_time, ' +
						'sp.login_time, ' +
						'CASE ' +
							'WHEN s.is_user_process = 1 THEN ' +
								's.last_request_start_time ' +
							'ELSE ' +
								'COALESCE ' +
								'( ' +
									'DATEADD ' +
									'( ' +
										'ms, ' +
										'1000 * (DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())) / 500) - DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())), ' +
										'DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE()) ' +
									'), ' +
									's.last_request_start_time ' +
								') ' +
						'END AS last_request_start_time, ' +
						'r.transaction_id, ' +
						'sp.database_id, ' +
						'sp.open_tran_count ' +
					'FROM @sessions AS sp ' +
					'LEFT OUTER LOOP JOIN sys.dm_exec_sessions AS s ON ' +
						's.session_id = sp.session_id ' +
						'AND s.login_time = sp.login_time ' +
					'LEFT OUTER LOOP JOIN sys.dm_exec_requests AS r ON ' +
						'sp.status <> ''sleeping'' ' +
						'AND r.session_id = sp.session_id ' +
						'AND r.request_id = sp.request_id ' +
						'AND ' +
						'( ' +
							'( ' +
								's.is_user_process = 0 ' +
								'AND sp.is_user_process = 0 ' +
							') ' +
							'OR ' +
							'( ' +
								'r.start_time = s.last_request_start_time ' +
								'AND s.last_request_end_time = sp.last_request_end_time ' +
							') ' +
						') ' +
				') AS y ' + 
				CASE 
					WHEN @get_task_info = 2 THEN
						CONVERT(VARCHAR(MAX), '') +
						'LEFT OUTER HASH JOIN ' +
						'( ' +
							'SELECT TOP(@i) ' +
								'task_nodes.task_node.value(''(session_id/text())[1]'', ''SMALLINT'') AS session_id, ' +
								'task_nodes.task_node.value(''(request_id/text())[1]'', ''INT'') AS request_id, ' +
								'task_nodes.task_node.value(''(physical_io/text())[1]'', ''BIGINT'') AS physical_io, ' +
								'task_nodes.task_node.value(''(context_switches/text())[1]'', ''BIGINT'') AS context_switches, ' +
								'task_nodes.task_node.value(''(tasks/text())[1]'', ''INT'') AS tasks, ' +
								'task_nodes.task_node.value(''(block_info/text())[1]'', ''NVARCHAR(4000)'') AS block_info, ' +
								'task_nodes.task_node.value(''(waits/text())[1]'', ''NVARCHAR(4000)'') AS wait_info, ' +
								'task_nodes.task_node.value(''(thread_CPU_snapshot/text())[1]'', ''BIGINT'') AS thread_CPU_snapshot ' +
							'FROM ' +
							'( ' +
								'SELECT TOP(@i) ' +
									'CONVERT ' +
									'( ' +
										'XML, ' +
										'REPLACE ' +
										'( ' +
											'CONVERT(NVARCHAR(MAX), tasks_raw.task_xml_raw) COLLATE Latin1_General_Bin2, ' +
											'N''</waits></tasks><tasks><waits>'', ' +
											'N'', '' ' +
										') ' +
									') AS task_xml ' +
								'FROM ' +
								'( ' +
									'SELECT TOP(@i) ' +
										'CASE waits.r ' +
											'WHEN 1 THEN waits.session_id ' +
											'ELSE NULL ' +
										'END AS [session_id], ' +
										'CASE waits.r ' +
											'WHEN 1 THEN waits.request_id ' +
											'ELSE NULL ' +
										'END AS [request_id], ' +											
										'CASE waits.r ' +
											'WHEN 1 THEN waits.physical_io ' +
											'ELSE NULL ' +
										'END AS [physical_io], ' +
										'CASE waits.r ' +
											'WHEN 1 THEN waits.context_switches ' +
											'ELSE NULL ' +
										'END AS [context_switches], ' +
										'CASE waits.r ' +
											'WHEN 1 THEN waits.thread_CPU_snapshot ' +
											'ELSE NULL ' +
										'END AS [thread_CPU_snapshot], ' +
										'CASE waits.r ' +
											'WHEN 1 THEN waits.tasks ' +
											'ELSE NULL ' +
										'END AS [tasks], ' +
										'CASE waits.r ' +
											'WHEN 1 THEN waits.block_info ' +
											'ELSE NULL ' +
										'END AS [block_info], ' +
										'REPLACE ' +
										'( ' +
											'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
											'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
											'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
												'CONVERT ' +
												'( ' +
													'NVARCHAR(MAX), ' +
													'N''('' + ' +
														'CONVERT(NVARCHAR, num_waits) + N''x: '' + ' +
														'CASE num_waits ' +
															'WHEN 1 THEN CONVERT(NVARCHAR, min_wait_time) + N''ms'' ' +
															'WHEN 2 THEN ' +
																'CASE ' +
																	'WHEN min_wait_time <> max_wait_time THEN CONVERT(NVARCHAR, min_wait_time) + N''/'' + CONVERT(NVARCHAR, max_wait_time) + N''ms'' ' +
																	'ELSE CONVERT(NVARCHAR, max_wait_time) + N''ms'' ' +
																'END ' +
															'ELSE ' +
																'CASE ' +
																	'WHEN min_wait_time <> max_wait_time THEN CONVERT(NVARCHAR, min_wait_time) + N''/'' + CONVERT(NVARCHAR, avg_wait_time) + N''/'' + CONVERT(NVARCHAR, max_wait_time) + N''ms'' ' +
																	'ELSE CONVERT(NVARCHAR, max_wait_time) + N''ms'' ' +
																'END ' +
														'END + ' +
													'N'')'' + wait_type COLLATE Latin1_General_Bin2 ' +
												'), ' +
												'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
												'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
												'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
											'NCHAR(0), ' +
											'N'''' ' +
										') AS [waits] ' +
									'FROM ' +
									'( ' +
										'SELECT TOP(@i) ' +
											'w1.*, ' +
											'ROW_NUMBER() OVER ' +
											'( ' +
												'PARTITION BY ' +
													'w1.session_id, ' +
													'w1.request_id ' +
												'ORDER BY ' +
													'w1.block_info DESC, ' +
													'w1.num_waits DESC, ' +
													'w1.wait_type ' +
											') AS r ' +
										'FROM ' +
										'( ' +
											'SELECT TOP(@i) ' +
												'task_info.session_id, ' +
												'task_info.request_id, ' +
												'task_info.physical_io, ' +
												'task_info.context_switches, ' +
												'task_info.thread_CPU_snapshot, ' +
												'task_info.num_tasks AS tasks, ' +
												'CASE ' +
													'WHEN task_info.runnable_time IS NOT NULL THEN ' +
														'''RUNNABLE'' ' +
													'ELSE ' +
														'wt2.wait_type ' +
												'END AS wait_type, ' +
												'NULLIF(COUNT(COALESCE(task_info.runnable_time, wt2.waiting_task_address)), 0) AS num_waits, ' +
												'MIN(COALESCE(task_info.runnable_time, wt2.wait_duration_ms)) AS min_wait_time, ' +
												'AVG(COALESCE(task_info.runnable_time, wt2.wait_duration_ms)) AS avg_wait_time, ' +
												'MAX(COALESCE(task_info.runnable_time, wt2.wait_duration_ms)) AS max_wait_time, ' +
												'MAX(wt2.block_info) AS block_info ' +
											'FROM ' +
											'( ' +
												'SELECT TOP(@i) ' +
													't.session_id, ' +
													't.request_id, ' +
													'SUM(CONVERT(BIGINT, t.pending_io_count)) OVER (PARTITION BY t.session_id, t.request_id) AS physical_io, ' +
													'SUM(CONVERT(BIGINT, t.context_switches_count)) OVER (PARTITION BY t.session_id, t.request_id) AS context_switches, ' +
													CASE
														WHEN @output_column_list LIKE '%|[CPU_delta|]%' ESCAPE '|'
															THEN
																'SUM(tr.usermode_time + tr.kernel_time) OVER (PARTITION BY t.session_id, t.request_id) '
														ELSE
															'CONVERT(BIGINT, NULL) '
													END + ' AS thread_CPU_snapshot, ' +
													'COUNT(*) OVER (PARTITION BY t.session_id, t.request_id) AS num_tasks, ' +
													't.task_address, ' +
													't.task_state, ' +
													'CASE ' +
														'WHEN ' +
															't.task_state = ''RUNNABLE'' ' +
															'AND w.runnable_time > 0 THEN ' +
																'w.runnable_time ' +
														'ELSE ' +
															'NULL ' +
													'END AS runnable_time ' +
												'FROM sys.dm_os_tasks AS t ' +
												'CROSS APPLY ' +
												'( ' +
													'SELECT TOP(1) ' +
														'sp2.session_id ' +
													'FROM @sessions AS sp2 ' +
													'WHERE ' +
														'sp2.session_id = t.session_id ' +
														'AND sp2.request_id = t.request_id ' +
														'AND sp2.status <> ''sleeping'' ' +
												') AS sp20 ' +
												'LEFT OUTER HASH JOIN ' +
												'( ' +
													'SELECT TOP(@i) ' +
														'( ' +
															'SELECT TOP(@i) ' +
																'ms_ticks ' +
															'FROM sys.dm_os_sys_info ' +
														') - ' +
															'w0.wait_resumed_ms_ticks AS runnable_time, ' +
														'w0.worker_address, ' +
														'w0.thread_address, ' +
														'w0.task_bound_ms_ticks ' +
													'FROM sys.dm_os_workers AS w0 ' +
													'WHERE ' +
														'w0.state = ''RUNNABLE'' ' +
														'OR @first_collection_ms_ticks >= w0.task_bound_ms_ticks ' +
												') AS w ON ' +
													'w.worker_address = t.worker_address ' +
												CASE
													WHEN @output_column_list LIKE '%|[CPU_delta|]%' ESCAPE '|'
														THEN
															'LEFT OUTER HASH JOIN sys.dm_os_threads AS tr ON ' +
																'tr.thread_address = w.thread_address ' +
																'AND @first_collection_ms_ticks >= w.task_bound_ms_ticks ' 
													ELSE
														''
												END +
											') AS task_info ' +
											'LEFT OUTER HASH JOIN ' +
											'( ' +
												'SELECT TOP(@i) ' +
													'wt1.wait_type, ' +
													'wt1.waiting_task_address, ' +
													'MAX(wt1.wait_duration_ms) AS wait_duration_ms, ' +
													'MAX(wt1.block_info) AS block_info ' +
												'FROM ' +
												'( ' +
													'SELECT DISTINCT TOP(@i) ' +
														'wt.wait_type + ' +
															--TODO: What else can be pulled from the resource_description?
															'CASE ' +
																'WHEN wt.wait_type LIKE N''PAGE%LATCH_%'' THEN ' +
																	''':'' + ' +
																	--database name
																	'COALESCE(DB_NAME(CONVERT(INT, LEFT(wt.resource_description, CHARINDEX(N'':'', wt.resource_description) - 1))), N''(null)'') + ' +
																	'N'':'' + ' +
																	--file id
																	'SUBSTRING(wt.resource_description, CHARINDEX(N'':'', wt.resource_description) + 1, LEN(wt.resource_description) - CHARINDEX(N'':'', REVERSE(wt.resource_description)) - CHARINDEX(N'':'', wt.resource_description)) + ' +
																	--page # for special pages
																	'N''('' + ' +
																		'CASE ' +
																			'WHEN ' +
																				'CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) = 1 OR ' +
																				'CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) % 8088 = 0 THEN N''PFS'' ' +
																			'WHEN ' +
																				'CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) = 2 OR ' +
																				'CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) % 511232 = 0 THEN N''GAM'' ' +
																			'WHEN ' +
																				'CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) = 3 OR ' +
																				'CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) % 511233 = 0 THEN N''SGAM'' ' +
																			'WHEN ' +
																				'CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) = 6 OR ' +
																				'CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) % 511238 = 0 THEN N''DCM'' ' +
																			'WHEN ' +
																				'CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) = 7 OR ' +
																				'CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) % 511239 = 0 THEN N''BCM'' ' +
																			'ELSE N''*'' ' +
																		'END + ' +
																	'N'')'' ' +
																'WHEN wt.wait_type = N''CXPACKET'' THEN ' +
																	'N'':'' + SUBSTRING(wt.resource_description, CHARINDEX(N''nodeId'', wt.resource_description) + 7, 4) ' +
																'WHEN wt.wait_type LIKE N''LATCH[_]%'' THEN ' +
																	'N'' ['' + LEFT(wt.resource_description, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description), 0), LEN(wt.resource_description) + 1) - 1) + N'']'' ' +
																'ELSE N'''' ' +
															'END COLLATE Latin1_General_Bin2 AS wait_type, ' +
														'CASE ' +
															'WHEN ' +
															'( ' +
																'wt.blocking_session_id IS NOT NULL ' +
																'AND wt.wait_type LIKE N''LCK[_]%'' ' +
															') THEN ' +
																'( ' +
																	'SELECT TOP(@i) ' +
																		'x.lock_type, ' +
																		'REPLACE ' +
																		'( ' +
																			'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
																			'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
																			'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
																				'DB_NAME ' +
																				'( ' +
																					'CONVERT ' +
																					'( ' +
																						'INT, ' +
																						'SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''dbid='', wt.resource_description), 0) + 5, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''dbid='', wt.resource_description) + 5), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''dbid='', wt.resource_description) - 5) ' +
																					') ' +
																				'), ' +
																				'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
																				'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
																				'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
																			'NCHAR(0), ' +
																			'N'''' ' +
																		') AS database_name, ' +
																		'CASE x.lock_type ' +
																			'WHEN N''objectlock'' THEN SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''objid='', wt.resource_description), 0) + 6, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''objid='', wt.resource_description) + 6), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''objid='', wt.resource_description) - 6) ' +
																			'ELSE NULL ' +
																		'END AS object_id, ' +
																		'CASE x.lock_type ' +
																			'WHEN N''filelock'' THEN ' +
																				'SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''fileid='', wt.resource_description), 0) + 7, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''fileid='', wt.resource_description) + 7), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''fileid='', wt.resource_description) - 7) ' +
																			'ELSE NULL ' +
																		'END AS file_id, ' +
																		'CASE ' +
																			'WHEN x.lock_type in (N''pagelock'', N''extentlock'', N''ridlock'') THEN ' +
																				'SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''associatedObjectId='', wt.resource_description), 0) + 19, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''associatedObjectId='', wt.resource_description) + 19), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''associatedObjectId='', wt.resource_description) - 19) ' +
																			'WHEN x.lock_type in (N''keylock'', N''hobtlock'', N''allocunitlock'') THEN ' +
																				'SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''hobtid='', wt.resource_description), 0) + 7, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''hobtid='', wt.resource_description) + 7), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''hobtid='', wt.resource_description) - 7) ' +
																			'ELSE NULL ' +
																		'END AS hobt_id, ' +
																		'CASE x.lock_type ' +
																			'WHEN N''applicationlock'' THEN ' +
																				'SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''hash='', wt.resource_description), 0) + 5, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''hash='', wt.resource_description) + 5), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''hash='', wt.resource_description) - 5) ' +
																			'ELSE NULL ' +
																		'END AS applock_hash, ' +
																		'CASE x.lock_type ' +
																			'WHEN N''metadatalock'' THEN ' +
																				'SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''subresource='', wt.resource_description), 0) + 12, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''subresource='', wt.resource_description) + 12), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''subresource='', wt.resource_description) - 12) ' +
																			'ELSE NULL ' +
																		'END AS metadata_resource, ' +
																		'CASE x.lock_type ' +
																			'WHEN N''metadatalock'' THEN ' +
																				'SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''classid='', wt.resource_description), 0) + 8, COALESCE(NULLIF(CHARINDEX(N'' dbid='', wt.resource_description) - CHARINDEX(N''classid='', wt.resource_description), 0), LEN(wt.resource_description) + 1) - 8) ' +
																			'ELSE NULL ' +
																		'END AS metadata_class_id ' +
																	'FROM ' +
																	'( ' +
																		'SELECT TOP(1) ' +
																			'LEFT(wt.resource_description, CHARINDEX(N'' '', wt.resource_description) - 1) COLLATE Latin1_General_Bin2 AS lock_type ' +
																	') AS x ' +
																	'FOR XML ' +
																		'PATH('''') ' +
																') ' +
															'ELSE NULL ' +
														'END AS block_info, ' +
														'wt.wait_duration_ms, ' +
														'wt.waiting_task_address ' +
													'FROM ' +
													'( ' +
														'SELECT TOP(@i) ' +
															'wt0.wait_type COLLATE Latin1_General_Bin2 AS wait_type, ' +
															'wt0.resource_description COLLATE Latin1_General_Bin2 AS resource_description, ' +
															'wt0.wait_duration_ms, ' +
															'wt0.waiting_task_address, ' +
															'CASE ' +
																'WHEN wt0.blocking_session_id = p.blocked THEN wt0.blocking_session_id ' +
																'ELSE NULL ' +
															'END AS blocking_session_id ' +
														'FROM sys.dm_os_waiting_tasks AS wt0 ' +
														'CROSS APPLY ' +
														'( ' +
															'SELECT TOP(1)' +
																's0.blocked ' +
															'FROM @sessions AS s0 ' +
															'WHERE ' +
																's0.session_id = wt0.session_id ' +
																'AND s0.wait_type <> N''OLEDB'' ' +
																'AND wt0.wait_type <> N''OLEDB'' ' +
														') AS p ' +
													') AS wt ' +
												') AS wt1 ' +
												'GROUP BY ' +
													'wt1.wait_type, ' +
													'wt1.waiting_task_address ' +
											') AS wt2 ON ' +
												'wt2.waiting_task_address = task_info.task_address ' +
												'AND wt2.wait_duration_ms > 0 ' +
												'AND task_info.runnable_time IS NULL ' +
											'GROUP BY ' +
												'task_info.session_id, ' +
												'task_info.request_id, ' +
												'task_info.physical_io, ' +
												'task_info.context_switches, ' +
												'task_info.thread_CPU_snapshot, ' +
												'task_info.num_tasks, ' +
												'CASE ' +
													'WHEN task_info.runnable_time IS NOT NULL THEN ' +
														'''RUNNABLE'' ' +
													'ELSE ' +
														'wt2.wait_type ' +
												'END ' +
										') AS w1 ' +
									') AS waits ' +
									'ORDER BY ' +
										'waits.session_id, ' +
										'waits.request_id, ' +
										'waits.r ' +
									'FOR XML ' +
										'PATH(N''tasks''), ' +
										'TYPE ' +
								') AS tasks_raw (task_xml_raw) ' +
							') AS tasks_final ' +
							'CROSS APPLY tasks_final.task_xml.nodes(N''/tasks'') AS task_nodes (task_node) ' +
							'WHERE ' +
								'task_nodes.task_node.exist(N''session_id'') = 1 ' +
						') AS tasks ON ' +
							'tasks.session_id = y.session_id ' +
							'AND tasks.request_id = y.request_id '
					ELSE ''
				END +
				'LEFT OUTER HASH JOIN ' +
				'( ' +
					'SELECT TOP(@i) ' +
						't_info.session_id, ' +
						'COALESCE(t_info.request_id, -1) AS request_id, ' +
						'SUM(t_info.tempdb_allocations) AS tempdb_allocations, ' +
						'SUM(t_info.tempdb_current) AS tempdb_current ' +
					'FROM ' +
					'( ' +
						'SELECT TOP(@i) ' +
							'tsu.session_id, ' +
							'tsu.request_id, ' +
							'tsu.user_objects_alloc_page_count + ' +
								'tsu.internal_objects_alloc_page_count AS tempdb_allocations,' +
							'tsu.user_objects_alloc_page_count + ' +
								'tsu.internal_objects_alloc_page_count - ' +
								'tsu.user_objects_dealloc_page_count - ' +
								'tsu.internal_objects_dealloc_page_count AS tempdb_current ' +
						'FROM sys.dm_db_task_space_usage AS tsu ' +
						'CROSS APPLY ' +
						'( ' +
							'SELECT TOP(1) ' +
								's0.session_id ' +
							'FROM @sessions AS s0 ' +
							'WHERE ' +
								's0.session_id = tsu.session_id ' +
						') AS p ' +
						'' +
						'UNION ALL ' +
						'' +
						'SELECT TOP(@i) ' +
							'ssu.session_id, ' +
							'NULL AS request_id, ' +
							'ssu.user_objects_alloc_page_count + ' +
								'ssu.internal_objects_alloc_page_count AS tempdb_allocations, ' +
							'ssu.user_objects_alloc_page_count + ' +
								'ssu.internal_objects_alloc_page_count - ' +
								'ssu.user_objects_dealloc_page_count - ' +
								'ssu.internal_objects_dealloc_page_count AS tempdb_current ' +
						'FROM sys.dm_db_session_space_usage AS ssu ' +
						'CROSS APPLY ' +
						'( ' +
							'SELECT TOP(1) ' +
								's0.session_id ' +
							'FROM @sessions AS s0 ' +
							'WHERE ' +
								's0.session_id = ssu.session_id ' +
						') AS p ' +
					') AS t_info ' +
					'GROUP BY ' +
						't_info.session_id, ' +
						'COALESCE(t_info.request_id, -1) ' +
				') AS tempdb_info ON ' +
					'tempdb_info.session_id = y.session_id ' +
					'AND tempdb_info.request_id = ' +
						'CASE ' +
							'WHEN y.status = N''sleeping'' THEN ' +
								'-1 ' +
							'ELSE ' +
								'y.request_id ' +
						'END ' +
				CASE 
					WHEN 
						NOT 
						(
							@get_avg_time = 1 
							AND @recursion = 1
						) THEN 
							''
					ELSE
						'LEFT OUTER HASH JOIN ' +
						'( ' +
							'SELECT TOP(@i) ' +
								'* ' +
							'FROM sys.dm_exec_query_stats ' +
						') AS qs ON ' +
							'qs.sql_handle = y.sql_handle ' + 
							'AND qs.plan_handle = y.plan_handle ' + 
							'AND qs.statement_start_offset = y.statement_start_offset ' +
							'AND qs.statement_end_offset = y.statement_end_offset '
					END + 
			') AS x ' +
			'OPTION (KEEPFIXED PLAN, OPTIMIZE FOR (@i = 1)); ';

		SET @sql_n = CONVERT(NVARCHAR(MAX), @sql);

		SET @last_collection_start = GETDATE();
		
		IF @recursion = -1
		BEGIN;
			SELECT
				@first_collection_ms_ticks = ms_ticks
			FROM sys.dm_os_sys_info;
		END;

		INSERT #sessions
		(
			recursion,
			session_id,
			request_id,
			session_number,
			elapsed_time,
			avg_elapsed_time,
			physical_io,
			reads,
			physical_reads,
			writes,
			tempdb_allocations,
			tempdb_current,
			CPU,
			thread_CPU_snapshot,
			context_switches,
			used_memory,
			tasks,
			status,
			wait_info,
			transaction_id,
			open_tran_count,
			sql_handle,
			statement_start_offset,
			statement_end_offset,		
			sql_text,
			plan_handle,
			blocking_session_id,
			percent_complete,
			host_name,
			login_name,
			database_name,
			program_name,
			additional_info,
			start_time,
			login_time,
			last_request_start_time
		)
		EXEC sp_executesql 
			@sql_n,
			N'@recursion SMALLINT, @filter sysname, @not_filter sysname, @first_collection_ms_ticks BIGINT',
			@recursion, @filter, @not_filter, @first_collection_ms_ticks;

		--Collect transaction information?
		IF
			@recursion = 1
			AND
			(
				@output_column_list LIKE '%|[tran_start_time|]%' ESCAPE '|'
				OR @output_column_list LIKE '%|[tran_log_writes|]%' ESCAPE '|' 
			)
		BEGIN;	
			DECLARE @i INT;
			SET @i = 2147483647;

			UPDATE s
			SET
				tran_start_time =
					CONVERT
					(
						DATETIME,
						LEFT
						(
							x.trans_info,
							NULLIF(CHARINDEX(NCHAR(254), x.trans_info) - 1, -1)
						),
						121
					),
				tran_log_writes =
					RIGHT
					(
						x.trans_info,
						LEN(x.trans_info) - CHARINDEX(NCHAR(254), x.trans_info)
					)
			FROM
			(
				SELECT TOP(@i)
					trans_nodes.trans_node.value('(session_id/text())[1]', 'SMALLINT') AS session_id,
					COALESCE(trans_nodes.trans_node.value('(request_id/text())[1]', 'INT'), 0) AS request_id,
					trans_nodes.trans_node.value('(trans_info/text())[1]', 'NVARCHAR(4000)') AS trans_info				
				FROM
				(
					SELECT TOP(@i)
						CONVERT
						(
							XML,
							REPLACE
							(
								CONVERT(NVARCHAR(MAX), trans_raw.trans_xml_raw) COLLATE Latin1_General_Bin2, 
								N'</trans_info></trans><trans><trans_info>', N''
							)
						)
					FROM
					(
						SELECT TOP(@i)
							CASE u_trans.r
								WHEN 1 THEN u_trans.session_id
								ELSE NULL
							END AS [session_id],
							CASE u_trans.r
								WHEN 1 THEN u_trans.request_id
								ELSE NULL
							END AS [request_id],
							CONVERT
							(
								NVARCHAR(MAX),
								CASE
									WHEN u_trans.database_id IS NOT NULL THEN
										CASE u_trans.r
											WHEN 1 THEN COALESCE(CONVERT(NVARCHAR, u_trans.transaction_start_time, 121) + NCHAR(254), N'')
											ELSE N''
										END + 
											REPLACE
											(
												REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
												REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
												REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
													CONVERT(VARCHAR(128), COALESCE(DB_NAME(u_trans.database_id), N'(null)')),
													NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
													NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
													NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
												NCHAR(0),
												N'?'
											) +
											N': ' +
										CONVERT(NVARCHAR, u_trans.log_record_count) + N' (' + CONVERT(NVARCHAR, u_trans.log_kb_used) + N' kB)' +
										N','
									ELSE
										N'N/A,'
								END COLLATE Latin1_General_Bin2
							) AS [trans_info]
						FROM
						(
							SELECT TOP(@i)
								trans.*,
								ROW_NUMBER() OVER
								(
									PARTITION BY
										trans.session_id,
										trans.request_id
									ORDER BY
										trans.transaction_start_time DESC
								) AS r
							FROM
							(
								SELECT TOP(@i)
									session_tran_map.session_id,
									session_tran_map.request_id,
									s_tran.database_id,
									COALESCE(SUM(s_tran.database_transaction_log_record_count), 0) AS log_record_count,
									COALESCE(SUM(s_tran.database_transaction_log_bytes_used), 0) / 1024 AS log_kb_used,
									MIN(s_tran.database_transaction_begin_time) AS transaction_start_time
								FROM
								(
									SELECT TOP(@i)
										*
									FROM sys.dm_tran_active_transactions
									WHERE
										transaction_begin_time <= @last_collection_start
								) AS a_tran
								INNER HASH JOIN
								(
									SELECT TOP(@i)
										*
									FROM sys.dm_tran_database_transactions
									WHERE
										database_id < 32767
								) AS s_tran ON
									s_tran.transaction_id = a_tran.transaction_id
								LEFT OUTER HASH JOIN
								(
									SELECT TOP(@i)
										*
									FROM sys.dm_tran_session_transactions
								) AS tst ON
									s_tran.transaction_id = tst.transaction_id
								CROSS APPLY
								(
									SELECT TOP(1)
										s3.session_id,
										s3.request_id
									FROM
									(
										SELECT TOP(1)
											s1.session_id,
											s1.request_id
										FROM #sessions AS s1
										WHERE
											s1.transaction_id = s_tran.transaction_id
											AND s1.recursion = 1
											
										UNION ALL
									
										SELECT TOP(1)
											s2.session_id,
											s2.request_id
										FROM #sessions AS s2
										WHERE
											s2.session_id = tst.session_id
											AND s2.recursion = 1
									) AS s3
									ORDER BY
										s3.request_id
								) AS session_tran_map
								GROUP BY
									session_tran_map.session_id,
									session_tran_map.request_id,
									s_tran.database_id
							) AS trans
						) AS u_trans
						FOR XML
							PATH('trans'),
							TYPE
					) AS trans_raw (trans_xml_raw)
				) AS trans_final (trans_xml)
				CROSS APPLY trans_final.trans_xml.nodes('/trans') AS trans_nodes (trans_node)
			) AS x
			INNER HASH JOIN #sessions AS s ON
				s.session_id = x.session_id
				AND s.request_id = x.request_id
			OPTION (OPTIMIZE FOR (@i = 1));
		END;

		--Variables for text and plan collection
		DECLARE	
			@session_id SMALLINT,
			@request_id INT,
			@sql_handle VARBINARY(64),
			@plan_handle VARBINARY(64),
			@statement_start_offset INT,
			@statement_end_offset INT,
			@start_time DATETIME,
			@database_name sysname;

		IF 
			@recursion = 1
			AND @output_column_list LIKE '%|[sql_text|]%' ESCAPE '|'
		BEGIN;
			DECLARE sql_cursor
			CURSOR LOCAL FAST_FORWARD
			FOR 
				SELECT 
					session_id,
					request_id,
					sql_handle,
					statement_start_offset,
					statement_end_offset
				FROM #sessions
				WHERE
					recursion = 1
					AND sql_handle IS NOT NULL
			OPTION (KEEPFIXED PLAN);

			OPEN sql_cursor;

			FETCH NEXT FROM sql_cursor
			INTO 
				@session_id,
				@request_id,
				@sql_handle,
				@statement_start_offset,
				@statement_end_offset;

			--Wait up to 5 ms for the SQL text, then give up
			SET LOCK_TIMEOUT 5;

			WHILE @@FETCH_STATUS = 0
			BEGIN;
				BEGIN TRY;
					UPDATE s
					SET
						s.sql_text =
						(
							SELECT
								REPLACE
								(
									REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
									REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
									REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
										N'--' + NCHAR(13) + NCHAR(10) +
										CASE 
											WHEN @get_full_inner_text = 1 THEN est.text
											WHEN LEN(est.text) < (@statement_end_offset / 2) + 1 THEN est.text
											WHEN SUBSTRING(est.text, (@statement_start_offset/2), 2) LIKE N'[a-zA-Z0-9][a-zA-Z0-9]' THEN est.text
											ELSE
												CASE
													WHEN @statement_start_offset > 0 THEN
														SUBSTRING
														(
															est.text,
															((@statement_start_offset/2) + 1),
															(
																CASE
																	WHEN @statement_end_offset = -1 THEN 2147483647
																	ELSE ((@statement_end_offset - @statement_start_offset)/2) + 1
																END
															)
														)
													ELSE RTRIM(LTRIM(est.text))
												END
										END +
										NCHAR(13) + NCHAR(10) + N'--' COLLATE Latin1_General_Bin2,
										NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
										NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
										NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
									NCHAR(0),
									N''
								) AS [processing-instruction(query)]
							FOR XML
								PATH(''),
								TYPE
						),
						s.statement_start_offset = 
							CASE 
								WHEN LEN(est.text) < (@statement_end_offset / 2) + 1 THEN 0
								WHEN SUBSTRING(CONVERT(VARCHAR(MAX), est.text), (@statement_start_offset/2), 2) LIKE '[a-zA-Z0-9][a-zA-Z0-9]' THEN 0
								ELSE @statement_start_offset
							END,
						s.statement_end_offset = 
							CASE 
								WHEN LEN(est.text) < (@statement_end_offset / 2) + 1 THEN -1
								WHEN SUBSTRING(CONVERT(VARCHAR(MAX), est.text), (@statement_start_offset/2), 2) LIKE '[a-zA-Z0-9][a-zA-Z0-9]' THEN -1
								ELSE @statement_end_offset
							END
					FROM 
						#sessions AS s,
						(
							SELECT TOP(1)
								text
							FROM
							(
								SELECT 
									text, 
									0 AS row_num
								FROM sys.dm_exec_sql_text(@sql_handle)
								
								UNION ALL
								
								SELECT 
									NULL,
									1 AS row_num
							) AS est0
							ORDER BY
								row_num
						) AS est
					WHERE 
						s.session_id = @session_id
						AND s.request_id = @request_id
						AND s.recursion = 1
					OPTION (KEEPFIXED PLAN);
				END TRY
				BEGIN CATCH;
					UPDATE s
					SET
						s.sql_text = 
							CASE ERROR_NUMBER() 
								WHEN 1222 THEN '<timeout_exceeded />'
								ELSE '<error message="' + ERROR_MESSAGE() + '" />'
							END
					FROM #sessions AS s
					WHERE 
						s.session_id = @session_id
						AND s.request_id = @request_id
						AND s.recursion = 1
					OPTION (KEEPFIXED PLAN);
				END CATCH;

				FETCH NEXT FROM sql_cursor
				INTO
					@session_id,
					@request_id,
					@sql_handle,
					@statement_start_offset,
					@statement_end_offset;
			END;

			--Return this to the default
			SET LOCK_TIMEOUT -1;

			CLOSE sql_cursor;
			DEALLOCATE sql_cursor;
		END;

		IF 
			@get_outer_command = 1 
			AND @recursion = 1
			AND @output_column_list LIKE '%|[sql_command|]%' ESCAPE '|'
		BEGIN;
			DECLARE @buffer_results TABLE
			(
				EventType VARCHAR(30),
				Parameters INT,
				EventInfo NVARCHAR(4000),
				start_time DATETIME,
				session_number INT IDENTITY(1,1) NOT NULL PRIMARY KEY
			);

			DECLARE buffer_cursor
			CURSOR LOCAL FAST_FORWARD
			FOR 
				SELECT 
					session_id,
					MAX(start_time) AS start_time
				FROM #sessions
				WHERE
					recursion = 1
				GROUP BY
					session_id
				ORDER BY
					session_id
				OPTION (KEEPFIXED PLAN);

			OPEN buffer_cursor;

			FETCH NEXT FROM buffer_cursor
			INTO 
				@session_id,
				@start_time;

			WHILE @@FETCH_STATUS = 0
			BEGIN;
				BEGIN TRY;
					--In SQL Server 2008, DBCC INPUTBUFFER will throw 
					--an exception if the session no longer exists
					INSERT @buffer_results
					(
						EventType,
						Parameters,
						EventInfo
					)
					EXEC sp_executesql
						N'DBCC INPUTBUFFER(@session_id) WITH NO_INFOMSGS;',
						N'@session_id SMALLINT',
						@session_id;

					UPDATE br
					SET
						br.start_time = @start_time
					FROM @buffer_results AS br
					WHERE
						br.session_number = 
						(
							SELECT MAX(br2.session_number)
							FROM @buffer_results br2
						);
				END TRY
				BEGIN CATCH
				END CATCH;

				FETCH NEXT FROM buffer_cursor
				INTO 
					@session_id,
					@start_time;
			END;

			UPDATE s
			SET
				sql_command = 
				(
					SELECT 
						REPLACE
						(
							REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
							REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
							REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								CONVERT
								(
									NVARCHAR(MAX),
									N'--' + NCHAR(13) + NCHAR(10) + br.EventInfo + NCHAR(13) + NCHAR(10) + N'--' COLLATE Latin1_General_Bin2
								),
								NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
								NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
								NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
							NCHAR(0),
							N''
						) AS [processing-instruction(query)]
					FROM @buffer_results AS br
					WHERE 
						br.session_number = s.session_number
						AND br.start_time = s.start_time
						AND 
						(
							(
								s.start_time = s.last_request_start_time
								AND EXISTS
								(
									SELECT *
									FROM sys.dm_exec_requests r2
									WHERE
										r2.session_id = s.session_id
										AND r2.request_id = s.request_id
										AND r2.start_time = s.start_time
								)
							)
							OR 
							(
								s.request_id = 0
								AND EXISTS
								(
									SELECT *
									FROM sys.dm_exec_sessions s2
									WHERE
										s2.session_id = s.session_id
										AND s2.last_request_start_time = s.last_request_start_time
								)
							)
						)
					FOR XML
						PATH(''),
						TYPE
				)
			FROM #sessions AS s
			WHERE
				recursion = 1
			OPTION (KEEPFIXED PLAN);

			CLOSE buffer_cursor;
			DEALLOCATE buffer_cursor;
		END;

		IF 
			@get_plans >= 1 
			AND @recursion = 1
			AND @output_column_list LIKE '%|[query_plan|]%' ESCAPE '|'
		BEGIN;
			DECLARE plan_cursor
			CURSOR LOCAL FAST_FORWARD
			FOR 
				SELECT
					session_id,
					request_id,
					plan_handle,
					statement_start_offset,
					statement_end_offset
				FROM #sessions
				WHERE
					recursion = 1
					AND plan_handle IS NOT NULL
			OPTION (KEEPFIXED PLAN);

			OPEN plan_cursor;

			FETCH NEXT FROM plan_cursor
			INTO 
				@session_id,
				@request_id,
				@plan_handle,
				@statement_start_offset,
				@statement_end_offset;

			--Wait up to 5 ms for a query plan, then give up
			SET LOCK_TIMEOUT 5;

			WHILE @@FETCH_STATUS = 0
			BEGIN;
				BEGIN TRY;
					UPDATE s
					SET
						s.query_plan =
						(
							SELECT
								CONVERT(xml, query_plan)
							FROM sys.dm_exec_text_query_plan
							(
								@plan_handle, 
								CASE @get_plans
									WHEN 1 THEN
										@statement_start_offset
									ELSE
										0
								END, 
								CASE @get_plans
									WHEN 1 THEN
										@statement_end_offset
									ELSE
										-1
								END
							)
						)
					FROM #sessions AS s
					WHERE 
						s.session_id = @session_id
						AND s.request_id = @request_id
						AND s.recursion = 1
					OPTION (KEEPFIXED PLAN);
				END TRY
				BEGIN CATCH;
					IF ERROR_NUMBER() = 6335
					BEGIN;
						UPDATE s
						SET
							s.query_plan =
							(
								SELECT
									N'--' + NCHAR(13) + NCHAR(10) + 
									N'-- Could not render showplan due to XML data type limitations. ' + NCHAR(13) + NCHAR(10) + 
									N'-- To see the graphical plan save the XML below as a .SQLPLAN file and re-open in SSMS.' + NCHAR(13) + NCHAR(10) +
									N'--' + NCHAR(13) + NCHAR(10) +
										REPLACE(qp.query_plan, N'<RelOp', NCHAR(13)+NCHAR(10)+N'<RelOp') + 
										NCHAR(13) + NCHAR(10) + N'--' COLLATE Latin1_General_Bin2 AS [processing-instruction(query_plan)]
								FROM sys.dm_exec_text_query_plan
								(
									@plan_handle, 
									CASE @get_plans
										WHEN 1 THEN
											@statement_start_offset
										ELSE
											0
									END, 
									CASE @get_plans
										WHEN 1 THEN
											@statement_end_offset
										ELSE
											-1
									END
								) AS qp
								FOR XML
									PATH(''),
									TYPE
							)
						FROM #sessions AS s
						WHERE 
							s.session_id = @session_id
							AND s.request_id = @request_id
							AND s.recursion = 1
						OPTION (KEEPFIXED PLAN);
					END;
					ELSE
					BEGIN;
						UPDATE s
						SET
							s.query_plan = 
								CASE ERROR_NUMBER() 
									WHEN 1222 THEN '<timeout_exceeded />'
									ELSE '<error message="' + ERROR_MESSAGE() + '" />'
								END
						FROM #sessions AS s
						WHERE 
							s.session_id = @session_id
							AND s.request_id = @request_id
							AND s.recursion = 1
						OPTION (KEEPFIXED PLAN);
					END;
				END CATCH;

				FETCH NEXT FROM plan_cursor
				INTO
					@session_id,
					@request_id,
					@plan_handle,
					@statement_start_offset,
					@statement_end_offset;
			END;

			--Return this to the default
			SET LOCK_TIMEOUT -1;

			CLOSE plan_cursor;
			DEALLOCATE plan_cursor;
		END;

		IF 
			@get_locks = 1 
			AND @recursion = 1
			AND @output_column_list LIKE '%|[locks|]%' ESCAPE '|'
		BEGIN;
			DECLARE locks_cursor
			CURSOR LOCAL FAST_FORWARD
			FOR 
				SELECT DISTINCT
					database_name
				FROM #locks
				WHERE
					EXISTS
					(
						SELECT *
						FROM #sessions AS s
						WHERE
							s.session_id = #locks.session_id
							AND recursion = 1
					)
					AND database_name <> '(null)'
				OPTION (KEEPFIXED PLAN);

			OPEN locks_cursor;

			FETCH NEXT FROM locks_cursor
			INTO 
				@database_name;

			WHILE @@FETCH_STATUS = 0
			BEGIN;
				BEGIN TRY;
					SET @sql_n = CONVERT(NVARCHAR(MAX), '') +
						'UPDATE l ' +
						'SET ' +
							'object_name = ' +
								'REPLACE ' +
								'( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
										'o.name COLLATE Latin1_General_Bin2, ' +
										'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
										'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
										'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
									'NCHAR(0), ' +
									N''''' ' +
								'), ' +
							'index_name = ' +
								'REPLACE ' +
								'( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
										'i.name COLLATE Latin1_General_Bin2, ' +
										'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
										'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
										'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
									'NCHAR(0), ' +
									N''''' ' +
								'), ' +
							'schema_name = ' +
								'REPLACE ' +
								'( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
										's.name COLLATE Latin1_General_Bin2, ' +
										'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
										'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
										'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
									'NCHAR(0), ' +
									N''''' ' +
								'), ' +
							'principal_name = ' + 
								'REPLACE ' +
								'( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
										'dp.name COLLATE Latin1_General_Bin2, ' +
										'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
										'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
										'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
									'NCHAR(0), ' +
									N''''' ' +
								') ' +
						'FROM #locks AS l ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.allocation_units AS au ON ' +
							'au.allocation_unit_id = l.allocation_unit_id ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.partitions AS p ON ' +
							'p.hobt_id = ' +
								'COALESCE ' +
								'( ' +
									'l.hobt_id, ' +
									'CASE ' +
										'WHEN au.type IN (1, 3) THEN au.container_id ' +
										'ELSE NULL ' +
									'END ' +
								') ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.partitions AS p1 ON ' +
							'l.hobt_id IS NULL ' +
							'AND au.type = 2 ' +
							'AND p1.partition_id = au.container_id ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.objects AS o ON ' +
							'o.object_id = COALESCE(l.object_id, p.object_id, p1.object_id) ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.indexes AS i ON ' +
							'i.object_id = COALESCE(l.object_id, p.object_id, p1.object_id) ' +
							'AND i.index_id = COALESCE(l.index_id, p.index_id, p1.index_id) ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.schemas AS s ON ' +
							's.schema_id = COALESCE(l.schema_id, o.schema_id) ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.database_principals AS dp ON ' +
							'dp.principal_id = l.principal_id ' +
						'WHERE ' +
							'l.database_name = @database_name ' +
						'OPTION (KEEPFIXED PLAN); ';
					
					EXEC sp_executesql
						@sql_n,
						N'@database_name sysname',
						@database_name;
				END TRY
				BEGIN CATCH;
					UPDATE #locks
					SET
						query_error = 
							REPLACE
							(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
									CONVERT
									(
										NVARCHAR(MAX), 
										ERROR_MESSAGE() COLLATE Latin1_General_Bin2
									),
									NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
									NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
									NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
								NCHAR(0),
								N''
							)
					WHERE 
						database_name = @database_name
					OPTION (KEEPFIXED PLAN);
				END CATCH;

				FETCH NEXT FROM locks_cursor
				INTO
					@database_name;
			END;

			CLOSE locks_cursor;
			DEALLOCATE locks_cursor;

			CREATE CLUSTERED INDEX IX_SRD ON #locks (session_id, request_id, database_name);

			UPDATE s
			SET 
				s.locks =
				(
					SELECT 
						REPLACE
						(
							REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
							REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
							REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								CONVERT
								(
									NVARCHAR(MAX), 
									l1.database_name COLLATE Latin1_General_Bin2
								),
								NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
								NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
								NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
							NCHAR(0),
							N''
						) AS [Database/@name],
						MIN(l1.query_error) AS [Database/@query_error],
						(
							SELECT 
								l2.request_mode AS [Lock/@request_mode],
								l2.request_status AS [Lock/@request_status],
								COUNT(*) AS [Lock/@request_count]
							FROM #locks AS l2
							WHERE 
								l1.session_id = l2.session_id
								AND l1.request_id = l2.request_id
								AND l2.database_name = l1.database_name
								AND l2.resource_type = 'DATABASE'
							GROUP BY
								l2.request_mode,
								l2.request_status
							FOR XML
								PATH(''),
								TYPE
						) AS [Database/Locks],
						(
							SELECT
								COALESCE(l3.object_name, '(null)') AS [Object/@name],
								l3.schema_name AS [Object/@schema_name],
								(
									SELECT
										l4.resource_type AS [Lock/@resource_type],
										l4.page_type AS [Lock/@page_type],
										l4.index_name AS [Lock/@index_name],
										CASE 
											WHEN l4.object_name IS NULL THEN l4.schema_name
											ELSE NULL
										END AS [Lock/@schema_name],
										l4.principal_name AS [Lock/@principal_name],
										l4.resource_description AS [Lock/@resource_description],
										l4.request_mode AS [Lock/@request_mode],
										l4.request_status AS [Lock/@request_status],
										SUM(l4.request_count) AS [Lock/@request_count]
									FROM #locks AS l4
									WHERE 
										l4.session_id = l3.session_id
										AND l4.request_id = l3.request_id
										AND l3.database_name = l4.database_name
										AND COALESCE(l3.object_name, '(null)') = COALESCE(l4.object_name, '(null)')
										AND COALESCE(l3.schema_name, '') = COALESCE(l4.schema_name, '')
										AND l4.resource_type <> 'DATABASE'
									GROUP BY
										l4.resource_type,
										l4.page_type,
										l4.index_name,
										CASE 
											WHEN l4.object_name IS NULL THEN l4.schema_name
											ELSE NULL
										END,
										l4.principal_name,
										l4.resource_description,
										l4.request_mode,
										l4.request_status
									FOR XML
										PATH(''),
										TYPE
								) AS [Object/Locks]
							FROM #locks AS l3
							WHERE 
								l3.session_id = l1.session_id
								AND l3.request_id = l1.request_id
								AND l3.database_name = l1.database_name
								AND l3.resource_type <> 'DATABASE'
							GROUP BY 
								l3.session_id,
								l3.request_id,
								l3.database_name,
								COALESCE(l3.object_name, '(null)'),
								l3.schema_name
							FOR XML
								PATH(''),
								TYPE
						) AS [Database/Objects]
					FROM #locks AS l1
					WHERE
						l1.session_id = s.session_id
						AND l1.request_id = s.request_id
						AND l1.start_time IN (s.start_time, s.last_request_start_time)
						AND s.recursion = 1
					GROUP BY 
						l1.session_id,
						l1.request_id,
						l1.database_name
					FOR XML
						PATH(''),
						TYPE
				)
			FROM #sessions s
			OPTION (KEEPFIXED PLAN);
		END;

		IF 
			@find_block_leaders = 1
			AND @recursion = 1
			AND @output_column_list LIKE '%|[blocked_session_count|]%' ESCAPE '|'
		BEGIN;
			WITH
			blockers AS
			(
				SELECT
					session_id,
					session_id AS top_level_session_id
				FROM #sessions
				WHERE
					recursion = 1

				UNION ALL

				SELECT
					s.session_id,
					b.top_level_session_id
				FROM blockers AS b
				JOIN #sessions AS s ON
					s.blocking_session_id = b.session_id
					AND s.recursion = 1
			)
			UPDATE s
			SET
				s.blocked_session_count = x.blocked_session_count
			FROM #sessions AS s
			JOIN
			(
				SELECT
					b.top_level_session_id AS session_id,
					COUNT(*) - 1 AS blocked_session_count
				FROM blockers AS b
				GROUP BY
					b.top_level_session_id
			) x ON
				s.session_id = x.session_id
			WHERE
				s.recursion = 1;
		END;

		IF
			@get_task_info = 2
			AND @output_column_list LIKE '%|[additional_info|]%' ESCAPE '|'
			AND @recursion = 1
		BEGIN;
			CREATE TABLE #blocked_requests
			(
				session_id SMALLINT NOT NULL,
				request_id INT NOT NULL,
				database_name sysname NOT NULL,
				object_id INT,
				hobt_id BIGINT,
				schema_id INT,
				schema_name sysname NULL,
				object_name sysname NULL,
				query_error NVARCHAR(2048),
				PRIMARY KEY (database_name, session_id, request_id)
			);

			CREATE STATISTICS s_database_name ON #blocked_requests (database_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_schema_name ON #blocked_requests (schema_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_object_name ON #blocked_requests (object_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_query_error ON #blocked_requests (query_error)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
		
			INSERT #blocked_requests
			(
				session_id,
				request_id,
				database_name,
				object_id,
				hobt_id,
				schema_id
			)
			SELECT
				session_id,
				request_id,
				database_name,
				object_id,
				hobt_id,
				CONVERT(INT, SUBSTRING(schema_node, CHARINDEX(' = ', schema_node) + 3, LEN(schema_node))) AS schema_id
			FROM
			(
				SELECT
					session_id,
					request_id,
					agent_nodes.agent_node.value('(database_name/text())[1]', 'sysname') AS database_name,
					agent_nodes.agent_node.value('(object_id/text())[1]', 'int') AS object_id,
					agent_nodes.agent_node.value('(hobt_id/text())[1]', 'bigint') AS hobt_id,
					agent_nodes.agent_node.value('(metadata_resource/text()[.="SCHEMA"]/../../metadata_class_id/text())[1]', 'varchar(100)') AS schema_node
				FROM #sessions AS s
				CROSS APPLY s.additional_info.nodes('//block_info') AS agent_nodes (agent_node)
				WHERE
					s.recursion = 1
			) AS t
			WHERE
				t.object_id IS NOT NULL
				OR t.hobt_id IS NOT NULL
				OR t.schema_node IS NOT NULL;
			
			DECLARE blocks_cursor
			CURSOR LOCAL FAST_FORWARD
			FOR
				SELECT DISTINCT
					database_name
				FROM #blocked_requests;
				
			OPEN blocks_cursor;
			
			FETCH NEXT FROM blocks_cursor
			INTO 
				@database_name;
			
			WHILE @@FETCH_STATUS = 0
			BEGIN;
				BEGIN TRY;
					SET @sql_n = 
						CONVERT(NVARCHAR(MAX), '') +
						'UPDATE b ' +
						'SET ' +
							'b.schema_name = ' +
								'REPLACE ' +
								'( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
										's.name COLLATE Latin1_General_Bin2, ' +
										'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
										'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
										'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
									'NCHAR(0), ' +
									N''''' ' +
								'), ' +
							'b.object_name = ' +
								'REPLACE ' +
								'( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
										'o.name COLLATE Latin1_General_Bin2, ' +
										'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
										'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
										'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
									'NCHAR(0), ' +
									N''''' ' +
								') ' +
						'FROM #blocked_requests AS b ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.partitions AS p ON ' +
							'p.hobt_id = b.hobt_id ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.objects AS o ON ' +
							'o.object_id = COALESCE(p.object_id, b.object_id) ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.schemas AS s ON ' +
							's.schema_id = COALESCE(o.schema_id, b.schema_id) ' +
						'WHERE ' +
							'b.database_name = @database_name; ';
					
					EXEC sp_executesql
						@sql_n,
						N'@database_name sysname',
						@database_name;
				END TRY
				BEGIN CATCH;
					UPDATE #blocked_requests
					SET
						query_error = 
							REPLACE
							(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
									CONVERT
									(
										NVARCHAR(MAX), 
										ERROR_MESSAGE() COLLATE Latin1_General_Bin2
									),
									NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
									NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
									NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
								NCHAR(0),
								N''
							)
					WHERE
						database_name = @database_name;
				END CATCH;

				FETCH NEXT FROM blocks_cursor
				INTO
					@database_name;
			END;
			
			CLOSE blocks_cursor;
			DEALLOCATE blocks_cursor;
			
			UPDATE s
			SET
				additional_info.modify
				('
					insert <schema_name>{sql:column("b.schema_name")}</schema_name>
					as last
					into (/additional_info/block_info)[1]
				')
			FROM #sessions AS s
			INNER JOIN #blocked_requests AS b ON
				b.session_id = s.session_id
				AND b.request_id = s.request_id
				AND s.recursion = 1
			WHERE
				b.schema_name IS NOT NULL;

			UPDATE s
			SET
				additional_info.modify
				('
					insert <object_name>{sql:column("b.object_name")}</object_name>
					as last
					into (/additional_info/block_info)[1]
				')
			FROM #sessions AS s
			INNER JOIN #blocked_requests AS b ON
				b.session_id = s.session_id
				AND b.request_id = s.request_id
				AND s.recursion = 1
			WHERE
				b.object_name IS NOT NULL;

			UPDATE s
			SET
				additional_info.modify
				('
					insert <query_error>{sql:column("b.query_error")}</query_error>
					as last
					into (/additional_info/block_info)[1]
				')
			FROM #sessions AS s
			INNER JOIN #blocked_requests AS b ON
				b.session_id = s.session_id
				AND b.request_id = s.request_id
				AND s.recursion = 1
			WHERE
				b.query_error IS NOT NULL;
		END;

		IF
			@output_column_list LIKE '%|[program_name|]%' ESCAPE '|'
			AND @output_column_list LIKE '%|[additional_info|]%' ESCAPE '|'
			AND @recursion = 1
		BEGIN;
			DECLARE @job_id UNIQUEIDENTIFIER;
			DECLARE @step_id INT;

			DECLARE agent_cursor
			CURSOR LOCAL FAST_FORWARD
			FOR 
				SELECT
					s.session_id,
					agent_nodes.agent_node.value('(job_id/text())[1]', 'uniqueidentifier') AS job_id,
					agent_nodes.agent_node.value('(step_id/text())[1]', 'int') AS step_id
				FROM #sessions AS s
				CROSS APPLY s.additional_info.nodes('//agent_job_info') AS agent_nodes (agent_node)
				WHERE
					s.recursion = 1
			OPTION (KEEPFIXED PLAN);
			
			OPEN agent_cursor;

			FETCH NEXT FROM agent_cursor
			INTO 
				@session_id,
				@job_id,
				@step_id;

			WHILE @@FETCH_STATUS = 0
			BEGIN;
				BEGIN TRY;
					DECLARE @job_name sysname;
					SET @job_name = NULL;
					DECLARE @step_name sysname;
					SET @step_name = NULL;
					
					SELECT
						@job_name = 
							REPLACE
							(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
									j.name,
									NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
									NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
									NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
								NCHAR(0),
								N'?'
							),
						@step_name = 
							REPLACE
							(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
									s.step_name,
									NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
									NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
									NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
								NCHAR(0),
								N'?'
							)
					FROM msdb.dbo.sysjobs AS j
					INNER JOIN msdb..sysjobsteps AS s ON
						j.job_id = s.job_id
					WHERE
						j.job_id = @job_id
						AND s.step_id = @step_id;

					IF @job_name IS NOT NULL
					BEGIN;
						UPDATE s
						SET
							additional_info.modify
							('
								insert text{sql:variable("@job_name")}
								into (/additional_info/agent_job_info/job_name)[1]
							')
						FROM #sessions AS s
						WHERE 
							s.session_id = @session_id
						OPTION (KEEPFIXED PLAN);
						
						UPDATE s
						SET
							additional_info.modify
							('
								insert text{sql:variable("@step_name")}
								into (/additional_info/agent_job_info/step_name)[1]
							')
						FROM #sessions AS s
						WHERE 
							s.session_id = @session_id
						OPTION (KEEPFIXED PLAN);
					END;
				END TRY
				BEGIN CATCH;
					DECLARE @msdb_error_message NVARCHAR(256);
					SET @msdb_error_message = ERROR_MESSAGE();
				
					UPDATE s
					SET
						additional_info.modify
						('
							insert <msdb_query_error>{sql:variable("@msdb_error_message")}</msdb_query_error>
							as last
							into (/additional_info/agent_job_info)[1]
						')
					FROM #sessions AS s
					WHERE 
						s.session_id = @session_id
						AND s.recursion = 1
					OPTION (KEEPFIXED PLAN);
				END CATCH;

				FETCH NEXT FROM agent_cursor
				INTO 
					@session_id,
					@job_id,
					@step_id;
			END;

			CLOSE agent_cursor;
			DEALLOCATE agent_cursor;
		END; 
		
		IF 
			@delta_interval > 0 
			AND @recursion <> 1
		BEGIN;
			SET @recursion = 1;

			DECLARE @delay_time CHAR(12);
			SET @delay_time = CONVERT(VARCHAR, DATEADD(second, @delta_interval, 0), 114);
			WAITFOR DELAY @delay_time;

			GOTO REDO;
		END;
	END;

	SET @sql = 
		--Outer column list
		CONVERT
		(
			VARCHAR(MAX),
			CASE
				WHEN 
					@destination_table <> '' 
					AND @return_schema = 0 
						THEN 'INSERT ' + @destination_table + ' '
				ELSE ''
			END +
			'SELECT ' +
				@output_column_list + ' ' +
			CASE @return_schema
				WHEN 1 THEN 'INTO #session_schema '
				ELSE ''
			END
		--End outer column list
		) + 
		--Inner column list
		CONVERT
		(
			VARCHAR(MAX),
			'FROM ' +
			'( ' +
				'SELECT ' +
					'session_id, ' +
					--[dd hh:mm:ss.mss]
					CASE @format_output
						WHEN 1 THEN
							'CASE ' +
								'WHEN elapsed_time < 0 THEN ' +
									'RIGHT ' +
									'( ' +
										'REPLICATE(''0'', max_elapsed_length) + CONVERT(VARCHAR, (-1 * elapsed_time) / 86400), ' +
										'max_elapsed_length ' +
									') + ' +
										'RIGHT ' +
										'( ' +
											'CONVERT(VARCHAR, DATEADD(second, (-1 * elapsed_time), 0), 120), ' +
											'9 ' +
										') + ' +
										'''.000'' ' +
								'ELSE ' +
									'RIGHT ' +
									'( ' +
										'REPLICATE(''0'', max_elapsed_length) + CONVERT(VARCHAR, elapsed_time / 86400000), ' +
										'max_elapsed_length ' +
									') + ' +
										'RIGHT ' +
										'( ' +
											'CONVERT(VARCHAR, DATEADD(second, elapsed_time / 1000, 0), 120), ' +
											'9 ' +
										') + ' +
										'''.'' + ' + 
										'RIGHT(''000'' + CONVERT(VARCHAR, elapsed_time % 1000), 3) ' +
							'END AS [dd hh:mm:ss.mss], '
						ELSE
							''
					END +
					--[dd hh:mm:ss.mss (avg)] / avg_elapsed_time
					CASE @format_output
						WHEN 1 THEN 
							'RIGHT ' +
							'( ' +
								'''00'' + CONVERT(VARCHAR, avg_elapsed_time / 86400000), ' +
								'2 ' +
							') + ' +
								'RIGHT ' +
								'( ' +
									'CONVERT(VARCHAR, DATEADD(second, avg_elapsed_time / 1000, 0), 120), ' +
									'9 ' +
								') + ' +
								'''.'' + ' +
								'RIGHT(''000'' + CONVERT(VARCHAR, avg_elapsed_time % 1000), 3) AS [dd hh:mm:ss.mss (avg)], '
						ELSE
							'avg_elapsed_time, '
					END +
					--physical_io
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, physical_io))) OVER() - LEN(CONVERT(VARCHAR, physical_io))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_io), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_io), 1), 19)) AS '
						ELSE ''
					END + 'physical_io, ' +
					--reads
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, reads))) OVER() - LEN(CONVERT(VARCHAR, reads))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, reads), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, reads), 1), 19)) AS '
						ELSE ''
					END + 'reads, ' +
					--physical_reads
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, physical_reads))) OVER() - LEN(CONVERT(VARCHAR, physical_reads))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_reads), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_reads), 1), 19)) AS '
						ELSE ''
					END + 'physical_reads, ' +
					--writes
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, writes))) OVER() - LEN(CONVERT(VARCHAR, writes))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, writes), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, writes), 1), 19)) AS '
						ELSE ''
					END + 'writes, ' +
					--tempdb_allocations
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, tempdb_allocations))) OVER() - LEN(CONVERT(VARCHAR, tempdb_allocations))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_allocations), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_allocations), 1), 19)) AS '
						ELSE ''
					END + 'tempdb_allocations, ' +
					--tempdb_current
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, tempdb_current))) OVER() - LEN(CONVERT(VARCHAR, tempdb_current))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_current), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_current), 1), 19)) AS '
						ELSE ''
					END + 'tempdb_current, ' +
					--CPU
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, CPU))) OVER() - LEN(CONVERT(VARCHAR, CPU))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, CPU), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, CPU), 1), 19)) AS '
						ELSE ''
					END + 'CPU, ' +
					--context_switches
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, context_switches))) OVER() - LEN(CONVERT(VARCHAR, context_switches))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, context_switches), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, context_switches), 1), 19)) AS '
						ELSE ''
					END + 'context_switches, ' +
					--used_memory
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, used_memory))) OVER() - LEN(CONVERT(VARCHAR, used_memory))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, used_memory), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, used_memory), 1), 19)) AS '
						ELSE ''
					END + 'used_memory, ' +
					--physical_io_delta			
					'CASE ' +
						'WHEN ' +
							'first_request_start_time = last_request_start_time ' + 
							'AND num_events = 2 ' +
							'AND physical_io_delta >= 0 ' +
								'THEN ' +
								CASE @format_output
									WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, physical_io_delta))) OVER() - LEN(CONVERT(VARCHAR, physical_io_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_io_delta), 1), 19)) ' 
									WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_io_delta), 1), 19)) '
									ELSE 'physical_io_delta '
								END +
						'ELSE NULL ' +
					'END AS physical_io_delta, ' +
					--reads_delta
					'CASE ' +
						'WHEN ' +
							'first_request_start_time = last_request_start_time ' + 
							'AND num_events = 2 ' +
							'AND reads_delta >= 0 ' +
								'THEN ' +
								CASE @format_output
									WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, reads_delta))) OVER() - LEN(CONVERT(VARCHAR, reads_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, reads_delta), 1), 19)) '
									WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, reads_delta), 1), 19)) '
									ELSE 'reads_delta '
								END +
						'ELSE NULL ' +
					'END AS reads_delta, ' +
					--physical_reads_delta
					'CASE ' +
						'WHEN ' +
							'first_request_start_time = last_request_start_time ' + 
							'AND num_events = 2 ' +
							'AND physical_reads_delta >= 0 ' +
								'THEN ' +
								CASE @format_output
									WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, physical_reads_delta))) OVER() - LEN(CONVERT(VARCHAR, physical_reads_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_reads_delta), 1), 19)) '
									WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_reads_delta), 1), 19)) '
									ELSE 'physical_reads_delta '
								END + 
						'ELSE NULL ' +
					'END AS physical_reads_delta, ' +
					--writes_delta
					'CASE ' +
						'WHEN ' +
							'first_request_start_time = last_request_start_time ' + 
							'AND num_events = 2 ' +
							'AND writes_delta >= 0 ' +
								'THEN ' +
								CASE @format_output
									WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, writes_delta))) OVER() - LEN(CONVERT(VARCHAR, writes_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, writes_delta), 1), 19)) '
									WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, writes_delta), 1), 19)) '
									ELSE 'writes_delta '
								END + 
						'ELSE NULL ' +
					'END AS writes_delta, ' +
					--tempdb_allocations_delta
					'CASE ' +
						'WHEN ' +
							'first_request_start_time = last_request_start_time ' + 
							'AND num_events = 2 ' +
							'AND tempdb_allocations_delta >= 0 ' +
								'THEN ' +
								CASE @format_output
									WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, tempdb_allocations_delta))) OVER() - LEN(CONVERT(VARCHAR, tempdb_allocations_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_allocations_delta), 1), 19)) '
									WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_allocations_delta), 1), 19)) '
									ELSE 'tempdb_allocations_delta '
								END + 
						'ELSE NULL ' +
					'END AS tempdb_allocations_delta, ' +
					--tempdb_current_delta
					--this is the only one that can (legitimately) go negative 
					'CASE ' +
						'WHEN ' +
							'first_request_start_time = last_request_start_time ' + 
							'AND num_events = 2 ' +
								'THEN ' +
								CASE @format_output
									WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, tempdb_current_delta))) OVER() - LEN(CONVERT(VARCHAR, tempdb_current_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_current_delta), 1), 19)) '
									WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_current_delta), 1), 19)) '
									ELSE 'tempdb_current_delta '
								END + 
						'ELSE NULL ' +
					'END AS tempdb_current_delta, ' +
					--CPU_delta
					'CASE ' +
						'WHEN ' +
							'first_request_start_time = last_request_start_time ' + 
							'AND num_events = 2 ' +
								'THEN ' +
									'CASE ' +
										'WHEN ' +
											'thread_CPU_delta > CPU_delta ' +
											'AND thread_CPU_delta > 0 ' +
												'THEN ' +
													CASE @format_output
														WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, thread_CPU_delta + CPU_delta))) OVER() - LEN(CONVERT(VARCHAR, thread_CPU_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, thread_CPU_delta), 1), 19)) '
														WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, thread_CPU_delta), 1), 19)) '
														ELSE 'thread_CPU_delta '
													END + 
										'WHEN CPU_delta >= 0 THEN ' +
											CASE @format_output
												WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, thread_CPU_delta + CPU_delta))) OVER() - LEN(CONVERT(VARCHAR, CPU_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, CPU_delta), 1), 19)) '
												WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, CPU_delta), 1), 19)) '
												ELSE 'CPU_delta '
											END + 
										'ELSE NULL ' +
									'END ' +
						'ELSE ' +
							'NULL ' +
					'END AS CPU_delta, ' +
					--context_switches_delta
					'CASE ' +
						'WHEN ' +
							'first_request_start_time = last_request_start_time ' + 
							'AND num_events = 2 ' +
							'AND context_switches_delta >= 0 ' +
								'THEN ' +
								CASE @format_output
									WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, context_switches_delta))) OVER() - LEN(CONVERT(VARCHAR, context_switches_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, context_switches_delta), 1), 19)) '
									WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, context_switches_delta), 1), 19)) '
									ELSE 'context_switches_delta '
								END + 
						'ELSE NULL ' +
					'END AS context_switches_delta, ' +
					--used_memory_delta
					'CASE ' +
						'WHEN ' +
							'first_request_start_time = last_request_start_time ' + 
							'AND num_events = 2 ' +
							'AND used_memory_delta >= 0 ' +
								'THEN ' +
								CASE @format_output
									WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, used_memory_delta))) OVER() - LEN(CONVERT(VARCHAR, used_memory_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, used_memory_delta), 1), 19)) '
									WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, used_memory_delta), 1), 19)) '
									ELSE 'used_memory_delta '
								END + 
						'ELSE NULL ' +
					'END AS used_memory_delta, ' +
					--tasks
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, tasks))) OVER() - LEN(CONVERT(VARCHAR, tasks))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tasks), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tasks), 1), 19)) '
						ELSE ''
					END + 'tasks, ' +
					'status, ' +
					'wait_info, ' +
					'locks, ' +
					'tran_start_time, ' +
					'LEFT(tran_log_writes, LEN(tran_log_writes) - 1) AS tran_log_writes, ' +
					--open_tran_count
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, open_tran_count))) OVER() - LEN(CONVERT(VARCHAR, open_tran_count))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, open_tran_count), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, open_tran_count), 1), 19)) AS '
						ELSE ''
					END + 'open_tran_count, ' +
					--sql_command
					CASE @format_output 
						WHEN 0 THEN 'REPLACE(REPLACE(CONVERT(NVARCHAR(MAX), sql_command), ''<?query --''+CHAR(13)+CHAR(10), ''''), CHAR(13)+CHAR(10)+''--?>'', '''') AS '
						ELSE ''
					END + 'sql_command, ' +
					--sql_text
					CASE @format_output 
						WHEN 0 THEN 'REPLACE(REPLACE(CONVERT(NVARCHAR(MAX), sql_text), ''<?query --''+CHAR(13)+CHAR(10), ''''), CHAR(13)+CHAR(10)+''--?>'', '''') AS '
						ELSE ''
					END + 'sql_text, ' +
					'query_plan, ' +
					'blocking_session_id, ' +
					--blocked_session_count
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, blocked_session_count))) OVER() - LEN(CONVERT(VARCHAR, blocked_session_count))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, blocked_session_count), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, blocked_session_count), 1), 19)) AS '
						ELSE ''
					END + 'blocked_session_count, ' +
					--percent_complete
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, CONVERT(MONEY, percent_complete), 2))) OVER() - LEN(CONVERT(VARCHAR, CONVERT(MONEY, percent_complete), 2))) + CONVERT(CHAR(22), CONVERT(MONEY, percent_complete), 2)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, CONVERT(CHAR(22), CONVERT(MONEY, blocked_session_count), 1)) AS '
						ELSE ''
					END + 'percent_complete, ' +
					'host_name, ' +
					'login_name, ' +
					'database_name, ' +
					'program_name, ' +
					'additional_info, ' +
					'start_time, ' +
					'login_time, ' +
					'CASE ' +
						'WHEN status = N''sleeping'' THEN NULL ' +
						'ELSE request_id ' +
					'END AS request_id, ' +
					'GETDATE() AS collection_time '
		--End inner column list
		) +
		--Derived table and INSERT specification
		CONVERT
		(
			VARCHAR(MAX),
				'FROM ' +
				'( ' +
					'SELECT TOP(2147483647) ' +
						'*, ' +
						'CASE ' +
							'MAX ' +
							'( ' +
								'LEN ' +
								'( ' +
									'CONVERT ' +
									'( ' +
										'VARCHAR, ' +
										'CASE ' +
											'WHEN elapsed_time < 0 THEN ' +
												'(-1 * elapsed_time) / 86400 ' +
											'ELSE ' +
												'elapsed_time / 86400000 ' +
										'END ' +
									') ' +
								') ' +
							') OVER () ' +
								'WHEN 1 THEN 2 ' +
								'ELSE ' +
									'MAX ' +
									'( ' +
										'LEN ' +
										'( ' +
											'CONVERT ' +
											'( ' +
												'VARCHAR, ' +
												'CASE ' +
													'WHEN elapsed_time < 0 THEN ' +
														'(-1 * elapsed_time) / 86400 ' +
													'ELSE ' +
														'elapsed_time / 86400000 ' +
												'END ' +
											') ' +
										') ' +
									') OVER () ' +
						'END AS max_elapsed_length, ' +
						'MAX(physical_io * recursion) OVER (PARTITION BY session_id, request_id) + ' +
							'MIN(physical_io * recursion) OVER (PARTITION BY session_id, request_id) AS physical_io_delta, ' +
						'MAX(reads * recursion) OVER (PARTITION BY session_id, request_id) + ' +
							'MIN(reads * recursion) OVER (PARTITION BY session_id, request_id) AS reads_delta, ' +
						'MAX(physical_reads * recursion) OVER (PARTITION BY session_id, request_id) + ' +
							'MIN(physical_reads * recursion) OVER (PARTITION BY session_id, request_id) AS physical_reads_delta, ' +
						'MAX(writes * recursion) OVER (PARTITION BY session_id, request_id) + ' +
							'MIN(writes * recursion) OVER (PARTITION BY session_id, request_id) AS writes_delta, ' +
						'MAX(tempdb_allocations * recursion) OVER (PARTITION BY session_id, request_id) + ' +
							'MIN(tempdb_allocations * recursion) OVER (PARTITION BY session_id, request_id) AS tempdb_allocations_delta, ' +
						'MAX(tempdb_current * recursion) OVER (PARTITION BY session_id, request_id) + ' +
							'MIN(tempdb_current * recursion) OVER (PARTITION BY session_id, request_id) AS tempdb_current_delta, ' +
						'MAX(CPU * recursion) OVER (PARTITION BY session_id, request_id) + ' +
							'MIN(CPU * recursion) OVER (PARTITION BY session_id, request_id) AS CPU_delta, ' +
						'MAX(thread_CPU_snapshot * recursion) OVER (PARTITION BY session_id, request_id) + ' +
							'MIN(thread_CPU_snapshot * recursion) OVER (PARTITION BY session_id, request_id) AS thread_CPU_delta, ' +
						'MAX(context_switches * recursion) OVER (PARTITION BY session_id, request_id) + ' +
							'MIN(context_switches * recursion) OVER (PARTITION BY session_id, request_id) AS context_switches_delta, ' +
						'MAX(used_memory * recursion) OVER (PARTITION BY session_id, request_id) + ' +
							'MIN(used_memory * recursion) OVER (PARTITION BY session_id, request_id) AS used_memory_delta, ' +
						'MIN(last_request_start_time) OVER (PARTITION BY session_id, request_id) AS first_request_start_time, ' +
						'COUNT(*) OVER (PARTITION BY session_id, request_id) AS num_events ' +
					'FROM #sessions AS s1 ' +
					CASE 
						WHEN @sort_order = '' THEN ''
						ELSE
							'ORDER BY ' +
								@sort_order
					END +
				') AS s ' +
				'WHERE ' +
					's.recursion = 1 ' +
			') x ' +
			'OPTION (KEEPFIXED PLAN); ' +
			'' +
			CASE @return_schema
				WHEN 1 THEN
					'SET @schema = ' +
						'''CREATE TABLE <table_name> ( '' + ' +
							'STUFF ' +
							'( ' +
								'( ' +
									'SELECT ' +
										''','' + ' +
										'QUOTENAME(COLUMN_NAME) + '' '' + ' +
										'DATA_TYPE + ' + 
										'CASE ' +
											'WHEN DATA_TYPE LIKE ''%char'' THEN ''('' + COALESCE(NULLIF(CONVERT(VARCHAR, CHARACTER_MAXIMUM_LENGTH), ''-1''), ''max'') + '') '' ' +
											'ELSE '' '' ' +
										'END + ' +
										'CASE IS_NULLABLE ' +
											'WHEN ''NO'' THEN ''NOT '' ' +
											'ELSE '''' ' +
										'END + ''NULL'' AS [text()] ' +
									'FROM tempdb.INFORMATION_SCHEMA.COLUMNS ' +
									'WHERE ' +
										'TABLE_NAME = (SELECT name FROM tempdb.sys.objects WHERE object_id = OBJECT_ID(''tempdb..#session_schema'')) ' +
										'ORDER BY ' +
											'ORDINAL_POSITION ' +
									'FOR XML ' +
										'PATH('''') ' +
								'), + ' +
								'1, ' +
								'1, ' +
								''''' ' +
							') + ' +
						''')''; ' 
				ELSE ''
			END
		--End derived table and INSERT specification
		);

	SET @sql_n = CONVERT(NVARCHAR(MAX), @sql);

	EXEC sp_executesql
		@sql_n,
		N'@schema VARCHAR(MAX) OUTPUT',
		@schema OUTPUT;
END;


GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [dbo].[sp_WhoIsActive_Admin]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Монитор производительности СУБД', 'SCHEMA', N'dbo', 'PROCEDURE', N'sp_WhoIsActive_Admin'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Create procedure [srv].[GetScalling_monitor_db]
--
GO



  --Назначение: Производительность MS SQL.Вывод мониторинга. Масштабируемые данные по времени
  --Автор: Прилепа Б.А. - АБД
  --Создано: 12.01.2017. Изменено 28.05.2019
  --exec srv.GetScalling_monitor_db @t=1						--RAM - HDD (СТАТИСТИКА DESC)

  --exec srv.GetScalling_monitor_db @t=2						--(БД) Размеры баз данных, mdf и ldf файла
  --exec srv.GetScalling_monitor_db @t=22						--(БД) Свободное место в файлах mdf, ldf
  --exec srv.GetScalling_monitor_db @t=3						--(БД) RAM под БД
  --exec srv.GetScalling_monitor_db @t=5						--(БД) Затраты процессорного времени по базам данных (CPUtime)
  --exec srv.GetScalling_monitor_db @t=6,@DATABASE='Trucks',@status_session='running'			--(БД) Сессии на БД (можно и по имени хоста) --status: 'running','sleeping'
  --exec srv.GetScalling_monitor_db @t=7						--(БД) Текущие запросы выполняемые на сервере (sp_Locks)
  --exec srv.GetScalling_monitor_db @t=8			--(БД) Мониторинг блокировок и повисающих запросов, job-ов (sp_Locks 3)
  --exec srv.GetScalling_monitor_db @t=19                       --(БД) Кто активен и потребление ресурсов ([dbo].[sp_WhoIsActive_Admin])
  --exec srv.GetScalling_monitor_db @t=20,@DATABASE='',@tbl='transportmodel1cs'	--(БД) Статистика по запросам
  --exec srv.GetScalling_monitor_db @t=18,@DATABASE='MonopolySunTemp',@type_desc_object='FN',@Unloading=0 ,@TABLE='CustomCheckOrderSave'  --(БД) Статистика по запросам БД (хранимки)
  --exec srv.GetScalling_monitor_db @t=9,@DATABASE='MonopolySun',@DATE1='2019-05-28'			--(БЭКАПЫ PRD-SQL-SRV01-02) Мониторинг бэкапов (запросом)

  --exec srv.GetScalling_monitor_db @t=4,@DATABASE='MonopolySun',@ON_ALL_DATABASE=0,@TABLE='msTruckInOrder_OnOff_ToAgreement'	--(TABLES) Размеры таблиц (+ обращения), данные в них и индексы (Если БД нет, то ничего не выведет)
  --exec srv.GetScalling_monitor_db @t=21,@TABLE='msTruckInOrder_OnOff_ToAgreement',@like=1 --(иногда возвращает пусто или не полный набор, особенности отображения в sys) --ПОИСК ИСПОЛЬЗОВАНИЯ ОБЪЕКТА ПО ВСЕМ БАЗАМ
  --exec srv.GetScalling_monitor_db @t=21,@TABLE='Order',@DATABASE='Trucks',@like=0 --(иногда возвращает пусто или не полный набор, особенности отображения в sys) --ПОИСК ИСПОЛЬЗОВАНИЯ ОБЪЕКТА ПО ВСЕМ БАЗАМ
  --exec srv.GetScalling_monitor_db @t=21,@DATABASE='MonopolySun',@like=0 --использование БД в хранимых объектах
  --exec srv.GetScalling_monitor_db @t=21,@DATABASE='MonopolySun',@job=1 --И джобы рассматриваем
  --exec srv.GetScalling_monitor_db @t=10,@DATABASE='WialonBuffer',@TABLE='booking_histories' 		--(TABLES) Суммарная cтатистика чтений и записей по таблицам
  --exec srv.GetScalling_monitor_db @t=17,@DATABASE='SRV'				--(БД) индексы! Последние чтения из таблиц, по всем таблицам БД
  --exec srv.GetScalling_monitor_db @t=17,@DATABASE='MonopolySun',@TABLE='msOrder_ToAgreement'			--(БД) индексы! Последние чтения из таблиц, без указания таблицы выводится по всем таблицам

  --exec srv.GetScalling_monitor_db @t=10						--(БД) Суммарная cтатистика по базам данных чтение/запись (индексы)
  --exec srv.GetScalling_monitor_db @t=16						--(БД) Суммарная cтатистика по базам данных чтение/запись (системные счетчики)

  --exec srv.GetScalling_monitor_db @t=11		--(JOBS) Данные по выполнению заданий на сервере (job-ов) msdb.dbo.GetStatisticJobs
  --exec srv.GetScalling_monitor_db @t=12		--(WAITS) Мониторинг статистики по ожиданиям /*Очистить статистику DBCC SQLPERF ('sys.dm_os_wait_stats', CLEAR);*/

  --exec srv.GetScalling_monitor_db @t=13,@DATABASE='MonopolyDataMigration',@TABLE='Order'		--(INDEXES) Используемость индексов в БД, какие индексы можно убрать
  --exec srv.GetScalling_monitor_db @t=14,@DATABASE='MonopolySunTemp',@TABLE='transfer_Order'		--(INDEXES) Фрагментированность индексов
  --exec srv.GetScalling_monitor_db @t=14,@DATABASE='MonopolySunTemp',@TABLE='Order',@Index_Is_Detailed=1		--(INDEXES) Фрагментированность индексов
  --exec srv.GetScalling_monitor_db @t=15,@DATABASE='Trucks'			--(INDEXES) Перечень всех индексов

  CREATE procedure [srv].[GetScalling_monitor_db] 
   @t					int			  = 0 /* См. выше* режимы просмотра*/
  ,@DATABASE			nvarchar(255) = N''
  ,@DATABASE_Unloading	nvarchar(255) = N''
  ,@DATE1				datetime	  = null
  ,@DATE2				datetime	  = N''
  ,@SERVER				nvarchar(255) = N''
  ,@TABLE				nvarchar(255) = N''
  ,@ON_ALL_DATABASE		int			  = 0
  ,@status_session		nvarchar(50)  = N''
  ,@type_desc_object	nvarchar(50)  = N''
  ,@Unloading			bit			  = 0 --выгрузка
  ,@Index_Is_Detailed	bit			  = 0 --'Detailed данные по уровням индексов', =1 просмотр нижних уровней может привести к высокой нагрузке на диск по чтениям
  ,@job					int			  = 0
  ,@like				int			  = 0 --Поиск в тексте stored objects по шаблону
  as
  begin
  set xact_abort on;
  set nocount on;
  --Общая процедура мониторинга SQL Server

  declare @servername nvarchar(255)=cast(SERVERPROPERTY(N'MachineName') as nvarchar(255));

  if @SERVER=0
  SELECT  @SERVER=@servername 

  /*@t=1 Чтения запись по БД - раз в 2 секунды, RAM - раз в минуту, HDD - раз в полчаса*/
  if @DATE1>@DATE2
  begin
	declare @DATE3 datetime
	set @DATE3=@DATE2
	set @DATE2=@DATE1
	set @DATE1=@DATE3
  end

  if @t=1 --Анализ свободного места на дисках и используемости RAM
  exec srv.Disk_RAM--проверка на текущий момент

  if @t=2 --Размеры баз данных
  SELECT  db,[file_name],[Size(Mb)],[SizeDB(Mb)], [All DBs Size(Mb)]=(case when id=1 then [All DBs Size(Mb)] else null end)
  ,[SizeData(Mb)]=(case when id=1 then [SizeData(Mb)] else null end)
  ,[SizeLog(Mb)]=(case when id=1 then [SizeLog(Mb)] else null end)
  from
  (SELECT  db,[file_name],[Size(Mb)],[SizeDB(Mb)],[All DBs Size(Mb)],sum(case when [type]=1 then [Size(Mb)] else 0 end) over (partition by 1) [SizeLog(Mb)],
  sum(case when [type]=0 then [Size(Mb)] else 0 end) over (partition by 1) [SizeData(Mb)],row_number() over (order by [SizeDB(Mb)] desc) id
  from
  (SELECT  b.name db,c.name [file_name],cast(sum(BytesOnDisk)/1024.0/1024.0 as numeric(12,3)) [Size(Mb)],cast(sum(BytesOnDisk/1024.0/1024.0) over (partition by b.name) as numeric(12,3)) [SizeDB(Mb)],
  cast(sum(BytesOnDisk/1024.0/1024.0) over (partition by 1) as numeric(12,3)) [All DBs Size(Mb)],c.[type]
  from ::fn_virtualfilestats(NULL, NULL) a inner join (SELECT  * from sys.databases where database_id>4) b on(a.DbId=b.database_id)
  inner join  master.sys.master_files c on(a.DbId=c.database_id and  a.FileId=c.[file_id])
  where b.name=@DATABASE or @DATABASE=''
  group by b.name,c.name,BytesOnDisk,c.[type]) a) a
  order by 4 desc

  --Объем RAM выделенного под разные базы данных
  if @t=3
  begin
	if object_id('tempdb..#SUMMA','U') is not null
	drop table #SUMMA

	SELECT  count(*)AS cached_pages_count, count(*)/128  [Size (Mb)]
		,CASE database_id
			WHEN 32767 THEN 'ResourceDb'
			ELSE db_name(database_id)
			END AS Database_name
			into #SUMMA
	FROM sys.dm_os_buffer_descriptors
	GROUP BY db_name(database_id) ,database_id

	SELECT  Database_name,[Size (Mb)],cast(round(([Size (Mb)]/cast(sum([Size (Mb)]) over (partition by 1) as float))*100,2) as numeric(12,2)) [RAM (%)]
	from #SUMMA
	ORDER BY [Size (Mb)] DESC
	if object_id('tempdb..#SUMMA','U') is not null
	drop table #SUMMA
  end

  if @t=4 and DB_ID(@DATABASE) is not null --Размеры таблиц, данные в них и индексы
  begin
  declare @SS varchar(max)
  
  if @ON_ALL_DATABASE=1
  set @SS='USE ['+@DATABASE+']
  declare @id	int,@pages	bigint,@reservedpages  bigint,@usedpages  bigint
	SELECT  @reservedpages = sum(a.total_pages),
		@usedpages = sum(a.used_pages),
		@pages = sum(CASE
					When it.internal_type IN (202,204,207,211,212,213,214,215,216,221,222,236) Then 0
					When a.type <> 1 and p.index_id < 2 Then a.used_pages
					When p.index_id < 2 Then a.data_pages
					Else 0 END)
	from sys.partitions p join sys.allocation_units a on p.partition_id = a.container_id
		left join sys.internal_tables it on p.object_id = it.object_id
SELECT  @reservedpages = @reservedpages + sum(isnull(reserved_page_count,0)),@usedpages = @usedpages + sum(isnull(used_page_count,0))
		FROM sys.dm_db_partition_stats p, sys.internal_tables it
		WHERE p.object_id = it.object_id;
	select [reserved(Mb)] = cast((@reservedpages * 8192) / (1024.0*1024.0) as numeric(12,2)),[data(Mb)] = cast((@pages * 8192) / (1024.0*1024.0) as numeric(12,2)),[index_size(Mb)] = cast(((@usedpages - @pages) * 8192) / (1024.0*1024.0) as numeric(12,2)),[unused(Mb)] = cast(((@reservedpages - @usedpages) * 8192) / (1024.0*1024.0) as numeric(12,2))'

  begin try	
		print @SS
		exec (@SS)	
  end try
  begin catch
		select ERROR_MESSAGE() ERR_MSG
  end catch

  declare @sql varchar(max)=''

  set @sql='
		USE ['+@DATABASE+']
		declare @table table(
		name nvarchar(255),
		[rows] bigint,
		reserved nvarchar(255),
		data nvarchar(255),
		index_size nvarchar(255),
		unused nvarchar(255),id int identity)
		DECLARE @name nvarchar(255)
		DECLARE SysCur CURSOR LOCAL FOR SELECT  ''[''+b.name+''].[''+a.name+'']'' as name 
		FROM sys.objects a inner join sys.schemas b on(a.schema_id=b.schema_id)
		WHERE type=''U'' and (a.name='''+@TABLE+''' or '''+@TABLE+'''='''')
		OPEN SysCur
		FETCH NEXT FROM SysCur INTO @name
		WHILE @@FETCH_STATUS=0 
		BEGIN
			insert into @table(name,[rows],reserved,data,index_size,unused)
			exec sp_spaceused @name 
			update @table
			set name=@name
			where id=(select top 1 id from @table order by id desc)
		FETCH NEXT FROM SysCur INTO @name
		END
		CLOSE SysCur
		DEALLOCATE SysCur
		declare @clean_table table(
		name nvarchar(255),
		[rows] int,
		[reserved(Kb)] int,
		[data(Kb)] int,
		[index_size(Kb)] int,
		[unused(Kb)] int)
		insert into @clean_table([name],[rows],[reserved(Kb)],[data(Kb)],[index_size(Kb)],[unused(Kb)])
		SELECT  cast(name as nvarchar(255)),cast([rows] as bigint),cast(replace(reserved,'' KB'','''') as bigint),cast(replace(data,'' KB'','''') as bigint),
		cast(replace(index_size,'' KB'','''') as bigint),cast(replace(unused,'' KB'','''') as bigint) from @table
		declare @TB table(srv nvarchar(255),DBName nvarchar(255),tbl nvarchar(255),Reads bigint,Writes bigint, [Reads@Writes] bigint,SampleDays numeric(20,5),SampleSecons bigint)
		insert into @TB(srv,DBName,tbl,Reads,Writes,[Reads@Writes],SampleDays,SampleSecons)
			SELECT   cast(SERVERPROPERTY(N''MachineName'') as nvarchar(255)) AS ServerName,
				DB_NAME() AS DBName,
				''[''+s.name+''].[''+ob.name+'']'' AS TableName ,
				SUM(ddius.user_seeks + ddius.user_scans+ddius.user_lookups) AS Reads ,
				SUM(ddius.user_updates) AS Writes,
				SUM(ddius.user_seeks + ddius.user_scans+ddius.user_lookups
					+ ddius.user_updates) AS [Reads&Writes],(SELECT DATEDIFF(s,create_date,GETDATE())/86400.0
				  FROM master.sys.databases WHERE name = ''tempdb'') AS SampleDays,( SELECT DATEDIFF(s, create_date, GETDATE()) AS SecoundsRunnig FROM master.sys.databases WHERE name = ''tempdb'') AS SampleSeconds
		FROM    sys.dm_db_index_usage_stats ddius
				INNER JOIN sys.indexes i ON ddius.object_id=i.object_id AND i.index_id=ddius.index_id
				INNER JOIN sys.objects ob ON(ddius.object_id=ob.object_id) 
				INNER JOIN sys.schemas s ON(ob.schema_id=s.schema_id) 
		WHERE    OBJECTPROPERTY(ddius.object_id,''IsUserTable'') = 1 AND ddius.database_id = DB_ID() AND (''''='''' or OBJECT_NAME(ddius.object_id)='''')
		GROUP BY ''[''+s.name+''].[''+ob.name+'']''		
		SELECT  ca.name tbl, max([rows]) [rows],max([reserved(Kb)]) [reserved(Kb)],max([data(Kb)]) [data(Kb)],max([index_size(Kb)]) [index_size(Kb)]
		,max([unused(Kb)]) [unused(Kb)],max(cast([reserved(Kb)]/1024.0 as numeric(12,3))) as [data(Mb)],max(isnull(Reads,0)) Reads,max(isnull(Writes,0)) Writes
		,max(isnull([Reads@Writes],0)) [Reads@Writes],max(last_user_update) last_user_update,max(last_user_seek) last_user_seek,max(last_user_scan) last_user_scan,max(last_user_lookup) last_user_lookup,
		max(SampleDays) SampleDays,(SELECT  max(create_date) as start_statistic from sys.databases where name=''tempdb'') start_statistic
		from @clean_table ca LEFT OUTER JOIN @TB cb ON(ca.name=cb.tbl) LEFT OUTER JOIN (SELECT ''[''+sc.name+''].[''+b.name+'']'' tbl,last_user_update,last_user_seek,
		last_user_scan,last_user_lookup from sys.dm_db_index_usage_stats a inner join ['+@DATABASE+'].sys.objects b on(a.object_id=b.object_id and db_NAME(a.database_id)='''+@DATABASE+''')
		inner join ['+@DATABASE+'].sys.schemas sc on(b.schema_id=sc.schema_id) left outer join ['+@DATABASE+'].sys.indexes ind on(a.index_id=ind.index_id and a.object_id=ind.object_id)
	    where db_NAME(a.database_id)='''+@DATABASE+''') c ON(ca.name=c.tbl) group by ca.name order by 8,9'
		
		begin try	
				print @sql
				exec (@sql)
		end try
		begin catch
				select ERROR_MESSAGE() ERR_MSG
		end catch
  end
  if @t=5 --Затраты процессорного времени по базам данных
	WITH DB_CPU_Stats
	AS
	(SELECT  DatabaseID, DB_Name(DatabaseID) AS [DatabaseName], SUM(total_worker_time) AS [CPU_Time_Ms]
	FROM sys.dm_exec_query_stats AS qs
	CROSS APPLY (SELECT  CONVERT(int, value) AS [DatabaseID]
				 FROM sys.dm_exec_plan_attributes(qs.plan_handle)
				 WHERE attribute = N'dbid') AS F_DB
	GROUP BY DatabaseID)
	SELECT  ROW_NUMBER() OVER(ORDER BY [CPU_Time_Ms] DESC) AS [row_num],
		  DatabaseName, [CPU_Time_Ms],
		  CAST([CPU_Time_Ms] * 1.0 / SUM([CPU_Time_Ms]) OVER() * 100.0 AS DECIMAL(5, 2)) AS [CPUPercent]
	FROM DB_CPU_Stats
	WHERE DatabaseID not in(1,3,4) -- system databases
	AND DatabaseID <> 32767 -- ResourceDB
	and DatabaseName<>'master'
	ORDER BY row_num OPTION (RECOMPILE);

	if @t=6 --Сессии на БД
	SELECT   distinct a.session_id,[host_name],p.cpu,p.waittime,p.lastwaittype,client_net_address,local_net_address,a.[program_name],
	login_name,a.[status],last_request_start_time,
	last_request_end_time,--[lock_timeout],
	original_login_name,--db_name(database_id) DB,
	cpu_time,total_scheduled_time,total_elapsed_time
	FROM    sys.dm_exec_sessions a left outer join sys.dm_exec_connections b on(a.session_id=b.session_id)
	left outer join sys.sysprocesses p on(a.session_id=p.spid)
	WHERE   database_id > 0
	AND ((DB_NAME(dbid)=@DATABASE or @DATABASE='' or cast(p.spid as nvarchar(5))=@DATABASE) or (ltrim(rtrim([host_name]))=@DATABASE or @DATABASE=''))
	and (@status_session='' or a.[status]=@status_session)
	order by [host_name],a.session_id,p.waittime desc,cpu desc

	if @t=7 --Текущие запросы
	exec srv.Locks 4;

	if @t=8 --Мониторинг блокировок
	exec srv.Locks 3;

	if @t=9 --ИНФА по бэкапам
	begin
		set @DATE1=case when @DATE1='' then NULL else @DATE1 end
		exec srv.Backups_info @DATE=@DATE1,@DATABASE=@DATABASE
	end

	if @t=10 --Статистика чтений и записей по таблицам
	begin
	if @DATABASE<>''
	begin
	declare @sql2 nvarchar(max)=''	

	set @sql2='
	USE ['+@DATABASE+']
	SELECT   cast(SERVERPROPERTY(N''MachineName'') as nvarchar(255)) AS ServerName ,
				DB_NAME() AS DBName ,
				s.name+''.''+ob.name AS TableName ,
				SUM(ddius.user_seeks + ddius.user_scans + ddius.user_lookups)
																	   AS  Reads ,
				SUM(ddius.user_updates) AS Writes ,
				SUM(ddius.user_seeks + ddius.user_scans + ddius.user_lookups
					+ ddius.user_updates) AS [Reads&Writes],
				( SELECT     DATEDIFF(s, create_date, GETDATE()) / 86400.0
				  FROM      master.sys.databases
				  WHERE     name = ''tempdb''
				) AS SampleDays ,
				( SELECT     DATEDIFF(s, create_date, GETDATE()) AS SecoundsRunnig
				  FROM      master.sys.databases
				  WHERE     name = ''tempdb''
				) AS SampleSeconds
		FROM    sys.dm_db_index_usage_stats ddius
				INNER JOIN sys.indexes i ON ddius.object_id = i.object_id
											 AND i.index_id = ddius.index_id
				INNER JOIN sys.objects ob ON(ddius.object_id=ob.object_id) 
				INNER JOIN sys.schemas s ON(ob.schema_id=s.schema_id) 
		WHERE    OBJECTPROPERTY(ddius.object_id, ''IsUserTable'') = 1
				AND ddius.database_id = DB_ID()
				AND ('''+@TABLE+'''='''' or OBJECT_NAME(ddius.object_id)='''+@TABLE+''')
		GROUP BY s.name+''.''+ob.name
		ORDER BY Reads,Writes'
		begin try	
				print @sql2
				exec sp_executesql @sql2	
		end try
		begin catch
				print @sql
				select ERROR_MESSAGE() ERR_MSG
		end catch

	end
	if @DATABASE=''
	begin
		DECLARE @TBL TABLE([server] nvarchar(255),db nvarchar(255),Reads bigint,Writes bigint,[Reads&Writes] bigint,SampleDays numeric(12,3),SampleSeconds int)
		DECLARE @name nvarchar(255)=''
		declare @sql_10 nvarchar(max)=''
		DECLARE SysCur CURSOR LOCAL FOR SELECT  name FROM sys.databases
		OPEN SysCur
		FETCH NEXT FROM SysCur INTO @name
		WHILE @@FETCH_STATUS=0 BEGIN
		set @sql_10='
			USE ['+@name+']
			SELECT   cast(SERVERPROPERTY(N''MachineName'') as nvarchar(255)) AS ServerName ,
					DB_NAME() AS DBName ,
					SUM(ddius.user_seeks + ddius.user_scans + ddius.user_lookups)
																		   AS  Reads ,
					SUM(ddius.user_updates) AS Writes ,
					SUM(ddius.user_seeks + ddius.user_scans + ddius.user_lookups
						+ ddius.user_updates) AS [Reads&Writes] ,
					( SELECT     DATEDIFF(s, create_date, GETDATE()) / 86400.0
					  FROM      master.sys.databases
					  WHERE     name = ''tempdb''
					) AS SampleDays ,
					( SELECT     DATEDIFF(s, create_date, GETDATE()) AS SecoundsRunnig
					  FROM      master.sys.databases
					  WHERE     name = ''tempdb''
					) AS SampleSeconds
			FROM    sys.dm_db_index_usage_stats ddius
					INNER JOIN sys.indexes i ON ddius.object_id = i.object_id
												 AND i.index_id = ddius.index_id
			WHERE    OBJECTPROPERTY(ddius.object_id, ''IsUserTable'') = 1
					AND ddius.database_id = DB_ID()'
		insert into @TBL([server],db,Reads,Writes,[Reads&Writes],SampleDays,SampleSeconds)
		exec sp_executesql @sql_10
		FETCH NEXT FROM SysCur INTO @name
		END
		CLOSE SysCur
		DEALLOCATE SysCur

		--Вывод данных Reads/Writes по индексам
		SELECT  [server],db,Reads,Writes,[Reads&Writes]
		,cast((Reads/cast(sum(Reads) over (partition by 1) as float)*100) as numeric(12,3)) [Reads(%)]
		,cast((Writes/cast(sum(Writes) over (partition by 1) as float)*100) as numeric(12,3)) [Writes(%)]
		,cast(([Reads&Writes]/cast(sum([Reads&Writes]) over (partition by 1) as float)*100) as numeric(12,3)) [Reads&Writes(%)]
		,SampleDays,SampleSeconds 
		FROM @TBL order by [Reads&Writes] desc,Writes desc,Reads desc

	end
	end
	
	if @t=11
	--Данные по выполнению заданий на сервере (job-ов)
	exec srv.GetStatisticJobs

	if @t=12
	--Мониторинг статистики по sql ожиданиям
	exec srv.Get_Statistic_Waits

	if @t=13 --используемость индексов в БД, какие индексы можно убрать
	begin
	declare @INDEX nvarchar(max)
	set @INDEX='
	USE ['+@DATABASE+']
	SELECT  DB_NAME() БД,
	 o.name AS ObjectName
	 , i.name AS IndexName
	 , i.index_id AS IndexID
	 , dm_ius.user_seeks AS UserSeek
	 , dm_ius.user_scans AS UserScans
	 , dm_ius.user_lookups AS UserLookups
	 , dm_ius.user_updates AS UserUpdates
	 ,last_user_seek
	 ,last_user_scan
	 ,last_user_lookup
	 ,last_user_update
	 , p.TableRows
	 , ''DROP INDEX '' + QUOTENAME(i.name)
	 + '' ON '' + QUOTENAME(s.name) + ''.'' + QUOTENAME(OBJECT_NAME(dm_ius.OBJECT_ID)) AS ''drop statement''
	 FROM sys.dm_db_index_usage_stats dm_ius
	 INNER JOIN sys.indexes i ON i.index_id = dm_ius.index_id AND dm_ius.OBJECT_ID = i.OBJECT_ID
	 INNER JOIN sys.objects o ON dm_ius.OBJECT_ID = o.OBJECT_ID
	 INNER JOIN sys.schemas s ON o.schema_id = s.schema_id
	 INNER JOIN (SELECT  SUM(p.rows) TableRows, p.index_id, p.OBJECT_ID
	 FROM sys.partitions p GROUP BY p.index_id, p.OBJECT_ID) p
	 ON p.index_id = dm_ius.index_id AND dm_ius.OBJECT_ID = p.OBJECT_ID
	 WHERE OBJECTPROPERTY(dm_ius.OBJECT_ID,''IsUserTable'') = 1
	 AND dm_ius.database_id = DB_ID()
	 AND i.type_desc in(''clustered'', ''nonclustered'')
	 AND i.is_unique_constraint = 0
	 AND (o.name='''+@TABLE+''' or '''+@TABLE+'''='''')
	 ORDER BY (dm_ius.user_seeks + dm_ius.user_scans + dm_ius.user_lookups) ASC'

		begin try	
				exec sp_executesql @INDEX	
		end try
		begin catch
				print @INDEX
				select ERROR_MESSAGE() ERR_MSG
		end catch
	 end

	 if @t=14 --Фрагментированность индексов для БД
	 begin
	 --Контэйнер сбора фрагментированности по индексу
	 DECLARE @FRAG nvarchar(max)

		set @FRAG='
		USE ['+@DATABASE+']

	    SELECT  TOP  10000000000 DB_NAME() БД,b.object_id,c.name+''.''+b.name Таблица,
		s.[index],index_type_desc Тип_индекса,
		alloc_unit_type_desc Расположение,
		round(avg_fragmentation_in_percent,2) [Фрагментированность(%)],
		fragment_count Фрагментов,
		page_count Страниц_данных,
		avg_fragment_size_in_pages [Фрагменты/страницы]
		FROM sys.dm_db_index_physical_stats(DB_ID(), '+case when len(@TABLE)>0 then 'cast(object_id('''+@TABLE+''',''U'') as varchar(50))' else 'NULL' end+', NULL, NULL, '+case when @Index_Is_Detailed=0 then 'NULL' else '''DETAILED''' end+') a inner join
		sys.objects b on(a.object_id=b.object_id)
		inner join sys.schemas c on(b.schema_id=c.schema_id)
		left join 
		(SELECT  index_id id,name [index],[object_id] from sys.indexes) s on(b.object_id=s.[object_id] and a.[index_id]=s.id)
		WHERE alloc_unit_type_desc=''IN_ROW_DATA'' and ('''+@TABLE+'''='''' or b.name='''+@TABLE+''')
		order by c.name+''.''+b.name'

		begin try
				print @FRAG
				exec sp_executesql @FRAG
		end try
		begin catch
				select ERROR_MESSAGE () err_msg
		end catch
     end

	 if @t=15 --Все индексы в БД
	 begin
	 declare @IND nvarchar(4000)=''
	 set @IND=   
	 'USE ['+@DATABASE+']
	  declare @indexes table(ServerName nvarchar(255),[DB_Name] nvarchar(255),TableName nvarchar(255),IndexName nvarchar(255),type_desc nvarchar(255),[Индексов] int)
		insert into @indexes
		SELECT   cast(SERVERPROPERTY(N''MachineName'') as nvarchar(255)) AS ServerName ,
				DB_NAME() AS [DB_Name] ,
				o.Name AS TableName ,
				i.Name AS IndexName, i.type_desc,COUNT(*) OVER (PARTITION BY o.Name ) [Индексов]
		FROM    sys.objects o
				LEFT JOIN sys.indexes i ON o.object_id = i.object_id
		WHERE   o.Type = ''U'' 
				AND LEFT(i.Name, 1) <> ''_'' 

		SELECT  a.*,(case when b.TableName is not null then 1 else 0 end) [ExistsClustered] FROM @indexes a left join (SELECT  TableName from @indexes where type_desc=''CLUSTERED'') b 
		on(a.TableName=b.TableName)
		ORDER BY a.[Индексов] DESC,a.TableName '

		begin try
				print @IND
				exec sp_executesql @IND
		end try
		begin catch
				select ERROR_MESSAGE () err_msg
		end catch
	end
	if @t=16
	--Статистика чтений, записей по файлам
	  SELECT  db,NumberReads,NumberWrites
	  ,cast(NumberReads/(cast(sum(NumberReads) over (partition by 1) as float))*100 as numeric(12,3)) [NumberReads(%)]
	  ,cast(NumberWrites/(cast(sum(NumberWrites) over (partition by 1) as float))*100 as numeric(12,3)) [NumberWrites(%)]
	  ,(cast(sum(NumberReads) over (partition by 1)/cast(sum(NumberWrites+NumberReads) over (partition by 1) as float) as numeric(12,4)))*100 [% reads]
	  ,(cast(sum(NumberWrites) over (partition by 1)/cast(sum(NumberWrites+NumberReads) over (partition by 1) as float) as numeric(12,4)))*100 [% writes]
	  from
	  (SELECT  b.name db,sum(NumberReads) NumberReads,sum(NumberWrites) NumberWrites
	  from ::fn_virtualfilestats(NULL, NULL) a inner join sys.databases b on(a.DbId=b.database_id)
	  inner join  master.sys.master_files c on(a.DbId=c.database_id and  a.FileId=c.[file_id])
	  where b.name=@DATABASE or @DATABASE=''
	  group by b.name) a
	  order by 4 desc,5 desc

	  if @t=17
	  begin
	  declare @sql_17 nvarchar(4000)=''

	  set @sql_17='
	  use ['+@DATABASE+']
	  SELECT  db_NAME(a.database_id) db,b.name tbl,/*a.object_id,ind.name [index],*/sum(user_seeks) user_seeks,sum(user_scans) user_scans,sum(user_lookups) user_lookups,sum(user_updates) user_updates,max(last_user_update) last_user_update,max(last_user_seek) last_user_seek,max(last_user_scan) last_user_scan,max(last_user_lookup)  last_user_lookup
	  from sys.dm_db_index_usage_stats a inner join sys.objects b on(a.object_id=b.object_id)
	  left outer join sys.indexes ind on(a.index_id=ind.index_id and a.object_id=ind.object_id)
	  where db_NAME(a.database_id)='''+@DATABASE+''' and ('''+@TABLE+'''='''' or b.name='''+@TABLE+''')
	  group by db_NAME(a.database_id),b.name
	  order by 3,4,5,6'

	  	begin try
				print @sql_17
				exec sp_executesql @sql_17
		end try
		begin catch
				select ERROR_MESSAGE () err_msg
		end catch
	  end

	  if @t=18
	  begin
	  declare @V nvarchar(max)

	  declare @ON_ALL_DATABASE_sql nvarchar(2000)=''
	  set @ON_ALL_DATABASE_sql=case when @Unloading=0 then '' when @Unloading=1 then 'into ['+@DATABASE_Unloading+'].[dbo].['+@DATABASE+'_'+@type_desc_object+'_'+replace(cast(cast(getdate() as date) as nvarchar(50)),'-','')+']' end
	  declare @ON_ALL_DATABASE_sql2 nvarchar(2000)=''
	  set @ON_ALL_DATABASE_sql2=case when @Unloading=1 
	  then 'if object_id(''master.dbo.['+@DATABASE+'_'+@type_desc_object+'_'+replace(cast(cast(getdate() as date) as nvarchar(50)),'-','')+']'',''U'') is not null
	  drop table ['+@DATABASE+'_'+@type_desc_object+'_'+replace(cast(cast(getdate() as date) as nvarchar(50)),'-','')+']
	  ' else '
	  ' end

	  set @V=@ON_ALL_DATABASE_sql2+'
		WITH P AS (		SELECT  sum(qs.execution_count) execution_count,max(qs.last_execution_time) last_execution_time,
		cast(sum(qs.total_worker_time)/1000.0 as int) total_worker_time,sum(qs.total_rows) total_rows,sum(qs.total_physical_reads)+sum(qs.total_logical_reads) total_reads
		,obj.name obj,obj.type_desc,isnull(db.name,'''+@DATABASE+''') DB
		,cast(datediff(ss,(SELECT  create_date from sys.databases where name=''tempdb''),getdate())/(60.0*60.0*24.0) as numeric(11,2))  [Days]
		'+@ON_ALL_DATABASE_sql+'		
		FROM sys.dm_exec_query_stats qs
		CROSS APPLY sys.dm_exec_sql_text (qs.sql_handle) t 
		INNER JOIN sys.databases db  (nolock) on(t.dbid=db.database_id and db.name=N'''+@DATABASE+''')
		INNER JOIN ['+@DATABASE+'].sys.objects obj  (nolock) on(t.objectid=obj.object_id)
		
		where ('''+@type_desc_object+'''='''' or obj.type_desc='''+@type_desc_object+''' or obj.type='''+@type_desc_object+''') and ('''+@TABLE+'''='''' or obj.name='''+@TABLE+''')
		and ('''+@TABLE+'''='''' or obj.name='''+@TABLE+''' or obj.name='''+@TABLE+''') and left(obj.name,7)<>''Obsolet''
		group by t.[text],db.name,obj.name,obj.type_desc)

		SELECT execution_count,last_execution_time,total_worker_time,total_rows,total_reads,
		obj,[type_desc],DB,[Days]
		FROM P
		UNION
		SELECT NULL,NULL,NULL,NULL,NULL,[name] COLLATE Cyrillic_General_CI_AS,obj2.type_desc COLLATE Cyrillic_General_CI_AS,null,null 
		from ['+@DATABASE+'].sys.objects obj2 where 
			('''+@type_desc_object+'''='''' or obj2.type_desc='''+@type_desc_object+''' or obj2.type='''+@type_desc_object+''') and ('''+@TABLE+'''='''' or obj2.name='''+@TABLE+''')
		and ('''+@TABLE+'''='''' or obj2.name='''+@TABLE+''' or obj2.name='''+@TABLE+''') and left(obj2.name,7)<>''Obsolet''
		order by 1 desc'

		begin try
				exec sp_executesql @V
		end try
		begin catch
				select ERROR_MESSAGE() ERR_MSG
		end catch

	  end
	  if @t=19 --Кто активен и потребление ресурсов
	  begin
	  exec [srv].[Used_resouces_by_sessions]

	  exec [dbo].[sp_WhoIsActive_Admin]
	  end
	  if @t=20
	  begin
	  IF OBJECT_ID('tempdb..#temp_stat','U') IS NOT NULL
	  drop table #temp_stat

		SELECT  distinct TOP  50 --top 2000
		 db.name db,SUBSTRING(qt.TEXT, (qs.statement_start_offset/2)+1,
		((CASE qs.statement_end_offset
		WHEN -1 THEN DATALENGTH(qt.TEXT)
		ELSE qs.statement_end_offset
		END - qs.statement_start_offset)/2)+1) as script, 
		qs.execution_count,plan_handle,total_worker_time
		into #temp_stat
		FROM sys.dm_exec_query_stats qs
		CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) qt
		LEFT JOIN sys.databases db on(qt.dbid =db.database_id)
		ORDER BY total_worker_time DESC, execution_count DESC

		SELECT  TOP  100 db,script,execution_count,total_worker_time,query_plan from #temp_stat qs
		CROSS APPLY sys.dm_exec_query_plan(qs.plan_handle) qp
		where left(script,40) not in('SELECT  distinct referenced_database_name')
		and left(script,19) not in('SELECT  DB_NAME() DB')
		and (db=@DATABASE or @DATABASE='') and (script like ''+'%'+@TABLE+'%'+'' or @TABLE='')
		order by execution_count desc

	  IF OBJECT_ID('tempdb..#temp_stat','U') IS NOT NULL
	  drop table #temp_stat
	  end
	  if @t=21 and @like=1
	  begin
			if len(@t)>0 and @DATABASE=''
			exec srv.FindObject @name=@TABLE,@like=@like
			if len(@DATABASE)>0
			exec srv.All_Find_Ref_Other_DB @DBB=@DATABASE
	  end
	  if @t=21 and @like=0 and @DATABASE=''
	  begin
			exec [srv].[FindObj] @find=@TABLE
	  end
	  if @t=21 and @like=0 and 1=(SELECT  count(1) from sys.databases where name=@DATABASE)
	  begin
			exec [srv].[Depend_objects] @DB=@DATABASE,@obj=@TABLE,@job=@job
	  end
	  if @t=22
	  exec [srv].[DB_USE_DATASPACE] @DATABASE
  end
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Add extended property [MS_Description] on procedure [srv].[GetScalling_monitor_db]
--
EXEC sys.sp_addextendedproperty N'MS_Description', N'Общая процедура мониторинга SQL Server', 'SCHEMA', N'srv', 'PROCEDURE', N'GetScalling_monitor_db'
GO
IF @@ERROR<>0 OR @@TRANCOUNT=0 BEGIN IF @@TRANCOUNT>0 ROLLBACK SET NOEXEC ON END
GO

--
-- Commit Transaction
--
IF @@TRANCOUNT>0 COMMIT TRANSACTION
GO

--
-- Set NOEXEC to off
--
SET NOEXEC OFF
GO